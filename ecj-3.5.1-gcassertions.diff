diff -ruN ecj-3.5.1/GCASSERTIONS.README ecj-3.5.1-gcassertions/GCASSERTIONS.README
--- ecj-3.5.1/GCASSERTIONS.README	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/GCASSERTIONS.README	2010-03-04 02:49:14.000000000 +0000
@@ -0,0 +1,267 @@
+This is the README file for the ECJ part of the GC Assertions
+framework, version 3.
+
+
+Introduction
+============
+The GC Assertions framework for ECJ/Jikes consists of two components:
+a compiler (part of this package) and a modified Java VM (part of a
+separate package).  To use this framework, you need both packages.
+
+The GC Assertions framework allows you to place certain heap traversal
+assertions within Java source code.  These assertions are checked
+whenever executed, by exploiting the VM's regular garbage collection
+mechanism.  They assert certain object-local properties, but can
+assert these properties over all reachable objects on the heap, which
+would not normally be possible for a regular Java program.
+
+
+This documentation describes the setup and use of the GC Assertions
+framework and some high-level debugging operations.  To understand the
+inner workings of this mechanism or extend it, please make sure to
+also read the README file accompanying the Jikes component of this
+system.
+
+
+Setup
+=====
+To use the GC Assertions framework, you must install both this ECJ
+component and the Jikes component (available separately.)  This
+section describes how to install the ECJ component; to test your GC
+Assertions, you must also install the Jikes component.
+
+To build this package, run
+
+  ant
+
+in the root directory.  To test that compilation was successful, run
+
+  make test
+
+in the same directory.  The result should be some debug output and a
+number of green `OK' messages.  If you encounter any red `ERROR'
+messages, part of your setup may be broken.  In that case, run
+
+  make nonjikes-test
+
+If this eliminates all red messages, your compiler is fully
+operational but your Jikes component may or may not be fully
+operational.  Edit the `Makefile' and point the variable `JIKES' to
+the correct location of your Jikes runtime.  Either the
+BaseBaseGCAssertions runtime or the FastAdaptiveGCAssertions runtime
+are suitable.  Re-run `make test'; all of your error messages should
+now have disappeared.  If not, you may be running broken or
+incompatible versions of the ECJ or Jikes components.
+
+
+Usage
+=====
+You can run the modified Eclipse compiler as you would run any other
+Java compiler, and you can compile regular Java programs with it.
+This implementation provides additional debugging operations
+(cf. `Debugging interface,' below), but these are only of use for GC
+Assertions framework developers.
+
+To introduce a GC assertion into your code, use any of the following
+constructs:
+
+  GCAssert.assert( <assertion> )    // JDK 1.4 or earlier only
+  GCAssert.assertion( <assertion> )
+  GCAssert.asserDisjoint( <assertion> )
+  GCAssert.assumeDisjoint( <assertion> )
+
+where <assertion> is a pure boolean Java expression enlosed in double
+quotes.  This expression may contain any of the following:
+ - parentheses
+ - ||, &&, !
+ - ==, !=, <=, =>, <, >
+ - true, false
+ - integers
+ - `instanceof' checks
+ - null
+ - field access (e.g., `obj.value')
+ - references to program variables/fields
+ - references to quantified variables (see below)
+
+as well as the following special constructs, explained in the
+following:
+
+ - E1 -> E2		// short for !E1 || E2
+ - forall Type x : Body
+ - exists Type x : Body
+ - reach(spec)[x]
+
+The `forall' and `exists' forms take one type (`Type') and one
+variable (`x') that may be used within their `Body.'  They act as
+boolean expressions with the following meanings:
+
+  `forall Type x : Body' is true iff for all live objects `x' on the
+heap such that x is a subtype of `Type', the property `Body' holds.
+
+  `exists Type x : Body' is true iff there exists at least one live
+object `x' on the heap such that x is a subtype of `Type' and the
+property `Body' holds.
+
+  Within such a `Body', the form `reach(spec)[x]' is a boolean
+expression denoting the idea that `x is transitively reachable from
+spec' (see below for a discussion of reach specs.)
+This form is permissible only within a `Body', as long as `x' is the
+exact variable being quantified over:
+
+  forall Node x : reach(spec)[x]
+
+is permissible, but
+
+  forall Node x : reach(spec)[other_node]
+
+is not (even if `other_node' is a perfectly valid node.)
+
+Note that no `Body' may contain a `forall' or `exists' quantifier.
+Also, the forms of reach specs are restricted, as described below.
+
+Reach specs
+-----------
+
+A reach spec has the form (in quasi-BNF):
+
+ReachSpec ::= <ReachSpecItem>
+            | <ReachSpecItem> ',' ... ',' <ReachSpecItem>
+
+ReachSpecItem ::= <Set>
+                | <Set> '/' <Set>
+		|       '/' <Set>
+
+Set ::= <Var>
+      | '{' <Var> ',' ... ',' <Var> '}'
+
+where <Var> is a local variable or field.  A reach spec describes a
+set of objects on the heap through notions of `ancestors' and
+`filters'.  For example, the spec
+
+  { a, b, c } / { e, f }
+
+has three ancestors (a, b, c) and two filters (e, f).  This set
+describes all nodes that are reachable from `a', `b', or `c' without
+passing through `e' or `f'.
+
+Ancestors always appear to the left of a `/', filters on the right.
+If a reach spec (item) does not contain a slash, the specified set is
+assumed to be an ancestor set (with an empty filter set).  For
+simplicity, a singleton set
+
+  {a}
+
+  can be written
+
+  a
+
+
+Combining multiple reach spec items gives a cumulative effect:
+
+  a/b, c/d
+
+describes all nodes that are reachable either:
+- from `a' without passing through `b', or
+- from `c' without passing through `b' or passing through `d'.
+
+The special form
+
+  /X
+
+describes all nodes reachable from the root set without going through
+X.
+
+Reach specs are subject to the `Singularity Condition' or the
+`Disjointness Condition'.  When using the `GCAssert.assert' or
+`GCAssert.assertion' form, the singularity condition applies:
+
+  Singularity Condition:
+    For any GC assertion, there must be at most one `spec' such that
+    `reach(spec)[z]' occurs in the body of that assertion (for some
+    `z.')
+
+If this is too restrictive, the `GCAssert.assertDisjoint' form may be
+used.  This form has almost the same semantics as
+`GCAssert.assertion', except that the Singularity Condition is
+replaced by the less restrictive Disjoingness Condition.  However,
+checking is somewhat slower (around 10% over the cost of a single
+garbage collection or so.)
+
+  Disjointness Condition:
+    For any GC assertion, let `SPEC' be the set of all `spec' such
+    that `reach(spec)[z]' occurs in the body of that assertion (for
+    some `z.').  Then the sets of all objects reachable from any
+    specs in `SPEC' are mutually disjoint.
+
+Due to implmentation condsiderations, this set `SPEC' may be no larger
+than 15 (allowing 15 different reach specs in one assertion.)
+The system will test the Disjointness Condition and abort with an
+assertion failure similar to a regular assertion failure (but with a
+different error message) if the condition was not met.
+
+If this is still too restrictive, the `GCAssert.assumeDisjoint' form
+may be used.  This form carries no restrictions but is incomplete and
+unsound:  objects reachable from more than one distinct spec may be
+tested only partially, which may cause false negatives or false
+positives.
+
+
+Examples for using the assertions
+---------------------------------
+GCAssert.assertion("exists Object o : o instanceof MyClass")
+
+  There exists at least one live instance of MyClass.
+
+GCAssert.assertion("forall Object o : o instanceof MyClass -> o = v")
+
+  There exists precisely one live instance of MyClass, namely `v'.
+(`v' must be visible as a variable.)
+
+
+(please send me other commented, tested examples)
+
+
+Running against the stub library
+--------------------------------
+After compiling with `ecj', the resultant program cannot run
+standalone, as it relies on a special GC Assertions runtime
+interface.  ECJ provides a stub versions of this interface in the
+`org/mmtk' subdirectory.  Linking against the stubs contained therein
+should satisfy a regular Java runtime (cf. the `test-stub' test cases
+in `Makefile.')
+
+
+Running against Jikes
+---------------------
+Simply use the Jikes `rvm' executable to run the ECJ-compiled class
+files, after building Jikes for either BaseBaseGCAssertions or
+FastAdaptiveGCAssertions.
+
+(See the `test-jikes' test cases in `Makefile' for concrete examples.)
+
+
+Debugging interface
+===================
+This variant of ecj comes with additional debug flags:
+
+ecj -gcaDebug:hook
+
+  This will print a quick message describing the GC assertions
+
+ecj -gcaDebug:ast
+
+  Print the AST of the parsed GC assertion expression
+
+ecj -gcaDebug:T
+
+  Print the predicate families (T) for each quantified expression
+(cf. the paper)
+
+ecj -gcaDebug:traversal
+
+  Print the traversal program generated for each assertion (cf. the
+Jikes GCAssertions document)
+
+ecj -gcaDebug:all
+
+  This will print all of the above (and some more.)
diff -ruN ecj-3.5.1/Makefile ecj-3.5.1-gcassertions/Makefile
--- ecj-3.5.1/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/Makefile	2010-03-22 21:45:31.000000000 +0000
@@ -0,0 +1,98 @@
+ECJ=./ecj -gcaDebug:all
+ECJSILENT=./ecj
+ECJAST=./ecj -gcaDebug:ast
+ECJT=./ecj -gcaDebug:T
+ECJHOOK=./ecj -gcaDebug:hook
+EXPECT=./expect.sh
+JAVAC=javac
+JAVA=java
+SPECSTUB=./org/mmtk/plan/marksweep/gcassertions/spec/
+JIKES=../../../jikes/jikesrvm-3.1.0-gcassertions/dist/BaseBaseGCAssertions_x86_64-linux/rvm
+#JIKES=../../../jikes/jikesrvm-3.1.0-gcassertions/dist/FastAdaptiveGCAssertions_x86_64-linux/rvm
+
+.PHONY: build test test-disjoint default test-ast test-typecheck test-sanitycheck test-T test-magic test-stub test-jikes test-bugs
+
+default: build test
+
+test: test-disjoint test-ast test-typecheck test-sanitycheck test-T test-magic test-stub test-jikes
+nonjikes-test: test-disjoint test-ast test-typecheck test-sanitycheck test-T test-magic test-stub
+
+build:
+	ant
+
+test-disjoint:
+	${ECJHOOK} test/Node.java test/HookPresentAssert.java | ${EXPECT} ASSERTION assert
+	${ECJHOOK} test/Node.java test/HookPresentAssertDisjoint.java | ${EXPECT} ASSERTION assertDisjoint
+	${ECJHOOK} test/Node.java test/HookPresentAssumeDisjoint.java | ${EXPECT} ASSERTION assumeDisjoint
+
+test-ast:
+	${ECJAST} test/Node.java test/HookPresentAssert.java 2>/dev/null | ${EXPECT} -file test/HookPresentAssert.expect
+	${ECJAST} test/Node.java test/ASTOpPrecedence.java 2>/dev/null | ${EXPECT} -file test/ASTOpPrecedence.expect
+	${ECJAST} test/Node.java test/ReachSort.java 2>/dev/null | ${EXPECT} -file test/ReachSort.expect
+
+test-typecheck:
+	${ECJ} test/Node.java test/TyCheck0.java 2>/dev/null 2>&1 | ${EXPECT} ERROR
+	${ECJ} test/Node.java test/TyCheck1.java 2>/dev/null 2>&1 | ${EXPECT} ERROR
+	${ECJ} test/Node.java test/TyCheck2.java 2>/dev/null 2>&1 | ${EXPECT} ERROR
+	${ECJ} test/Node.java test/TyCheck3.java 2>/dev/null 2>&1 | ${EXPECT} ERROR
+	${ECJ} test/Node.java test/TyCheck4.java 2>/dev/null 2>&1 | ${EXPECT} ERROR
+	${ECJ} test/Node.java test/TyCheck5.java 2>/dev/null 2>&1 | ${EXPECT} ERROR
+	${ECJ} test/Node.java test/TyCheck6.java 2>/dev/null 2>&1 | ${EXPECT} ERROR
+	${ECJ} test/Node.java test/TyCheck7.java 2>/dev/null 2>&1 | ${EXPECT} ERROR
+	${ECJ} test/Node.java test/TyCheck8.java 2>/dev/null 2>&1 | ${EXPECT} ERROR
+
+test-sanitycheck:
+	${ECJ} test/Node.java test/SanityCheck0.java 2>/dev/null 2>&1 | ${EXPECT} ERROR
+	${ECJ} test/Node.java test/SanityCheck1.java 2>/dev/null 2>&1 | ${EXPECT} ERROR
+	${ECJ} test/Node.java test/SanityCheck2.java 2>/dev/null 2>&1 | ${EXPECT} ERROR
+	${ECJ} test/Node.java test/SanityCheck3.java 2>/dev/null 2>&1 | ${EXPECT} ERROR
+	${ECJ} test/Node.java test/SanityCheck4.java 2>/dev/null 2>&1 | ${EXPECT} ERROR
+	${ECJ} test/Node.java test/SanityCheck5.java 2>/dev/null 2>&1 | ${EXPECT} ERROR
+	${ECJ} test/Node.java test/SanityCheck6.java 2>/dev/null 2>&1 | ${EXPECT} ERROR
+	${ECJ} test/Node.java test/SanityCheck7.java 2>/dev/null 2>&1 | ${EXPECT} -not ERROR
+	${ECJ} test/Node.java test/SanityCheck8.java 2>/dev/null 2>&1 | ${EXPECT} -not ERROR
+	${ECJ} test/Node.java test/SanityCheck9.java 2>/dev/null 2>&1 | ${EXPECT} -not ERROR
+
+test-T:
+	${ECJT} test/Node.java test/TestT0.java 2>/dev/null 2>&1 | ${EXPECT} -shuffle -file test/TestT0.expect
+	${ECJT} test/Node.java test/TestT1.java 2>/dev/null 2>&1 | ${EXPECT} -shuffle -file test/TestT1.expect
+	${ECJT} test/Node.java test/TestT2.java 2>/dev/null 2>&1 | ${EXPECT} -shuffle -file test/TestT2.expect
+	${ECJT} test/Node.java test/TestT3.java 2>/dev/null 2>&1 | ${EXPECT} -shuffle -file test/TestT3.expect
+
+test-magic:
+	${ECJSILENT} test/Node.java test/MagicTestLibrary.java
+	${JAVAC} -cp . test/TestHarness.java test/MagicChecker.java 
+	${JAVA} -cp . test.MagicChecker
+
+test-stub:
+	${JAVAC} test/Node.java ${SPECSTUB}/*.java
+	${ECJSILENT} -1.5 -cp . test/HTIT*.java
+	${JAVA} -cp . test.HTIT0 2>&1 | ${EXPECT} -not Exception
+	${JAVA} -cp . test.HTIT1 2>&1 | ${EXPECT} -not Exception
+	${JAVA} -cp . test.HTIT2 2>&1 | ${EXPECT} -not Exception
+	${JAVA} -cp . test.HTIT3 2>&1 | ${EXPECT} -not Exception
+	${JAVA} -cp . test.HTIT4 2>&1 | ${EXPECT} -not Exception
+	${JAVA} -cp . test.HTIT5 2>&1 | ${EXPECT} -not Exception
+	${JAVA} -cp . test.HTIT6 2>&1 | ${EXPECT} -not Exception
+
+test-jikes:
+	rm -f ${SPECSTUB}/*.class
+	${ECJSILENT} -1.5 -cp . test/HTIT*.java
+	${JIKES} test.HTIT0 2>&1 | ${EXPECT} all-clear
+	${JIKES} test.HTIT1 2>&1 | ${EXPECT} Error
+	${JIKES} test.HTIT2 2>&1 | ${EXPECT} all-clear
+	${JIKES} test.HTIT3 2>&1 | ${EXPECT} all-clear
+	${JIKES} test.HTIT4 2>&1 | ${EXPECT} Error
+	${JIKES} test.HTIT5 2>&1 | ${EXPECT} all-clear
+	${JIKES} test.HTIT6 2>&1 | ${EXPECT} all-clear
+#	${JIKES} -X:gc:assertfrequency=60 -X:gc:assertonheapfull=true  -Xms2M -Xmx10M test.HTIT7
+	${JIKES} -X:gc:assertfrequency=1 -X:gc:assertonheapfull=true  -Xms5M -Xmx20M test.HTIT7 2>&1 | ${EXPECT} all-clear
+	${JIKES} test.HTIT8 2>&1 | ${EXPECT} all-clear
+
+t:
+	rm -f ${SPECSTUB}/*.class
+	${ECJSILENT} -gcaDebug:all -1.5 -cp . test/HTIT8.java
+	${JIKES} test.HTIT8
+
+test-bugs:
+	${ECJSILENT} -6 test/LLNode.java test/DLL.java 2>&1 | ${EXPECT} -file /dev/null
\ No newline at end of file
diff -ruN ecj-3.5.1/build.xml ecj-3.5.1-gcassertions/build.xml
--- ecj-3.5.1/build.xml	2009-04-28 16:53:02.000000000 +0000
+++ ecj-3.5.1-gcassertions/build.xml	2010-02-28 20:38:18.000000000 +0000
@@ -20,15 +20,17 @@
 		<mkdir dir="${output}" />
 
 		<javac srcdir="${basedir}" destdir="${output}"
-				debuglevel="lines,source"
+				debugLevel="lines,source"
+		       		debug="true"
 				source="1.3"
 				target="1.2"
-			excludes="org/eclipse/jdt/internal/compiler/tool/*,**/apt/**">
+			excludes="org/eclipse/jdt/internal/compiler/tool/*,**/apt/**,test/**">
 			<compilerarg line="-Xlint:none"/>
 		</javac>
 
 		<javac destdir="${output}"
-				debuglevel="lines,source"
+				debugLevel="lines,source"
+		       		debug="true"
 				source="1.6"
 				target="1.6"
 				includes="org/eclipse/jdt/internal/compiler/tool/*">
@@ -50,4 +52,4 @@
 		</zip>
 		<delete dir="${output}" />
 	</target>
-</project>
\ No newline at end of file
+</project>
diff -ruN ecj-3.5.1/ecj ecj-3.5.1-gcassertions/ecj
--- ecj-3.5.1/ecj	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/ecj	2010-03-03 22:16:28.000000000 +0000
@@ -0,0 +1,2 @@
+#! /bin/sh
+java -jar `dirname $0`/ecj.jar $@
diff -ruN ecj-3.5.1/expect.sh ecj-3.5.1-gcassertions/expect.sh
--- ecj-3.5.1/expect.sh	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/expect.sh	2010-03-02 03:07:18.000000000 +0000
@@ -0,0 +1,58 @@
+#! /bin/bash
+
+if [ x$1 == x ]; then
+    echo "Usage: $0 [-not] <text>"
+    echo "   OR: $0 [-not] [-shuffle] -file <file>"
+    echo "Prints OK or FAILED, with a diff, depending on wether stdin matches.  For"
+    echo "plain text, containment is sufficient, but other text requires a full match."
+    exit 1
+fi
+
+NOT=false
+if [ x$1 == x-not ]; then
+    NOT=true
+    shift 1
+fi
+
+FILTER="cat -"
+if [ x$1 == x-shuffle ]; then
+    FILTER="sort"
+    shift 1
+fi
+
+if [ x$1 == x-file ]; then
+    BASEFILE=`mktemp`
+    cat $2 | $FILTER > ${BASEFILE}
+    if $FILTER | diff -u ${BASEFILE} -; then
+	if ${NOT}
+	then 
+	    printf "\033[31;1mFAILED\033[0m\n"
+	else
+	    printf "\033[32;1mOK\033[0m\n"
+	fi
+    else
+	if ${NOT}
+	then 
+	    printf "\033[32;1mOK\033[0m\n"
+	else
+	    printf "\033[31;1mFAILED\033[0m\n"
+	fi
+    fi
+    rm -f ${BASEFILE}
+else
+    if grep -e "`echo "$@"`" -; then
+	if ${NOT}
+	then 
+	    printf "\033[31;1mFAILED\033[0m\n"
+	else
+	    printf "\033[32;1mOK\033[0m\n"
+	fi
+    else
+	if ${NOT}
+	then 
+	    printf "\033[32;1mOK\033[0m\n"
+	else
+	    printf "\033[31;1mFAILED\033[0m\n"
+	fi
+    fi
+fi
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ASTVisitor.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ASTVisitor.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ASTVisitor.java	2009-03-07 01:08:10.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ASTVisitor.java	2010-02-25 15:49:01.000000000 +0000
@@ -456,6 +456,24 @@
 	public void endVisit(Wildcard wildcard, ClassScope scope) {
 		// do nothing by default
 	}
+	public void endVisit(Assertion a, BlockScope scope) {
+		// do nothing by default
+	}
+	public void endVisit(Assertion a, ClassScope scope) {
+		// do nothing by default
+	}
+	public void endVisit(ReachExpression reach, BlockScope scope) {
+		// do nothing by default
+	}
+	public void endVisit(ReachExpression reach, ClassScope scope) {
+		// do nothing by default
+	}
+	public void endVisit(QuantifiedExpression qe, BlockScope scope) {
+		// do nothing by default
+	}
+	public void endVisit(QuantifiedExpression qe, ClassScope scope) {
+		// do nothing by default
+	}
 	public boolean visit(
     		AllocationExpression allocationExpression,
     		BlockScope scope) {
@@ -891,4 +909,22 @@
 	public boolean visit(Wildcard wildcard, ClassScope scope) {
 		return true; // do nothing by default, keep traversing
 	}
+	public boolean visit(Assertion a, BlockScope scope) {
+		return true; // do nothing by default, keep traversing
+	}
+	public boolean visit(Assertion a, ClassScope scope) {
+		return true; // do nothing by default, keep traversing
+	}
+	public boolean visit(ReachExpression reach, BlockScope scope) {
+		return true; // do nothing by default, keep traversing
+	}
+	public boolean visit(ReachExpression reach, ClassScope scope) {
+		return true; // do nothing by default, keep traversing
+	}
+	public boolean visit(QuantifiedExpression qe, BlockScope scope) {
+		return true; // do nothing by default, keep traversing
+	}
+	public boolean visit(QuantifiedExpression qe, ClassScope scope) {
+		return true; // do nothing by default, keep traversing
+	}
 }
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java	2009-03-07 01:08:07.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/AbstractMethodDeclaration.java	2010-02-28 20:29:09.000000000 +0000
@@ -227,10 +227,7 @@
 					argBinding.recordInitializationStartPC(0);
 				}
 			}
-			if (this.statements != null) {
-				for (int i = 0, max = this.statements.length; i < max; i++)
-					this.statements[i].generateCode(this.scope, codeStream);
-			}
+			this.generateStatementCode(codeStream);
 			// if a problem got reported during code gen, then trigger problem method creation
 			if (this.ignoreFurtherInvestigation) {
 				throw new AbortMethod(this.scope.referenceCompilationUnit().compilationResult, null);
@@ -249,6 +246,15 @@
 		classFile.completeMethodInfo(methodAttributeOffset, attributeNumber);
 	}
 
+	protected void
+	generateStatementCode(final CodeStream code_stream)
+	{
+		if (this.statements != null) {
+			for (int i = 0, max = this.statements.length; i < max; i++)
+				this.statements[i].generateCode(this.scope, code_stream);
+		}
+	}
+
 	private void checkArgumentsSize() {
 		TypeBinding[] parameters = this.binding.parameters;
 		int size = 1; // an abstact method or a native method cannot be static
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/Argument.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/Argument.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/Argument.java	2009-01-08 20:51:05.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/Argument.java	2010-03-03 17:50:52.000000000 +0000
@@ -30,7 +30,6 @@
 	}
 
 	public void bind(MethodScope scope, TypeBinding typeBinding, boolean used) {
-
 		// record the resolved type into the type reference
 		Binding existingVariable = scope.getBinding(this.name, Binding.VARIABLE, this, false /*do not resolve hidden field*/);
 		if (existingVariable != null && existingVariable.isValidBinding()){
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/Assertion.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/Assertion.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/Assertion.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/Assertion.java	2010-03-18 23:00:11.000000000 +0000
@@ -0,0 +1,222 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2008 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.compiler.ast;
+
+import java.util.ArrayList;
+
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.ASTVisitor;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.codegen.BranchLabel;
+import org.eclipse.jdt.internal.compiler.codegen.CodeStream;
+import org.eclipse.jdt.internal.compiler.flow.FlowContext;
+import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
+import org.eclipse.jdt.internal.compiler.impl.Constant;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.problem.*;
+import org.eclipse.jdt.internal.compiler.util.Messages;
+import org.eclipse.jdt.internal.compiler.gca.Debug;
+import org.eclipse.jdt.internal.compiler.gca.PredicateLinkage;
+import org.eclipse.jdt.internal.compiler.gca.PredicateFamily;
+import org.eclipse.jdt.internal.compiler.gca.GCANodeFactory;
+import org.eclipse.jdt.internal.compiler.ASTVisitor;
+import java.util.*;
+
+public class Assertion extends Expression
+{
+	private static int predicate_object_bindings_counter = 0;
+
+	public static final int ASSERT = 1;
+	public static final int ASSERT_DISJOINT = 2;
+	public static final int ASSUME_DISJOINT = 3;
+	public static final int ASSERT_DEBUG = 4; // only emit static helper methods; used for debugging the compiler
+
+	public QuantifiedExpression[] qexprs; // All contained quantified expressions
+	public Expression body;
+	public final int kind;
+	public int method_offset; // predicate methods offset
+	public BlockScope scope;
+	public PredicateLinkage linkage;
+	public LocalVariableBinding predicate_object_bindings;
+	public HashSet /* SingleNameReference */ contained_names;
+	TypeDeclaration declaring_class;
+
+
+	public Assertion(final int _kind, final Expression _body)
+	{
+		super();
+		this.kind = _kind;
+		this.body = _body;
+		this.constant = Constant.NotAConstant;
+	}
+	
+	public boolean
+	checkUnsafeCast(Scope scope, TypeBinding castType, TypeBinding expressionType, TypeBinding match, boolean isNarrowing)
+	{
+		return false;
+	}
+
+	/**
+	 * Every expression is responsible for generating its implicit conversion when necessary.
+	 *
+	 * @param currentScope org.eclipse.jdt.internal.compiler.lookup.BlockScope
+	 * @param codeStream org.eclipse.jdt.internal.compiler.codegen.CodeStream
+	 * @param valueRequired boolean
+	 */
+	public void
+	generateCode(final BlockScope currentScope, CodeStream codeStream, boolean valueRequired)
+	{
+		if (this.kind == ASSERT_DEBUG)
+			return; // don't generate code in debug mode
+
+		if (linkage == null)
+			throw new RuntimeException("Internal error: Trying to emit assertion without prior linking!");
+
+		linkage.emit(codeStream, currentScope, this.predicate_object_bindings.resolvedPosition,
+			     this.declaring_class, this.method_offset, this.body, this.kind == ASSERT_DISJOINT);
+
+		if (valueRequired)
+			codeStream.iconst_0(); // we're void, so this shouldn't really ever happen.
+	}
+
+	public int
+	generateStaticHelperMethods(final ProblemReporter problem_reporter, final int _method_offset,
+				    final TypeDeclaration _declaring_class)
+	{
+		findQuantifiedExpressions(problem_reporter);
+		this.method_offset = _method_offset;
+		this.declaring_class = _declaring_class;
+		return emitQuantifiedExpressions(problem_reporter, method_offset, _declaring_class);
+	}
+
+	private void
+	findQuantifiedExpressions(final ProblemReporter problem_reporter)
+	{
+		final LinkedList qexprs_ll = new LinkedList();
+
+		traverse(new ASTVisitor() {
+				public boolean visit(final QuantifiedExpression e, final BlockScope _) {
+					qexprs_ll.addLast(e);
+					return false;
+				}
+				public boolean visit(final ReachExpression e, final BlockScope _) {
+					problem_reporter.abortDueToInternalError("`reach' outside of quantifier", Assertion.this);
+					return false;
+				}
+			}, (BlockScope) null);
+
+		this.qexprs = new QuantifiedExpression[qexprs_ll.size()];
+
+		for (int i = 0; i < qexprs_ll.size(); i++) {
+			this.qexprs[i] = (QuantifiedExpression) qexprs_ll.get(i);
+			Debug.println("extraction", "aq#" + i + ": " + this.qexprs[i].toString());
+			this.qexprs[i].locateReachExpressions(problem_reporter);
+			this.qexprs[i].setQExprIndex(this, i);
+
+		}
+		if (this.kind == ASSERT) { // assert disjointness statically if needed
+			ReachSpec rs = null;
+			for (int qi = 0; qi < this.qexprs.length; qi++) {
+				final QuantifiedExpression q = this.qexprs[qi];
+				if (q.reach_expressions.length > 0) {
+					if (rs == null)
+						rs = q.reach_expressions[0].reach_spec;
+
+					for (int ri = 0; ri < q.reach_expressions.length; ri++)
+						if (!q.reach_expressions[ri].reach_spec.equals(rs))
+							problem_reporter.abortDueToInternalError("reach("
+												 + q.reach_expressions[ri].reach_spec
+												 + ") does not match reach("
+												 + rs
+												 + "); use `assertDisjoint' or `assumeDisjoint' instead of `assert'",
+												 q);
+				}
+
+			}
+		}
+
+	}
+
+	private int
+	emitQuantifiedExpressions(final ProblemReporter problem_reporter,
+				  final int offset, final TypeDeclaration declaring_class)
+	{
+		this.linkage = new PredicateLinkage();
+
+		for (int i = 0; i < this.qexprs.length; i++) {
+			final PredicateFamily predicate_family = GCANodeFactory.SINGLETON.build(this.qexprs[i], this.scope);
+			this.linkage.addPredicateFamily(predicate_family);
+			Debug.println("extraction", predicate_family.toString());
+		}
+		this.linkage.link();
+		return this.linkage.addMethods(declaring_class, this, offset);
+	}
+
+	public StringBuffer printExpression(int indent, StringBuffer output)
+	{
+		output.append(body.toString());
+		return output;
+	}
+
+
+	/**
+	 * Traverse an expression in the context of a blockScope
+	 * @param visitor
+	 * @param scope
+	 */
+	public void traverse(ASTVisitor visitor, BlockScope scope)
+	{
+		if (visitor.visit(this, scope))
+			body.traverse(visitor, scope);
+		visitor.endVisit(this, scope);
+	}
+
+	/**
+	 * Traverse an expression in the context of a classScope
+	 * @param visitor
+	 * @param scope
+	 */
+	public void
+	traverse(ASTVisitor visitor, ClassScope scope)
+	{
+		if (visitor.visit(this, scope)) {
+			body.traverse(visitor, scope);
+		}
+		visitor.endVisit(this, scope);
+	}
+	
+
+	public TypeBinding resolveType(BlockScope scope) {
+
+		this.predicate_object_bindings = new LocalVariableBinding(("__P" + predicate_object_bindings_counter++).toCharArray(),
+									  null,
+									  0,
+									  false
+									  );
+		this.predicate_object_bindings.useFlag = LocalVariableBinding.USED;
+		scope.addLocalVariable(this.predicate_object_bindings);
+		this.predicate_object_bindings.setConstant(Constant.NotAConstant);
+
+		final TypeBinding ty = this.body.resolveTypeExpecting(scope, TypeBinding.BOOLEAN);
+		this.scope = scope;
+		return TypeBinding.VOID;
+	}
+
+	public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
+		Iterator it = this.contained_names.iterator();
+		while (it.hasNext()) {
+			SingleNameReference snr = (SingleNameReference) it.next();
+			flowInfo = snr.analyseCode(currentScope, flowContext, flowInfo);
+		}
+
+		return flowInfo;
+	}
+}
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/AssertionPredicateMethod.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/AssertionPredicateMethod.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/AssertionPredicateMethod.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/AssertionPredicateMethod.java	2010-03-01 17:58:19.000000000 +0000
@@ -0,0 +1,90 @@
+package org.eclipse.jdt.internal.compiler.ast;
+
+import org.eclipse.jdt.core.compiler.*;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.flow.FlowInfo;
+import org.eclipse.jdt.internal.compiler.flow.InitializationFlowContext;
+import org.eclipse.jdt.internal.compiler.impl.*;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.problem.*;
+import org.eclipse.jdt.internal.compiler.parser.*;
+import org.eclipse.jdt.internal.compiler.gca.GCAClosure;
+import org.eclipse.jdt.internal.compiler.util.Util;
+
+/**
+ * Auto-generated from Assertions
+ */
+public class AssertionPredicateMethod extends AbstractMethodDeclaration
+{
+	public Assertion assertion;
+	public TypeDeclaration declaring_class;
+	public int id;
+	public GCAClosure closure;
+
+	public AssertionPredicateMethod(final int _id,
+					final Assertion _assertion,
+					final TypeDeclaration _declaring_class,
+					final GCAClosure _closure)
+	{
+		super(_declaring_class.compilationResult);
+		this.declaring_class = _declaring_class;
+		this.id = _id;
+		this.assertion = _assertion;
+		this.closure = _closure;
+		final ClassScope class_scope = _declaring_class.scope;
+		this.scope = new MethodScope(class_scope, class_scope.referenceContext, true);
+
+		init();
+	}
+
+	public void
+	init()
+	{
+		String suffix = "" + this.id;
+		while (suffix.length() < 4)
+			suffix = "0" + suffix;
+		final String method_name = "__magic_predicate$" + suffix;
+
+		this.modifiers = ClassFileConstants.AccFinal | ClassFileConstants.AccStatic | ClassFileConstants.AccPublic;
+		this.selector = method_name.toCharArray();
+
+		final TypeBinding object_ty_binding = scope.getJavaLangObject();
+		final TypeBinding object_array_ty_binding = new ArrayBinding(scope.getJavaLangObject(), 1, scope.environment());
+		final SingleTypeReference object_ty_ref = new SingleTypeReference("Object".toCharArray(), 0L);
+		object_ty_ref.resolvedType = object_ty_binding;
+		final SingleTypeReference object_array_ty_ref = new SingleTypeReference("Object[]".toCharArray(), 0L);
+		object_ty_ref.resolvedType = object_array_ty_binding;
+
+		this.binding =
+			new MethodBinding(this.modifiers,
+					  this.selector,
+					  TypeBinding.BOOLEAN,
+					  new TypeBinding[] { object_ty_binding,
+							      object_array_ty_binding },
+					  new ReferenceBinding[0],
+					  this.declaring_class.binding);
+		this.statements = null;
+
+		final Argument arg_x = new Argument(new char[] {'x'}, 0L,
+						    object_ty_ref,
+						    ClassFileConstants.AccFinal);
+		final Argument arg_env = new Argument(new char[] {'e', 'n', 'v'}, 0L,
+						      object_array_ty_ref,
+						      ClassFileConstants.AccFinal);
+		arg_x.bind(this.scope, object_ty_binding, true);
+		arg_env.bind(this.scope, object_array_ty_binding, true);
+		this.arguments = new Argument[] { arg_x, arg_env };
+	}
+				
+
+	public void analyseCode(ClassScope classScope, InitializationFlowContext initializationContext, FlowInfo info) {}
+	public void parseStatements(Parser parser, CompilationUnitDeclaration unit) {}
+
+	protected void
+	generateStatementCode(final CodeStream code_stream)
+	{
+		closure.emit(this.scope, code_stream);
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java	2008-11-26 17:56:55.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java	2010-02-25 20:35:41.000000000 +0000
@@ -35,6 +35,12 @@
 	public Expression left, right;
 	public Constant optimizedBooleanConstant;
 
+
+	public String toString()
+	{
+		return "(" + left.toString() + ") " + operatorToString() + " (" + right.toString() + ")";
+	}
+
 public BinaryExpression(Expression left, Expression right, int operator) {
 	this.left = left;
 	this.right = right;
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java	2009-03-07 01:08:07.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java	2010-02-20 02:45:08.000000000 +0000
@@ -811,7 +811,8 @@
 
 			// check whether comparing identical expressions
 			Binding leftDirect = Expression.getDirectBinding(this.left);
-			if (leftDirect != null && leftDirect == Expression.getDirectBinding(this.right)) {
+			if (leftDirect != null && leftDirect == Expression.getDirectBinding(this.right)
+					&& !(this.right instanceof Assignment)) {
 				scope.problemReporter().comparingIdenticalExpressions(this);
 			}
 			return this.resolvedType = TypeBinding.BOOLEAN;
@@ -848,7 +849,9 @@
 			// check whether comparing identical expressions
 			Binding leftDirect = Expression.getDirectBinding(this.left);
 			if (leftDirect != null && leftDirect == Expression.getDirectBinding(this.right)) {
-				scope.problemReporter().comparingIdenticalExpressions(this);
+				if (!(this.right instanceof Assignment)) {
+					scope.problemReporter().comparingIdenticalExpressions(this);
+				}
 			}
 			return this.resolvedType = TypeBinding.BOOLEAN;
 		}
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java	2009-03-07 01:08:07.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/InstanceOfExpression.java	2010-02-25 13:55:02.000000000 +0000
@@ -101,4 +101,9 @@
 	}
 	visitor.endVisit(this, scope);
 }
+
+	public String toString()
+	{
+		return "(" + expression.toString() + ") instanceof " + type.toString();
+	}
 }
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java	2009-03-07 00:58:58.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/LocalDeclaration.java	2010-03-03 19:04:18.000000000 +0000
@@ -20,6 +20,7 @@
 public class LocalDeclaration extends AbstractVariableDeclaration {
 
 	public LocalVariableBinding binding;
+	public boolean quantifier_bound = false; // defined in quantifier 
 
 	public LocalDeclaration(
 		char[] name,
@@ -33,6 +34,7 @@
 	}
 
 public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
+
 	// record variable initialization if any
 	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0) {
 		this.bits |= ASTNode.IsLocalDeclarationReachable; // only set if actually reached
@@ -225,6 +227,11 @@
 		}
 		// only resolve annotation at the end, for constant to be positionned before (96991)
 		resolveAnnotations(scope, this.annotations, this.binding);
+		this.binding.useFlag = LocalVariableBinding.USED;
+		if (this.quantifier_bound) {
+			this.binding.useFlag = LocalVariableBinding.USED;
+			this.binding.quantifier_binding = true;
+		}
 	}
 
 	public void traverse(ASTVisitor visitor, BlockScope scope) {
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/NameReference.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/NameReference.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/NameReference.java	2009-02-05 09:38:11.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/NameReference.java	2010-03-19 03:41:33.000000000 +0000
@@ -12,7 +12,7 @@
 
 import org.eclipse.jdt.internal.compiler.lookup.*;
 
-public abstract class NameReference extends Reference implements InvocationSite {
+public abstract class NameReference extends Reference implements InvocationSite, Comparable {
 
 	public Binding binding; //may be aTypeBinding-aFieldBinding-aLocalVariableBinding
 
@@ -29,6 +29,12 @@
 	this.bits |= Binding.TYPE | Binding.VARIABLE; // restrictiveFlag
 }
 
+public int
+compareTo(Object _)
+{
+	throw new RuntimeException("Comparisons unimplemented!");
+}
+
 public FieldBinding fieldBinding() {
 	//this method should be sent ONLY after a check against isFieldReference()
 	//check its use doing senders.........
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/NumberLiteral.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/NumberLiteral.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/NumberLiteral.java	2009-03-07 00:58:57.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/NumberLiteral.java	2010-02-26 16:19:18.000000000 +0000
@@ -30,4 +30,10 @@
 	public char[] source(){
 		return this.source;
 	}
+
+	public String
+	toString()
+	{
+		return new String(source);
+	}
 }
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java	2009-03-07 01:08:07.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java	2010-02-26 05:00:59.000000000 +0000
@@ -1504,8 +1504,14 @@
 		return get_AND();
 	}
 
+	public int
+	getOperatorId()
+	{
+		return (this.bits & OperatorMASK) >> OperatorSHIFT;
+	}
+
 	public String operatorToString() {
-		switch ((this.bits & OperatorMASK) >> OperatorSHIFT) {
+		switch (this.getOperatorId()) {
 			case EQUAL_EQUAL :
 				return "=="; //$NON-NLS-1$
 			case LESS_EQUAL :
@@ -1567,4 +1573,5 @@
 	}
 
 	public abstract StringBuffer printExpressionNoParenthesis(int indent, StringBuffer output);
+
 }
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java	2009-03-07 00:58:59.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/QualifiedNameReference.java	2010-03-19 03:43:10.000000000 +0000
@@ -40,7 +40,7 @@
 import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
 import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
 
-public class QualifiedNameReference extends NameReference {
+public class QualifiedNameReference extends NameReference implements Comparable {
 
 	public char[][] tokens;
 	public long[] sourcePositions;
@@ -59,6 +59,15 @@
 	this.sourceEnd = sourceEnd;
 }
 
+public int
+compareTo(Object o)
+{
+	if (o instanceof QualifiedNameReference)
+		return (this.toString().compareTo(o.toString()));
+	else
+		return 1;
+}
+
 public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, Assignment assignment, boolean isCompound) {
 	// determine the rank until which we now we do not need any actual value for the field access
 	int otherBindingsCount = this.otherBindings == null ? 0 : this.otherBindings.length;
@@ -1033,4 +1042,15 @@
 public String unboundReferenceErrorName() {
 	return new String(this.tokens[0]);
 }
+	public String toString()
+	{
+		String s = "";
+		for (int i = 0; i < tokens.length; i++) {
+			if (i > 0)
+				s += ".";
+			s += new String(tokens[i]);
+		}
+		return s;
+	}
+
 }
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/QuantifiedExpression.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/QuantifiedExpression.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/QuantifiedExpression.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/QuantifiedExpression.java	2010-03-03 18:29:20.000000000 +0000
@@ -0,0 +1,144 @@
+package org.eclipse.jdt.internal.compiler.ast;
+
+import org.eclipse.jdt.internal.compiler.impl.*;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+import org.eclipse.jdt.internal.compiler.flow.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.gca.*;
+import org.eclipse.jdt.internal.compiler.ASTVisitor;
+import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
+import java.util.*;
+
+public class QuantifiedExpression extends Expression
+{
+	public static final boolean UNIVERSAL = false;
+	public static final boolean EXISTENTIAL = true;
+
+	public final boolean existential;
+	public Expression body;
+	public Argument variable;
+	public int qexpr_index = -1; // Magic index.  During code generation, this is our relative offset to the qexpr local variable index.
+	public Assertion owner_assertion;
+
+	ReachExpression[] reach_expressions; // contained reach expressions
+
+	public
+	QuantifiedExpression(final boolean _existential,
+			     final Argument _variable,
+			     final Expression _body)
+	{
+		super();
+		this.existential = _existential;
+		this.variable = _variable;
+		this.body = _body;
+		this.constant = Constant.NotAConstant;
+		this.variable.quantifier_bound = true;
+	}
+
+	void
+	setQExprIndex(final Assertion _owner, final int i)
+	{
+		this.owner_assertion = _owner;
+		this.qexpr_index = i;
+	}
+
+	void
+	locateReachExpressions(final ProblemReporter problem_reporter)
+	{
+		final LinkedList rexpr_ll = new LinkedList();
+
+		this.body.traverse(new ASTVisitor() {
+				public boolean visit(final QuantifiedExpression e, final BlockScope _) {
+					problem_reporter.abortDueToInternalError("Quantified expression `" + e + "' inside `" + QuantifiedExpression.this.toString() + "'",
+										 QuantifiedExpression.this);
+					return false;
+				}
+				public boolean visit(final ReachExpression e, final BlockScope _) {
+					rexpr_ll.addLast(e);
+					return false;
+				}
+			}, (BlockScope) null);
+
+		this.reach_expressions = new ReachExpression[rexpr_ll.size()];
+		for (int i = 0; i < rexpr_ll.size(); i++) {
+			this.reach_expressions[i] = (ReachExpression) rexpr_ll.get(i);
+			Debug.println("extraction", "  qr#" + i + ": " + this.reach_expressions[i].toString());
+			if (this.reach_expressions[i].parameter.binding != this.variable.binding)
+				problem_reporter.abortDueToInternalError("Parameter to `reach' must be quantified variable", this.reach_expressions[i]);
+			this.reach_expressions[i].reach_spec.assertNotVariable(this.variable.binding, problem_reporter, this);
+		}
+	}
+
+	public String
+	toString()
+	{
+		String quant = this.existential ? "exists" : "forall";
+		return quant + " " + ((new String(this.variable.name))) + ": " + this.body.toString();
+	}
+
+	public StringBuffer printExpression(int indent, StringBuffer output)
+	{
+		return output.append(toString());
+	}
+
+	/**
+	 * Every expression is responsible for generating its implicit conversion when necessary.
+	 *
+	 * @param currentScope org.eclipse.jdt.internal.compiler.lookup.BlockScope
+	 * @param codeStream org.eclipse.jdt.internal.compiler.codegen.CodeStream
+	 */
+	public void
+	generateCode(BlockScope currentScope, CodeStream cs, boolean _)
+	{
+		cs.aload(this.owner_assertion.predicate_object_bindings.resolvedPosition);
+		cs.generateInlinedValue(this.qexpr_index);
+		cs.aaload();
+		cs.doInvokeVirtual(PredicateLinkage.GCA_PREDICATE_FAMILY, "value", new String[] {}, "Z");
+	}
+
+	public TypeBinding resolveType(BlockScope scope) {
+		MethodScope sub_scope = new MethodScope(scope, scope.outerMostMethodScope().referenceContext, false);
+//		BlockScope sub_scope = new BlockScope(scope);
+//		System.err.println("FROM-SCOPE : " + scope);
+//		System.err.println("RESOLVE-TYPE : " + sub_scope);
+//		this.variable.bind(sub_scope, null, true);
+		this.variable.resolve(sub_scope);
+//		System.err.println("  added var");
+
+ 		if (!this.variable.type.resolveType(sub_scope, true).isCompatibleWith(scope.getJavaLangObject())) {
+ 			scope.problemReporter().typeMismatchError(this.variable.type.resolveType(sub_scope, true), sub_scope.getJavaLangObject(), this.variable, null);
+ 			return null;
+ 		}
+//		this.body.resolve(sub_scope);
+		final TypeBinding ty = this.body.resolveTypeExpecting(sub_scope, TypeBinding.BOOLEAN);
+		return TypeBinding.BOOLEAN;
+	}
+
+	/**
+	 * Traverse an expression in the context of a blockScope
+	 * @param visitor
+	 * @param scope
+	 */
+	public void
+	traverse(ASTVisitor visitor, BlockScope scope)
+	{
+		if (visitor.visit(this, scope)) {
+			body.traverse(visitor, scope);
+		}
+		visitor.endVisit(this, scope);
+	}
+
+	/**
+	 * Traverse an expression in the context of a classScope
+	 * @param visitor
+	 * @param scope
+	 */
+	public void
+	traverse(ASTVisitor visitor, ClassScope scope)
+	{
+		if (visitor.visit(this, scope))
+			body.traverse(visitor, scope);
+		visitor.endVisit(this, scope);
+	}
+}
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/QuantifiedExpressionResultIndex.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/QuantifiedExpressionResultIndex.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/QuantifiedExpressionResultIndex.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/QuantifiedExpressionResultIndex.java	2010-02-23 01:03:16.000000000 +0000
@@ -0,0 +1,44 @@
+package org.eclipse.jdt.internal.compiler.ast;
+
+import org.eclipse.jdt.internal.compiler.impl.*;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+import org.eclipse.jdt.internal.compiler.flow.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+
+public class QuantifiedExpressionResultIndex extends Expression
+{
+
+	public final int index;
+
+	public
+	QuantifiedExpressionResultIndex(final int _index)
+	{
+		super();
+		this.index = _index;
+	}
+
+	public String
+	toString()
+	{
+		return "$_" + index;
+	}
+
+	public StringBuffer printExpression(int indent, StringBuffer output)
+	{
+		return output.append(toString());
+	}
+
+	/**
+	 * Every expression is responsible for generating its implicit conversion when necessary.
+	 *
+	 * @param currentScope org.eclipse.jdt.internal.compiler.lookup.BlockScope
+	 * @param codeStream org.eclipse.jdt.internal.compiler.codegen.CodeStream
+	 * @param valueRequired boolean
+	 */
+	public void
+	generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired)
+	{
+		throw new RuntimeException("FIXME!");
+	}
+}
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/ReachExpression.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/ReachExpression.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/ReachExpression.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/ReachExpression.java	2010-03-09 21:37:01.000000000 +0000
@@ -0,0 +1,80 @@
+package org.eclipse.jdt.internal.compiler.ast;
+
+import org.eclipse.jdt.internal.compiler.impl.*;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+import org.eclipse.jdt.internal.compiler.flow.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.gca.Debug;
+import org.eclipse.jdt.internal.compiler.ASTVisitor;
+import java.util.*;
+
+public class ReachExpression extends Expression
+{
+	public ReachSpec reach_spec;
+	public SingleNameReference parameter;
+
+	public
+	ReachExpression(final SingleNameReference _parameter, final ReachSpec _reach_spec)
+	{
+		super();
+		this.reach_spec = _reach_spec;
+		this.parameter = _parameter;
+		this.constant = Constant.NotAConstant;
+		this.resolvedType = TypeBinding.BOOLEAN;
+	}
+
+	public String
+	toString()
+	{
+		return "reach[" + this.reach_spec.toString() + "](" + (new String(this.parameter.token)).toString() + ")";
+	}
+
+	public StringBuffer printExpression(int indent, StringBuffer output)
+	{
+		return output.append(toString());
+	}
+
+	/**
+	 * Every expression is responsible for generating its implicit conversion when necessary.
+	 *
+	 * @param currentScope org.eclipse.jdt.internal.compiler.lookup.BlockScope
+	 * @param codeStream org.eclipse.jdt.internal.compiler.codegen.CodeStream
+	 * @param valueRequired boolean
+	 */
+	public void
+	generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired)
+	{
+		throw new RuntimeException("ReachExpressions must never be used to generate code!");
+	}
+
+	public TypeBinding resolveType(BlockScope scope) {
+		this.parameter.resolveTypeExpecting(scope, scope.getJavaLangObject());
+		this.reach_spec.resolveTypes(scope);
+		return TypeBinding.BOOLEAN;
+	}
+
+	/**
+	 * Traverse an expression in the context of a blockScope
+	 * @param visitor
+	 * @param scope
+	 */
+	public void
+	traverse(ASTVisitor visitor, BlockScope scope)
+	{
+		visitor.visit(this, scope);
+		visitor.endVisit(this, scope);
+	}
+
+	/**
+	 * Traverse an expression in the context of a classScope
+	 * @param visitor
+	 * @param scope
+	 */
+	public void
+	traverse(ASTVisitor visitor, ClassScope scope)
+	{
+		visitor.visit(this, scope);
+		visitor.endVisit(this, scope);
+	}
+}
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/ReachSpec.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/ReachSpec.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/ReachSpec.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/ReachSpec.java	2010-03-19 03:48:24.000000000 +0000
@@ -0,0 +1,193 @@
+package org.eclipse.jdt.internal.compiler.ast;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
+
+/**
+ * Reachability spec.  Captures e.g. `{a, b} / {c}, d
+ */
+public class ReachSpec
+{
+	public Traversal[] traversals;
+
+	public
+	ReachSpec(final Traversal[] _traversals)
+	{
+		this.traversals = _traversals;
+	}
+
+	public boolean
+	isDominator()
+	{
+		return (traversals.length > 0
+			&& traversals[0].sources.length == 0);
+	}
+
+	public void
+	resolveTypes(final BlockScope scope)
+	{
+		final TypeBinding tb = scope.getJavaLangObject();
+		for (int i = 0; i < traversals.length; i++)
+			traversals[i].resolveTypes(scope, tb);
+	}
+
+	/**
+	 * asserts that the parameter binding does not occur in this spec
+	 */
+	public void
+	assertNotVariable(final VariableBinding vb, final ProblemReporter problem_reporter, final ASTNode node)
+	{
+		for (int i = 0; i < traversals.length; i++)
+			traversals[i].assertNotVariable(vb, problem_reporter, node);
+	}
+
+	public int
+	hashCode()
+	{
+		int v = 0;
+		for (int i = 0; i < this.traversals.length; i++)
+			v = (v << 1) + this.traversals[i].hashCode();
+		return v;
+	}
+
+	public boolean
+	equals(final Object o)
+	{
+		if (!(o instanceof ReachSpec))
+			return false;
+		final ReachSpec other = (ReachSpec) o;
+
+		if (other.traversals.length != this.traversals.length)
+			return false;
+
+		for (int i = 0; i < this.traversals.length; i++)
+			if (!this.traversals[i].equals(other.traversals[i]))
+				return false;
+
+		return true;
+	}
+
+	public String
+	toString()
+	{
+		String s = "";
+		for (int i = 0; i < this.traversals.length; i++) {
+			s += this.traversals[i].toString();
+			if (i + 1 < this.traversals.length)
+				s += ", ";
+		}
+		return s;
+	}
+
+	public static class
+	Traversal
+	{
+		public NameReference[] sources;
+		public NameReference[] ignores;
+
+		static NameReference[]
+		make_sorted_array(final NameReference [] _src)
+		{
+			if (_src == null)
+				return new NameReference[0];
+
+			java.util.Arrays.sort(_src);
+			return _src;
+		}
+
+		static boolean
+		compare_arrays(final NameReference [] a,
+			       final NameReference [] b)
+		{
+			if (a.length != b.length)
+				return false;
+
+			for (int i = 0; i < a.length; i++)
+				if (a[i].compareTo(b[i]) != 0)
+					return false;
+			return true;
+		}
+
+		static String
+		array_to_string(final NameReference [] a)
+		{
+			if (a.length == 0)
+				return "";
+			if (a.length == 1)
+				return a[0].toString();
+
+			String s = "{";
+			for (int i = 0; i < a.length; i++) {
+				s += a[i].toString();
+				if (i + 1 < a.length)
+					s += ", ";
+			}
+
+			return s + "}";
+		}
+
+		public
+		Traversal(final NameReference[] _sources, final NameReference[] _ignores)
+		{
+			this.sources = make_sorted_array(_sources);
+			this.ignores = make_sorted_array(_ignores);
+		}
+
+		public int
+		hashCode()
+		{
+			int v = 0;
+			for (int i = 0; i < this.sources.length; i++)
+				v += (this.sources[i].binding.hashCode() * 7);
+			for (int i = 0; i < this.ignores.length; i++)
+				v += (this.ignores[i].binding.hashCode() * 2);
+			return v;
+		}
+
+		public boolean
+		equals(Object o)
+		{
+			if (!(o instanceof Traversal))
+				return false;
+
+			final Traversal other = (Traversal) o;
+
+			if (!compare_arrays(this.sources, other.sources))
+				return false;
+			if (!compare_arrays(this.ignores, other.ignores))
+				return false;
+
+			return true;
+		}
+
+		public String
+		toString()
+		{
+			String sep = "";
+
+			if (sources.length == 0 || ignores.length != 0)
+				sep = "/";
+
+			return array_to_string(sources) + sep + array_to_string(ignores);
+		}
+
+		public void
+		resolveTypes(final BlockScope scope, final TypeBinding tb)
+		{
+			for (int i = 0; i < this.sources.length; i++)
+				this.sources[i].resolveTypeExpecting(scope, tb);
+			for (int i = 0; i < this.ignores.length; i++)
+				this.ignores[i].resolveTypeExpecting(scope, tb);
+		}
+
+		public void
+		assertNotVariable(final VariableBinding vb, final ProblemReporter problem_reporter, final ASTNode node)
+		{
+			for (int i = 0; i < this.sources.length; i++)
+				if (this.sources[i].binding == vb)
+					problem_reporter.abortDueToInternalError("Quantified variable `"+this.sources[i]+"' in reachability test source set", node);
+			for (int i = 0; i < this.ignores.length; i++)
+				if (this.ignores[i].binding == vb)
+					problem_reporter.abortDueToInternalError("Quantified variable `"+this.ignores[i]+"' in reachability test ignore set", node);
+		}
+	}
+}
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java	2009-03-07 00:58:59.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/SingleNameReference.java	2010-03-19 03:47:16.000000000 +0000
@@ -39,7 +39,7 @@
 import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
 import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;
 
-public class SingleNameReference extends NameReference implements OperatorIds {
+public class SingleNameReference extends NameReference implements OperatorIds, Comparable {
 
 	public static final int READ = 0;
 	public static final int WRITE = 1;
@@ -47,6 +47,7 @@
 	public MethodBinding[] syntheticAccessors; // [0]=read accessor [1]=write accessor
 	public TypeBinding genericCast;
 
+
 public SingleNameReference(char[] source, long pos) {
 	super();
 	this.token = source;
@@ -158,7 +159,8 @@
 			break;
 		case Binding.LOCAL : // reading a local variable
 			LocalVariableBinding localBinding;
-			if (!flowInfo.isDefinitelyAssigned(localBinding = (LocalVariableBinding) this.binding)) {
+			if (!flowInfo.isDefinitelyAssigned(localBinding = (LocalVariableBinding) this.binding)
+			    && !localBinding.isQuantifierBinding()) {
 				currentScope.problemReporter().uninitializedLocalVariable(localBinding, this);
 			}
 			if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0)	{
@@ -250,6 +252,15 @@
 	super.computeConversion(scope, runtimeTimeType, compileTimeType);
 }
 
+public int
+compareTo(Object o)
+{
+	if (o instanceof SingleNameReference)
+		return (new String(this.token)).compareTo(new String(((SingleNameReference)o).token));
+	else
+		return -1;
+}
+
 public void generateAssignment(BlockScope currentScope, CodeStream codeStream, Assignment assignment, boolean valueRequired) {
 	// optimizing assignment like: i = i + 1 or i = 1 + i
 	if (assignment.expression.isCompactableOperation()) {
@@ -821,6 +832,7 @@
 public TypeBinding reportError(BlockScope scope) {
 	//=====error cases=======
 	this.constant = Constant.NotAConstant;
+
 	if (this.binding instanceof ProblemFieldBinding) {
 		scope.problemReporter().invalidField(this, (FieldBinding) this.binding);
 	} else if (this.binding instanceof ProblemReferenceBinding || this.binding instanceof MissingTypeBinding) {
@@ -890,6 +902,7 @@
 		}
 	}
 	// error scenarii
+
 	return this.resolvedType = reportError(scope);
 }
 
@@ -906,4 +919,6 @@
 public String unboundReferenceErrorName(){
 	return new String(this.token);
 }
+
+	public String toString() { return new String(this.token); }
 }
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java	2009-09-28 17:28:40.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java	2010-02-28 19:37:49.000000000 +0000
@@ -534,6 +534,18 @@
 				memberType.generateCode(this.scope, classFile);
 			}
 		}
+
+		// Incorporate predicate functions into method table
+		final ProblemReporter problem_reporter = this.scope.problemReporter();
+		this.traverse (new ASTVisitor() {
+				int helper_offset = 0;
+				public boolean visit(final Assertion a, final BlockScope _) {
+					helper_offset += a.generateStaticHelperMethods(problem_reporter, helper_offset,
+										       TypeDeclaration.this);
+					return false;
+				}
+			}, (BlockScope) null);
+
 		// generate all methods
 		classFile.setForMethodInfos();
 		if (this.methods != null) {
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/TypeReference.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/TypeReference.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/TypeReference.java	2008-06-27 16:03:55.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/TypeReference.java	2010-02-25 14:10:03.000000000 +0000
@@ -107,6 +107,20 @@
  */
 public abstract char [][] getTypeName() ;
 
+	public String toString()
+	{
+		String retval = null;
+		final char[][] name = getTypeName();
+		for (int i = 0; i < name.length; i++) {
+			final String s = new String(name[i]);
+			if (retval == null)
+				retval = s;
+			else
+				retval = retval + "." + s;
+		}
+		return retval;
+	}
+
 protected TypeBinding internalResolveType(Scope scope) {
 	// handle the error here
 	this.constant = Constant.NotAConstant;
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/UnaryExpression.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/UnaryExpression.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/ast/UnaryExpression.java	2009-03-07 00:58:59.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/ast/UnaryExpression.java	2010-02-25 15:08:47.000000000 +0000
@@ -27,6 +27,11 @@
 		this.bits |= operator << OperatorSHIFT; // encode operator
 	}
 
+	public String toString()
+	{
+		return operatorToString() + expression.toString();
+	}
+
 public FlowInfo analyseCode(
 		BlockScope currentScope,
 		FlowContext flowContext,
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/batch/Main.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/batch/Main.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/batch/Main.java	2009-05-14 22:15:07.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/batch/Main.java	2010-02-22 19:39:53.000000000 +0000
@@ -1893,6 +1893,10 @@
 					mode = INSIDE_DEFAULT_ENCODING;
 					continue;
 				}
+				if (currentArg.startsWith("-gcaDebug:")) {
+					org.eclipse.jdt.internal.compiler.gca.Debug.setDebug(currentArg.substring(10));
+					continue;
+				}
 				if (currentArg.equals("-1.3")) { //$NON-NLS-1$
 					if (didSpecifyCompliance) {
 						throw new IllegalArgumentException(
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java	2009-05-14 22:15:07.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java	2010-03-03 18:05:57.000000000 +0000
@@ -359,6 +359,16 @@
 	writeUnsignedShort(this.constantPool.literalIndexForType(typeBinding));
 }
 
+public void anewarray(char[] typeBinding) {
+	this.countLabels = 0;
+	if (this.classFileOffset + 2 >= this.bCodeStream.length) {
+		resizeByteArray();
+	}
+	this.position++;
+	this.bCodeStream[this.classFileOffset++] = Opcodes.OPC_anewarray;
+	writeUnsignedShort(this.constantPool.literalIndexForType(typeBinding));
+}
+
 public void areturn() {
 	this.countLabels = 0;
 	this.stackDepth--;
@@ -2501,6 +2511,49 @@
 	return_();
 }
 
+private void
+do_invoke(byte opcode, final String classname, final String methodname, final String[] args, final String retval)
+{
+	String signature = "(";
+	int param_size = 0;
+	for (int i = 0; i < args.length; i++) {
+		String s = args[i];
+		if (s.length() > 3 // magic number: broken hack!
+		    && !s.endsWith(";"))
+			s = s + ";";
+		signature += s;
+		param_size += (s.equals("D") || s.equals("J"))? 2 : 1;
+	}
+	// magic number: broken hack!
+	signature += ")" + retval + ((retval.length() > 3 && !retval.endsWith(";"))? ";" : "");
+
+	invoke(opcode,
+	       param_size + ((opcode == Opcodes.OPC_invokevirtual || opcode == Opcodes.OPC_invokeinterface) ? 1 : 0),
+	       retval.equals("V")? 0 : 1,
+	       classname.toCharArray(),
+	       methodname.toCharArray(),
+	       signature.toCharArray());
+}
+
+public void
+doInvokeConstructor(final String classname, final String[] args)
+{
+	do_invoke(Opcodes.OPC_invokespecial, classname, "<init>", args, "V");
+}
+
+public void
+doInvokeStatic(final String classname, final String methodname, final String[] args, final String retty)
+{
+	do_invoke(Opcodes.OPC_invokestatic, classname, methodname, args, retty);
+}
+
+public void
+doInvokeVirtual(final String classname, final String methodname, final String[] args, final String retty)
+{
+	do_invoke(Opcodes.OPC_invokevirtual, classname, methodname, args, retty);
+}
+
+
 public void generateSyntheticBodyForMethodAccess(SyntheticMethodBinding accessMethod) {
 	initializeMaxLocals(accessMethod);
 	MethodBinding targetMethod = accessMethod.targetMethod;
@@ -3804,7 +3857,7 @@
 	writeUnsignedShort(this.constantPool.literalIndexForType(typeBinding));
 }
 
-protected void invoke(byte opcode, int receiverAndArgsSize, int returnTypeSize, char[] declaringClass, char[] selector, char[] signature) {
+public void invoke(byte opcode, int receiverAndArgsSize, int returnTypeSize, char[] declaringClass, char[] selector, char[] signature) {
 	this.countLabels = 0;
 	if (opcode == Opcodes.OPC_invokeinterface) {
 		// invokeinterface
@@ -5520,6 +5573,19 @@
 	this.countLabels = 0;
 	this.stackDepth++;
 	if (this.stackDepth > this.stackMax)
+		this.stackMax = this.stackDepth;
+	if (this.classFileOffset + 2 >= this.bCodeStream.length) {
+		resizeByteArray();
+	}
+	this.position++;
+	this.bCodeStream[this.classFileOffset++] = Opcodes.OPC_new;
+	writeUnsignedShort(this.constantPool.literalIndexForType(typeBinding));
+}
+
+public void new_(char []typeBinding) {
+	this.countLabels = 0;
+	this.stackDepth++;
+	if (this.stackDepth > this.stackMax)
 		this.stackMax = this.stackDepth;
 	if (this.classFileOffset + 2 >= this.bCodeStream.length) {
 		resizeByteArray();
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/BindingWrapper.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/BindingWrapper.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/BindingWrapper.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/BindingWrapper.java	2010-03-03 19:23:34.000000000 +0000
@@ -0,0 +1,112 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.ast.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+
+import java.util.*;
+
+
+public class BindingWrapper
+{
+	public NameReference name_reference;
+	public Binding source;
+	public FieldBinding[] path; // null for static fields
+
+	public void
+	emitLoad(final CodeStream cs, final BlockScope scope, final PredicateLinkage plinkage)
+	{
+		name_reference.generateCode(scope, cs, true);
+		//		cs.load(source);
+		if (this.path != null) {
+			for (int i = 0; i < this.path.length; i++) {
+				final FieldBinding field = this.path[i];
+				cs.fieldAccess(Opcodes.OPC_getfield, field, null);
+			}
+		}
+		if (this.name_reference.resolvedType.isBaseType()) {
+			// Need boxing!
+			cs.generateBoxingConversion(this.name_reference.resolvedType.id);
+		}
+	}
+
+// 	public
+// 	BindingWrapper(final Binding single)
+// 	{
+// 		this.source = single;
+// 		this.path = new FieldBinding[0];
+// 	}
+
+	public
+	BindingWrapper(final SingleNameReference snr)
+	{
+		this.name_reference = snr;
+		this.source = snr.binding;
+		this.path = new FieldBinding[0];
+	}
+
+	public
+	BindingWrapper(final QualifiedNameReference nr)
+	{
+		this.name_reference = nr;
+		this.source = nr.binding;
+		this.path = nr.otherBindings;
+	}
+
+	public boolean
+	equals(Object o)
+	{
+		if (o instanceof BindingWrapper) {
+			final BindingWrapper other = (BindingWrapper) o;
+			if (other.path.length != this.path.length) {
+				System.err.println("  => different path length");
+				return false;
+			}
+
+			if (!(new String(other.source.computeUniqueKey())).equals(new String(this.source.computeUniqueKey()))) {
+				System.err.println("  => Different source");
+				return false;
+			}
+
+			for (int i = 0; i < this.path.length; i++)
+				if (!((new String(this.path[i].computeUniqueKey()))).equals(new String (other.path[i].computeUniqueKey()))) {
+					System.err.println("  => Path index key mismatch");
+					return false;
+				}
+			return true;
+		} else
+			return false;
+	}
+
+	public int
+	hashCode()
+	{
+		int v = 0;
+		if (this.source != null)
+			v = (new String(source.computeUniqueKey())).hashCode();
+
+		if (this.path == null)
+			return v;
+
+		for (int i = 0; i < path.length; i++)
+			v += (new String(path[i].computeUniqueKey())).hashCode();
+		return v;
+	}
+
+	public String
+	toString()
+	{
+		String retval;
+		if (this.source == null)
+			retval = "*";
+		else
+			retval = new String(this.source.toString().replace(" ", "-"));
+		if (this.path == null)
+			return "STATIC:" + retval;
+		for (int i = 0; i < path.length; i++) {
+			retval += ".";
+			retval += (path[i] == null)? "*" : path[i].toString().replace(" ", "-");
+		}
+		return retval;
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/Debug.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/Debug.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/Debug.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/Debug.java	2010-03-03 20:57:09.000000000 +0000
@@ -0,0 +1,55 @@
+package org.eclipse.jdt.internal.compiler.gca;
+
+import java.util.*;
+
+public class Debug
+{
+	private static boolean enable_all = false;
+	private static final HashSet enabled = new HashSet();
+
+	private static final HashSet valid;
+
+	static {
+		String[] valid_s = new String[] { "ast", "hook", "all", "extraction", "T", "traversal" };
+		valid = new HashSet();
+		for (int i = 0; i < valid_s.length; i++)
+			valid.add(valid_s[i]);
+	}
+
+	public static void
+	setDebug(String d)
+	{
+		if (d.equals("all"))
+			enable_all = true;
+		else
+			enabled.add(d);
+	}
+
+
+	public static void
+	print(String subsys, String s)
+	{
+		if (enable_all || enabled.contains(subsys))
+			System.out.print(s);
+	}
+	
+	public static void
+	println(String subsys, String s)
+	{
+		print(subsys, s + "\n");
+	}
+
+
+	public static void
+	print(String msg)
+	{
+		print("all", msg);
+	}
+
+	public static void
+	println(String msg)
+	{
+		println("all", msg);
+	}
+	
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCABinary.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCABinary.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCABinary.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCABinary.java	2010-03-18 22:14:39.000000000 +0000
@@ -0,0 +1,191 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.ast.OperatorIds;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+
+import java.util.*;
+
+public class GCABinary extends GCANode implements OperatorIds
+{
+	int op_id;
+
+	public
+	GCABinary(final int _op_id, final String name, final GCANode lhs, final GCANode rhs)
+	{
+		super(name, 2);
+		this.op_id = _op_id;
+		this.children[0] = lhs;
+		this.children[1] = rhs;
+
+		if (this.children[0].result_ty == null) {
+			System.err.println("BINOP " + name + ": child 0 has no ty: " + lhs);
+			try { throw new RuntimeException("Foo"); } catch (RuntimeException e) { e.printStackTrace(); };
+		}
+		if (this.children[1].result_ty == null)
+			System.err.println("BINOP " + name + ": child 1 has no ty: " + rhs);
+	}
+
+	public GCANode
+	fold()
+	{
+		super.fold();
+
+		switch (this.op_id) {
+		case AND_AND:
+			for (int i = 0; i <= 1; i++)
+				if (this.children[i] == GCATrue.TRUE)
+					return this.children[1 - i];
+			for (int i = 0; i <= 1; i++)
+				if (this.children[i] == GCAFalse.FALSE)
+					return GCAFalse.FALSE;
+			return this;
+
+		case OR_OR:
+			for (int i = 0; i <= 1; i++)
+				if (this.children[i] == GCAFalse.FALSE)
+					return this.children[1 - i];
+			for (int i = 0; i <= 1; i++)
+				if (this.children[i] == GCATrue.TRUE)
+					return GCATrue.TRUE;
+
+		default:
+			return this;
+		}
+	}
+
+	public GCANode
+	copy()
+	{
+		return new GCABinary(this.op_id, this.op, this.children[0].copy(), this.children[1].copy()).setTypes(this.result_ty, this.implicit_conversion);
+	}
+
+	private boolean
+	fp_compare(final CodeStream cs)
+	{
+		if (this.children[0].result_ty == TypeBinding.DOUBLE || this.children[1].result_ty == TypeBinding.DOUBLE) {
+			cs.dcmpl();
+			return true;
+		} else if (this.children[0].result_ty == TypeBinding.FLOAT || this.children[1].result_ty == TypeBinding.FLOAT) {
+			cs.fcmpl();
+			return true;
+		} else
+			return false;
+	}
+
+	protected void
+	doAccept(GCANodeVisitor visitor)
+	{
+		visitor.visitBinary(this);
+	}
+
+	public void
+	emit(final GCAClosure closure, final CodeStream cs)
+	{
+		closure.pushLabels();
+		switch (this.op_id) {
+		case AND_AND: {
+			closure.pushLabels();
+			closure.true_label = new BranchLabel(cs);
+
+			children[0].emit(closure, cs);
+
+			closure.true_label.place();
+			closure.popLabels();
+
+			children[1].emit(closure, cs);
+			break;
+		}
+		case OR_OR: {
+			closure.pushLabels();
+			closure.false_label = new BranchLabel(cs);
+
+			children[0].emit(closure, cs);
+
+			closure.false_label.place();
+			closure.popLabels();
+
+			children[1].emit(closure, cs);
+			break;
+		}
+		case NOT_EQUAL:
+			closure.swapLabels();
+		case EQUAL_EQUAL: {
+			if (children[0].result_ty == TypeBinding.BOOLEAN || children[1].result_ty == TypeBinding.BOOLEAN) {
+				closure.pushLabels();
+				closure.true_label = new BranchLabel(cs);
+				closure.false_label = new BranchLabel(cs);
+				BranchLabel result_label = new BranchLabel(cs);
+
+				children[0].emit(closure, cs);
+				closure.false_label.place();
+				cs.iconst_0();
+				cs.goto_(result_label);
+				closure.true_label.place();
+				cs.iconst_1();
+				result_label.place();
+
+				closure.true_label = new BranchLabel(cs);
+				closure.false_label = new BranchLabel(cs);
+				result_label = new BranchLabel(cs);
+				children[1].emit(closure, cs);
+				closure.false_label.place();
+				cs.iconst_0();
+				cs.goto_(result_label);
+				closure.true_label.place();
+				cs.iconst_1();
+				result_label.place();
+
+				closure.popLabels();
+				cs.if_icmpeq(closure.true_label);
+			} else if (children[0].result_ty.isNumericType()) {
+				children[0].emit(closure, cs);
+				children[1].emit(closure, cs);
+				if (fp_compare(cs))
+					cs.ifeq(closure.true_label);
+				else
+					cs.if_icmpeq(closure.true_label);
+			} else {
+				children[0].emit(closure, cs);
+				if (children[1] == GCANull.NULL)
+					cs.ifnull(closure.true_label);
+				else {
+					children[1].emit(closure, cs);
+					cs.if_acmpeq(closure.true_label);
+				}
+			}
+			cs.goto_(closure.false_label);
+			break;
+		}
+		case GREATER:
+			closure.swapLabels();
+		case LESS_EQUAL: {
+			children[0].emit(closure, cs);
+			children[1].emit(closure, cs);
+			if (fp_compare(cs))
+				cs.ifle(closure.true_label);
+			else
+				cs.if_icmple(closure.true_label);
+			cs.goto_(closure.false_label);
+			break;
+		}
+		case LESS:
+			closure.swapLabels();
+		case GREATER_EQUAL: {
+			children[0].emit(closure, cs);
+			children[1].emit(closure, cs);
+			if (fp_compare(cs))
+				cs.ifge(closure.true_label);
+			else
+				cs.if_icmpge(closure.true_label);
+			cs.goto_(closure.false_label);
+			break;
+		}
+
+		default:
+			throw new RuntimeException("Unknown binary operator `" + this.op + "'");
+		}
+		closure.popLabels();
+	}
+
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCAClosure.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCAClosure.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCAClosure.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCAClosure.java	2010-03-02 15:39:24.000000000 +0000
@@ -0,0 +1,170 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.ast.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+
+import java.util.*;
+
+public class GCAClosure
+{
+	public final BindingWrapper[] env;
+	public final GCANode body;
+	public final TypeBinding query_var_ty;
+
+	// during code emitting:
+	public int self_index;
+	BranchLabel true_label, false_label;
+	public LinkedList true_label_stack = new LinkedList();
+	public LinkedList false_label_stack = new LinkedList();
+	public BlockScope scope;
+
+	public
+	GCAClosure(final TypeBinding _query_var_ty,
+		   final GCANode _body,
+		   final BindingWrapper[] _env)
+	{
+		this.query_var_ty = _query_var_ty;
+		this.env = _env;
+		this.body = _body;
+	}
+
+	public int
+	hashCode()
+	{
+		int hc = body.hashCode();
+		for (int i = 0; i < env.length; i++) {
+			hc <<= 2;
+			hc ^= env[i].hashCode();
+		}
+		return hc;
+	}
+
+	public boolean
+	equals(Object o)
+	{
+		if (o instanceof GCAClosure) {
+			final GCAClosure other = (GCAClosure) o;
+
+			if (other.env.length != this.env.length)
+				return false;
+			if (!other.body.equals(this.body))
+				return false;
+
+			for (int i = 0; i < this.env.length; i++)
+				if (!other.env[i].equals(this.env[i])) {
+					return false;
+				}
+
+			return true;
+		} else
+			return false;
+	}
+
+	public String
+	toString()
+	{
+		if (env.length == 0)
+			return body.toString();
+		String s = "{";
+		for (int i = 0; i < env.length; i++) {
+			if (i > 0)
+				s += ", ";
+			s += "$" + i + " = " + env[i].toString();
+		}
+		return s + "} " + body;
+	}
+
+	public void
+	emit(BlockScope scope, CodeStream code_stream)
+	{
+		this.self_index = 0;
+		this.scope = scope;
+		if (this.query_var_ty == scope.getJavaLangObject())
+			this.self_index = 0;
+		else {
+//			System.err.println("Emitting for non-Object: " + query_var_ty.debugName());
+			// emit prelude that returns `false' if the checked cast would fail
+			final BranchLabel success_label = new BranchLabel(code_stream);
+			code_stream.aload_0();
+			code_stream.instance_of(this.query_var_ty);
+			code_stream.ifne(success_label);
+			code_stream.generateInlinedValue(0);
+			code_stream.ireturn();
+			success_label.place();
+			code_stream.aload_0();
+			code_stream.checkcast(this.query_var_ty);
+			code_stream.astore_2();
+			this.self_index = 2;
+		}
+
+		if (this.body == GCATrue.TRUE) {
+			code_stream.generateInlinedValue(1);
+			code_stream.ireturn();
+		} else {
+			final BranchLabel t_label = this.true_label = new BranchLabel(code_stream);
+			final BranchLabel f_label = this.false_label = new BranchLabel(code_stream);
+
+			this.body.emit(this, code_stream);
+
+			f_label.place();
+			code_stream.generateInlinedValue(0);
+			code_stream.ireturn();
+			t_label.place();
+			code_stream.generateInlinedValue(1);
+			code_stream.ireturn();
+		}
+	}
+
+	public void
+	swapLabels()
+	{
+		final BranchLabel swap = this.true_label;
+		this.true_label = this.false_label;
+		this.false_label = swap;
+	}
+
+	public void
+	pushLabels()
+	{
+		this.true_label_stack.addFirst(this.true_label);
+		this.false_label_stack.addFirst(this.false_label);
+	}
+
+	public void
+	popLabels()
+	{
+		this.true_label = (BranchLabel) this.true_label_stack.removeFirst();
+		this.false_label = (BranchLabel) this.false_label_stack.removeFirst();
+	}
+
+	/**
+	 * Interpret TOS as boolean and jump as needed
+	 */
+	public void
+	booleanJump(final CodeStream cs)
+	{
+		cs.ifne(this.true_label);
+		cs.goto_(this.false_label);
+	}
+
+	public void
+	loadIterationVar(CodeStream cs)
+	{
+		if (this.self_index == 0) // unconverted
+			cs.aload_0();
+		else if (this.self_index == 2) // converted
+			cs.aload_2();
+		else
+			cs.aload(self_index);
+	}
+
+	/**
+	 * Always returns false?
+	 */
+	public boolean
+	isTrivial()
+	{
+		return this.body == GCAFalse.FALSE;
+	}
+}
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCAConstant.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCAConstant.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCAConstant.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCAConstant.java	2010-03-18 22:18:37.000000000 +0000
@@ -0,0 +1,31 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.impl.Constant;
+
+import java.util.*;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+
+public class GCAConstant extends GCALiteral
+{
+	Constant value;
+	int implicit_conversion;
+
+	public GCAConstant(final Constant i, int implicit_conversion)
+	{
+		super(i.toString());
+		this.value = i;
+	}
+
+	protected void
+	doAccept(GCANodeVisitor visitor)
+	{
+		visitor.visitConstant(this);
+	}
+
+	public void
+	emit(final GCAClosure closure, final CodeStream cs)
+	{
+		cs.generateConstant(this.value, this.implicit_conversion);
+	}
+
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCADereference.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCADereference.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCADereference.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCADereference.java	2010-03-18 23:35:08.000000000 +0000
@@ -0,0 +1,98 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.ast.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+
+import java.util.*;
+
+public class GCADereference extends GCANode
+{
+	FieldBinding[] path;
+
+	public
+	GCADereference(GCANode body, FieldBinding[] path)
+	{
+		super(stringify(path), 1);
+		if (path == null)
+			throw new RuntimeException("Path is null!");
+		this.path = path;
+		this.children[0] = body;
+		for (int i = 0; i < path.length; i++)
+			if (path[i] == null)
+				throw new RuntimeException("Path." + i + " is null! (" + toString() + ")");
+	}
+
+	public int
+	pathLength()
+	{
+		return this.path.length;
+	}
+
+	public GCADereference
+	copyWithoutLastPathElement()
+	{
+		final FieldBinding[] new_path = new FieldBinding[this.path.length - 1];
+		System.arraycopy(this.path, 0, new_path, 0, new_path.length);
+		return (GCADereference) new GCADereference(this.children[0].copy(), new_path).setTypes(GCANodeFactory.java_lang_Object, 0);
+	}
+
+	public GCANode
+	copy()
+	{
+		return new GCADereference(this.children[0].copy(), path).setTypes(this.result_ty, this.implicit_conversion);
+	}
+
+	public boolean
+	equals(Object o)
+	{
+		if (!super.equals(o))
+			return false;
+
+		if (!(o instanceof GCADereference)) {
+			return false;
+		}
+		final GCADereference other = (GCADereference) o;
+
+		if (other.path.length != this.path.length) {
+			return false;
+		}
+		return (stringify(this.path).equals(stringify(other.path)));
+	}
+
+	private static String
+	stringify(FieldBinding[] path)
+	{
+		String retval = "#";
+		for (int i = 0; i < path.length; i++) {
+			if (i > 0)
+				retval += ".";
+			if (path[i] == null)
+				retval += "?";
+			else if (path[i].declaringClass == null) {
+				retval += "!";
+				retval += path[i].toString().replace(" ", "-");
+			} else {
+				retval += new String(path[i].declaringClass.signature());
+				retval += path[i].toString().replace(" ", "-");
+			}
+		}
+		return retval;
+	}
+
+	protected void
+	doAccept(GCANodeVisitor visitor)
+	{
+		visitor.visitDereference(this);
+	}
+
+	public void
+	emit(final GCAClosure closure, final CodeStream cs)
+	{
+		this.children[0].emit(closure, cs);
+		for (int i = 0; i < path.length; i++) {
+			final FieldBinding field = path[i];
+			cs.fieldAccess(Opcodes.OPC_getfield, field, null);
+		}
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCAEnvVar.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCAEnvVar.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCAEnvVar.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCAEnvVar.java	2010-03-18 22:15:52.000000000 +0000
@@ -0,0 +1,44 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.ast.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+
+import java.util.*;
+
+public class GCAEnvVar extends GCALiteral
+{
+	int index;
+
+	public
+	GCAEnvVar(final int _index)
+	{
+		super("$" + _index);
+		this.index = _index;
+	}
+
+	protected void
+	doAccept(GCANodeVisitor visitor)
+	{
+		visitor.visitEnvVar(this);
+	}
+
+	public void
+	emit(final GCAClosure closure, final CodeStream cs)
+	{
+		cs.aload_1();
+		cs.generateInlinedValue(this.index);
+		cs.aaload();
+
+		// convert Object to whatever we need
+		if (this.result_ty.isBaseType()) {
+			final TypeBinding interty = closure.scope.environment().computeBoxingType(this.result_ty);
+			cs.checkcast(interty);
+		}
+
+		this.emitUnboxing(cs);
+		this.emitImplicitConversion(cs);
+		if (this.result_ty == TypeBinding.BOOLEAN)
+			closure.booleanJump(cs);
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCAFalse.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCAFalse.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCAFalse.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCAFalse.java	2010-03-18 22:14:23.000000000 +0000
@@ -0,0 +1,28 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+
+import java.util.*;
+
+public class GCAFalse extends GCALiteral
+{
+	private GCAFalse()
+	{
+		super("false");
+	}
+
+	public static final GCAFalse FALSE = new GCAFalse();
+
+	protected void
+	doAccept(GCANodeVisitor visitor)
+	{
+		visitor.visitFalse(this);
+	}
+
+	public void
+	emit(final GCAClosure closure, final CodeStream cs)
+	{
+		cs.goto_(closure.false_label);
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCAInstanceOf.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCAInstanceOf.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCAInstanceOf.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCAInstanceOf.java	2010-03-18 22:14:34.000000000 +0000
@@ -0,0 +1,63 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.ast.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+
+import java.util.*;
+
+public class GCAInstanceOf extends GCANode
+{
+	TypeBinding ty;
+	String ty_name;
+
+	public
+	GCAInstanceOf(final GCANode body, final TypeBinding ty)
+	{
+		super("instanceof", 1);
+		this.children[0] = body;
+		this.ty = ty;
+		this.ty_name = ty.debugName();
+	}
+
+	public GCANode
+	copy()
+	{
+		return new GCAInstanceOf(this.children[0], this.ty).setTypes(this.result_ty, this.implicit_conversion);
+	}
+
+	public boolean
+	equals(Object o)
+	{
+		if (!super.equals(o))
+			return false;
+		if (!(o instanceof GCAInstanceOf))
+			return false;
+		final GCAInstanceOf other = (GCAInstanceOf) o;
+
+		if (!other.ty_name.equals(this.ty_name))
+			return false;
+
+		return true;
+	}
+
+	public String
+	toString()
+	{
+		return "instanceof(" + this.children[0] + ", " + this.ty_name + ")";
+	}
+
+	protected void
+	doAccept(GCANodeVisitor visitor)
+	{
+		visitor.visitInstanceOf(this);
+	}
+
+	public void
+	emit(final GCAClosure closure, final CodeStream cs)
+	{
+		this.children[0].emit(closure, cs);
+		cs.instance_of(ty);
+		closure.booleanJump(cs);
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCAIterationVar.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCAIterationVar.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCAIterationVar.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCAIterationVar.java	2010-03-18 22:15:06.000000000 +0000
@@ -0,0 +1,30 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.ast.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+
+import java.util.*;
+
+public class GCAIterationVar extends GCALiteral
+{
+	private
+	GCAIterationVar()
+	{
+		super("x");
+	}
+
+	public static final GCAIterationVar VAR = new GCAIterationVar();
+
+	protected void
+	doAccept(GCANodeVisitor visitor)
+	{
+		visitor.visitIterationVar(this);
+	}
+
+	public void
+	emit(final GCAClosure closure, final CodeStream cs)
+	{
+		closure.loadIterationVar(cs);
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCALiteral.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCALiteral.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCALiteral.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCALiteral.java	2010-02-26 23:31:31.000000000 +0000
@@ -0,0 +1,25 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+
+import java.util.*;
+
+public abstract class GCALiteral extends GCANode
+{
+	protected GCALiteral(final String _s)
+	{
+		super(_s, 0);
+	}
+
+	public GCANode
+	fold()
+	{
+		return this; // nothing to fold
+	}
+
+	public GCANode
+	copy()
+	{
+		return this; // no need to duplicate
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCANode.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCANode.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCANode.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCANode.java	2010-03-18 22:08:28.000000000 +0000
@@ -0,0 +1,134 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+
+import java.util.*;
+
+/**
+ * GCANodes represent boolean expressions found within QuantifiedExpressions in the regular
+ * syntax tree.  Unlike regular AST nodes, GCANodes facilitate substitution, simplification,
+ * comparison, and hashing.
+ */
+public abstract class GCANode
+{
+	public GCANode[] children;
+	public String op;
+	public TypeBinding result_ty;
+	public int implicit_conversion;
+
+	protected
+	GCANode(final String _op, final int children_nr)
+	{
+		this.children = new GCANode[children_nr];
+		this.op = _op;
+	}
+
+	public int
+	hashCode()
+	{
+		int hc = op.hashCode();
+		for (int i = 0; i < this.children.length; i++)
+			hc += (this.children[i].hashCode() << 2);
+		return hc;
+	}
+
+	public boolean
+	equals(Object o)
+	{
+		if (o instanceof GCANode) {
+			final GCANode other = (GCANode) o;
+
+			if (!other.op.equals(this.op)) {
+				return false;
+			}
+			if (this.children.length != other.children.length){
+				return false;
+			}
+			for (int i = 0; i < this.children.length; i++)
+				if (!this.children[i].equals(other.children[i])) {
+					return false;
+				}
+			return true;
+		} else
+			return false;
+	}
+
+	public GCANode
+	subst(GCANodeTest t, GCANode substnode)
+	{
+		if (t.test(this))
+			return substnode;
+		else {
+			for (int i = 0; i < this.children.length; i++)
+				this.children[i] = this.children[i].subst(t, substnode);
+			return this;
+		}
+	}
+
+	// Constant folding
+	public GCANode
+	fold()
+	{
+		for (int i = 0; i < this.children.length; i++)
+			this.children[i] = this.children[i].fold();
+		return this;
+	}
+
+	public abstract void
+	emit(final GCAClosure closure, final CodeStream cs);
+
+	/**
+	 * Under the hypothesis that we have a boxed value of the expected type, unbox
+	 */
+	public void
+	emitUnboxing(final CodeStream cs)
+	{
+		cs.generateUnboxingConversion(result_ty.id);
+	}
+
+	public void
+	emitImplicitConversion(final CodeStream cs)
+	{
+		cs.generateImplicitConversion(this.implicit_conversion);
+	}
+
+	public abstract GCANode
+	copy();
+
+
+	public GCANode
+	setTypes(final TypeBinding _result_ty, final int _implicit_conversion)
+	{
+		this.result_ty = _result_ty;
+		this.implicit_conversion = _implicit_conversion;
+		return this;
+	}
+
+	public void
+	accept(GCANodeVisitor visitor)
+	{
+		this.doAccept(visitor);
+		for (int i = 0; i < this.children.length; i++)
+			this.children[i].accept(visitor);
+	}
+
+	protected abstract void
+	doAccept(GCANodeVisitor visitor);
+
+	public String
+	toString()
+	{
+		if (this.children.length == 0)
+			return op;
+		else {
+			String s =  op + "(";
+			for (int i = 0; i < this.children.length; i++) {
+				s += this.children[i];
+				if (i + 1 < this.children.length)
+					s += ", ";
+			}
+			return s + ")";
+		}
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCANodeFactory.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCANodeFactory.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCANodeFactory.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCANodeFactory.java	2010-03-18 23:40:42.000000000 +0000
@@ -0,0 +1,167 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.ast.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+
+import java.util.*;
+
+public class GCANodeFactory
+{
+	private HashMap /* <BindingWrapper, GCAEnvVar> */ env = new HashMap();
+	private ArrayList /* BindingWrapper */ env_list = new ArrayList();
+	private HashSet /* ReachSpec */ reach_specs = new HashSet();
+	private Binding iteration_var;
+	private BlockScope scope;
+
+	public static TypeBinding java_lang_Object = null; // initialised ASAP
+
+
+	public static final GCANodeFactory SINGLETON = new GCANodeFactory();
+
+	private
+	GCANodeFactory()
+	{}
+
+	public PredicateFamily
+	build(final QuantifiedExpression qe, BlockScope _scope)
+	{
+		this.env.clear();
+		this.env_list.clear();
+		this.iteration_var = qe.variable.binding;
+		this.reach_specs.clear();
+		this.scope = _scope;
+
+		java_lang_Object = _scope.getJavaLangObject();
+
+		GCANode body = make(qe.body);
+		if (!qe.existential)
+			body = new GCAUnary(OperatorIds.NOT, "!", body); // universal bodies must be negated, since the purpose of these bodies is to indicate traversal termination
+
+		body = guardBody(body);
+
+		final BindingWrapper[] env_array = new BindingWrapper[this.env_list.size()];
+		for (int i = 0; i < this.env_list.size(); i++)
+			env_array[i] = (BindingWrapper) env_list.get(i);
+
+		final ReachSpec[] reach_specs_array = new ReachSpec[this.reach_specs.size()];
+		final Iterator rs_it = reach_specs.iterator();
+		int i = 0;
+		while (rs_it.hasNext())
+			reach_specs_array[i++] = (ReachSpec)rs_it.next();
+
+		return new PredicateFamily(qe.variable.type.resolveType(_scope, false), body, env_array, qe, reach_specs_array);
+	}
+
+	// detect uses of x.f.g and guard against x.f being null
+	private GCANode
+	guardBody(GCANode body)
+	{
+		GCATraversalDereferenceCollector.SINGLETON.clear();
+		body.accept(GCATraversalDereferenceCollector.SINGLETON);
+
+		for (int i = 0; i < GCATraversalDereferenceCollector.SINGLETON.nodes.size(); i++) {
+			GCADereference deref = (GCADereference) GCATraversalDereferenceCollector.SINGLETON.nodes.get(i);
+
+			while (deref.pathLength () > 1) {
+				final GCADereference sub_deref = deref.copyWithoutLastPathElement();
+				final GCANode guard = new GCABinary(OperatorIds.NOT_EQUAL, "!=", sub_deref, GCANull.NULL.setTypes(this.scope.getJavaLangObject(), 0));
+				guard.setTypes(TypeBinding.BOOLEAN, 0);
+				body = new GCABinary(OperatorIds.AND_AND, "&&", guard, body).setTypes(TypeBinding.BOOLEAN, 0);
+				deref = sub_deref;
+			}
+		}
+
+		return body;
+	}
+
+	private GCANode
+	substituteBinding(final BindingWrapper binding)
+	{
+		if (binding.source == this.iteration_var && binding.path.length == 0)
+			return GCAIterationVar.VAR;
+		else {
+			GCAEnvVar var = (GCAEnvVar) env.get(binding);
+			if (var == null) {
+				final int index = env_list.size();
+				var = new GCAEnvVar(index);
+				env_list.add(binding);
+				env.put(binding, var);
+			}
+			return var;
+		}
+	}
+
+	private final GCANode
+	make(final Expression e)
+	{
+		final GCANode n = makeSub(e);
+		n.result_ty = e.resolvedType;
+		n.implicit_conversion = e.implicitConversion;
+		return n;
+	}
+
+	private final GCANode
+	makeSub(final Expression e)
+	{
+		// Distributing all this code over the various classes would integrate the GCA code
+		// too much for readability, so I opted for a slow-and-non-OO functional-style
+		// translation pattern here.  I don't really like OO anyway.
+
+		if (e instanceof TrueLiteral)
+			return GCATrue.TRUE;
+		if (e instanceof FalseLiteral)
+			return GCAFalse.FALSE;
+		if (e instanceof NullLiteral)
+			return GCANull.NULL;
+		if (e instanceof Literal) {
+			final Literal lit = (Literal) e;
+			lit.computeConstant();
+			return new GCAConstant(lit.constant, lit.implicitConversion);
+		}
+		if (e instanceof BinaryExpression) {
+			final BinaryExpression be = (BinaryExpression) e;
+			return new GCABinary(be.getOperatorId(), be.operatorToString(), make(be.left), make(be.right));
+		}
+		if (e instanceof InstanceOfExpression) {
+			final InstanceOfExpression ioe = (InstanceOfExpression) e;
+			return new GCAInstanceOf(make(ioe.expression), ioe.type.resolveType(this.scope, false));
+		}
+		if (e instanceof UnaryExpression) {
+			final UnaryExpression ue = (UnaryExpression) e;
+			return new GCAUnary(ue.getOperatorId(), ue.operatorToString(), make(ue.expression));
+		}
+		if (e instanceof ReachExpression) {
+			final ReachExpression re = (ReachExpression) e;
+			this.reach_specs.add(re.reach_spec);
+			return new GCATraversalConstant(re.reach_spec);
+		}
+		if (e instanceof SingleNameReference) {
+			final SingleNameReference sr = (SingleNameReference) e;
+			return substituteBinding(new BindingWrapper(sr));
+		}
+		if (e instanceof QualifiedNameReference) {
+			final QualifiedNameReference qr = (QualifiedNameReference) e;
+			switch (qr.bits & ASTNode.RestrictiveFlagMASK) {
+			case Binding.FIELD:
+				return substituteBinding(new BindingWrapper(qr));
+
+			case Binding.LOCAL: {
+				if (qr.binding == this.iteration_var) { // forall x : ... x.v ...
+					final BindingWrapper br = new BindingWrapper(qr);
+					br.path = new FieldBinding[0];
+					GCANode n = substituteBinding(br);
+					if (qr.otherBindings == null)
+						return n;
+					else 
+						return new GCADereference(n,
+									  qr.otherBindings);
+				} else
+					return substituteBinding(new BindingWrapper(qr));
+			}
+			default:
+				throw new RuntimeException("Unexpected kind of QualifiedNameReference");
+			}
+		}
+		throw new RuntimeException("Trying to build GCA expression from unsupported expression: " + e.getClass());
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCANodeTest.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCANodeTest.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCANodeTest.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCANodeTest.java	2010-02-26 04:23:13.000000000 +0000
@@ -0,0 +1,12 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.*;
+
+import java.util.*;
+
+/**
+ * Interface for filtering GCANodes
+ */
+public abstract class GCANodeTest
+{
+	public abstract boolean test(GCANode node);
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCANodeVisitor.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCANodeVisitor.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCANodeVisitor.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCANodeVisitor.java	2010-03-18 23:14:27.000000000 +0000
@@ -0,0 +1,42 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+
+import java.util.*;
+
+public abstract class GCANodeVisitor
+{
+	public void
+	visitBinary(GCABinary _) {}
+
+	public void
+	visitUnary(GCAUnary _) {}
+
+	public void
+	visitConstant(GCAConstant _) {}
+
+	public void
+	visitInstanceOf(GCAInstanceOf _) {}
+
+	public void
+	visitNull(GCANull _) {}
+
+	public void
+	visitTrue(GCATrue _) {}
+
+	public void
+	visitFalse(GCAFalse _) {}
+
+	public void
+	visitIterationVar(GCAIterationVar _) {}
+
+	public void
+	visitEnvVar(GCAEnvVar _) {}
+
+	public void
+	visitTraversalConstant(GCATraversalConstant _) {}
+
+	public void
+	visitDereference(GCADereference _) {}
+}
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCANull.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCANull.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCANull.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCANull.java	2010-03-18 22:15:00.000000000 +0000
@@ -0,0 +1,29 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+
+import java.util.*;
+
+public class GCANull extends GCALiteral
+{
+	private GCANull()
+	{
+		super("null");
+	}
+
+	public static final GCANull NULL = new GCANull();
+
+	protected void
+	doAccept(GCANodeVisitor visitor)
+	{
+		visitor.visitNull(this);
+	}
+
+	public void
+	emit(final GCAClosure closure, final CodeStream cs)
+	{
+		cs.aconst_null();
+	}
+
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCATraversalConstant.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCATraversalConstant.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCATraversalConstant.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCATraversalConstant.java	2010-03-18 22:18:59.000000000 +0000
@@ -0,0 +1,36 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.ast.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+
+import java.util.*;
+
+/**
+ * Such a constant represents a particular traversal.  Depending on the
+ * traversal in question, we'll substitute TRUE or FALSE in it-- we never
+ * generate code directly.
+ */
+public class GCATraversalConstant extends GCALiteral
+{
+	ReachSpec reach_spec;
+
+	public
+	GCATraversalConstant(final ReachSpec rs)
+	{
+		super("reach:" + rs.toString());
+		this.reach_spec = rs;
+	}
+
+	protected void
+	doAccept(GCANodeVisitor visitor)
+	{
+		visitor.visitTraversalConstant(this);
+	}
+
+	public void
+	emit(final GCAClosure closure, final CodeStream cs)
+	{
+		throw new RuntimeException("Trying to emit code with traversal constant!");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCATraversalDereferenceCollector.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCATraversalDereferenceCollector.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCATraversalDereferenceCollector.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCATraversalDereferenceCollector.java	2010-03-18 23:30:31.000000000 +0000
@@ -0,0 +1,30 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+
+import java.util.*;
+
+/**
+ * Collects all GCADereference nodes that need guarding against null pointer exceptions
+ */
+public class GCATraversalDereferenceCollector extends GCANodeVisitor
+{
+	public static final GCATraversalDereferenceCollector SINGLETON = new GCATraversalDereferenceCollector();
+
+	public ArrayList nodes = new ArrayList(); // will contain all collected
+
+	public void
+	clear()
+	{
+		this.nodes.clear();
+	}
+
+	public void
+	visitDereference(GCADereference deref)
+	{
+		if (deref.children[0] instanceof GCAIterationVar
+		    && deref.pathLength() > 1)
+			this.nodes.add(deref);
+	}
+}
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCATrue.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCATrue.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCATrue.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCATrue.java	2010-03-18 22:14:18.000000000 +0000
@@ -0,0 +1,28 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+
+import java.util.*;
+
+public class GCATrue extends GCALiteral
+{
+	private GCATrue()
+	{
+		super("true");
+	}
+
+	public static final GCATrue TRUE = new GCATrue();
+
+	protected void
+	doAccept(GCANodeVisitor visitor)
+	{
+		visitor.visitTrue(this);
+	}
+
+	public void
+	emit(final GCAClosure closure, final CodeStream cs)
+	{
+		cs.goto_(closure.true_label);
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCAUnary.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCAUnary.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/GCAUnary.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/GCAUnary.java	2010-03-21 22:03:30.000000000 +0000
@@ -0,0 +1,83 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.ast.OperatorIds;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
+
+import java.util.*;
+
+public class GCAUnary extends GCANode implements OperatorIds
+{
+	int op_id;
+
+	public GCAUnary(final int _op_id, final String name, final GCANode child)
+	{
+		super(name, 1);
+		this.op_id = _op_id;
+		this.children[0] = child;
+
+		if (_op_id == NOT) {
+			this.implicit_conversion = 0;
+			this.result_ty = TypeBinding.BOOLEAN;
+		}
+	}
+
+	public GCANode
+	fold()
+	{
+		final GCANode child = this.children[0] = this.children[0].fold();
+
+		switch (this.op_id) {
+		case NOT:
+			if (child == GCATrue.TRUE)
+				return GCAFalse.FALSE;
+			else if (child == GCAFalse.FALSE)
+				return GCATrue.TRUE;
+			else if (child instanceof GCAUnary // double negation elimination
+				 && ((GCAUnary) child).op_id == NOT)
+				return child.children[0];
+			else if (child instanceof GCABinary) {
+				GCABinary b = (GCABinary) child;
+				if (b.op_id == OperatorIds.NOT_EQUAL) {
+					b.op_id = OperatorIds.EQUAL_EQUAL;
+					b.op = "==";
+					return child;
+				} else if (b.op_id == OperatorIds.EQUAL_EQUAL) {
+					b.op_id = OperatorIds.NOT_EQUAL;
+					b.op = "!=";
+					return child;
+				}
+			}
+		default:
+			return this;
+		}
+	}
+
+	public GCANode
+	copy()
+	{
+		return new GCAUnary(this.op_id, this.op, this.children[0].copy()).setTypes(this.result_ty, this.implicit_conversion);
+	}
+
+	protected void
+	doAccept(GCANodeVisitor visitor)
+	{
+		visitor.visitUnary(this);
+	}
+
+	public void
+	emit(final GCAClosure closure, final CodeStream cs)
+	{
+		closure.pushLabels();
+		switch (this.op_id) {
+		case NOT: {
+			closure.swapLabels();
+			this.children[0].emit(closure, cs);
+			break;
+		}
+		default:
+			throw new RuntimeException("Unknown unary operator `" + this.op + "'");
+		}
+		closure.popLabels();
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/Parser.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/Parser.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/Parser.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/Parser.java	2010-03-19 03:56:23.000000000 +0000
@@ -0,0 +1,763 @@
+package org.eclipse.jdt.internal.compiler.gca;
+
+import java.util.*;
+
+import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
+import org.eclipse.jdt.internal.compiler.ast.*;
+
+// Manually implemented recursive descent parser.  Ah well.
+public class Parser implements OperatorIds
+{
+	private Scanner scanner;
+	private ProblemReporter problem_reporter;
+
+	private void
+	dumpScanner(final String s)
+	{
+		System.out.print(s + ":  ");
+		_dump_scanner();
+		System.out.println();
+	}
+
+	private int
+	pos()
+	{
+		return scanner.offset();
+	}
+
+	private long
+	combo_pos()
+	{
+		return ((0L | (scanner.offset())) << 32) | scanner.offset();
+	}
+
+	private void
+	_dump_scanner()
+	{
+		final Token t = this.scanner.next();
+		if (t != null) {
+			System.out.print(t + "  ");
+			_dump_scanner();
+		}
+		this.scanner.pushBack(t);
+	}
+
+	Set name_set;
+
+	public
+	Parser(final Scanner _scanner, final ProblemReporter _problem_reporter, final Set _name_collector)
+	{
+		this.name_set = _name_collector;
+		this.scanner = _scanner;
+		this.problem_reporter = _problem_reporter;
+	}
+
+	public static Expression
+	parse(final int _source_start, final int _source_end, final String body, final int assertion_kind, ProblemReporter pr)
+	{
+		final HashSet name_set = new HashSet();
+		final Parser p = new Parser(new Scanner(body, _source_start), pr, name_set);
+
+		final Assertion a = p.parseAssertion(assertion_kind);
+		a.contained_names = name_set;
+
+		if (a == null)
+			return new IntLiteral(new char[] {'0'}, _source_start, _source_end);
+		else {
+			a.sourceStart = _source_start;
+			a.sourceEnd = _source_end;
+			Debug.println("ast", a.toString());
+			return a;
+		}
+	}
+
+	public void
+	fail(String message)
+	{
+		final String msg = "GCA Parse failed: " + message + "; next token: " + scanner.next();
+		try {
+			throw new RuntimeException(msg);
+		} catch (RuntimeException e) {
+			e.printStackTrace();
+		}
+		this.problem_reporter.abortDueToInternalError(msg);
+	}
+
+	public boolean
+	accept(int kind)
+	{
+		final Token t = this.scanner.next();
+		if (t == null
+		    || t.kind != kind) {
+			this.scanner.pushBack(t);
+			return false;
+		}
+		return true;
+	}
+
+	public Token
+	peek()
+	{
+		final Token t = this.scanner.next();
+		this.scanner.pushBack(t);
+		return t;
+	}
+
+	public Expression
+	expectExpression(final Expression e)
+	{
+		if (e == null)
+			fail("Missing expression");
+		return e;
+	}
+
+	public String
+	acceptID()
+	{
+		final Token t = this.scanner.next();
+		if (t == null
+		    || t.kind != Token.ID) {
+			this.scanner.pushBack(t);
+			return null;
+		}
+		return t.toString();
+	}
+
+	public Expression
+	acceptDoubleWithPrefix(final String pfx)
+	{
+		final Token t = this.scanner.next();
+
+		if (t == null || t.kind != Token.PERIOD) {
+			this.scanner.pushBack(t);
+			return null;
+		}
+
+		final Token t2 = this.scanner.next();
+		if (t2 == null) {
+			this.scanner.pushBack(t);
+			return null;
+		}
+
+		if (t2.kind != Token.INT) {
+			this.scanner.pushBack(t2);
+			this.scanner.pushBack(t);
+			return null;
+		}
+
+		return new DoubleLiteral((pfx + t + t2).toCharArray(), pos(), pos());
+	}
+
+	public Expression
+	acceptNumber()
+	{
+		final Token t = this.scanner.next();
+		if (t == null)
+			return null;
+
+		if (t.kind != Token.INT) {
+			// ".2" format double?
+			final Expression retval = acceptDoubleWithPrefix("");
+			if (retval == null)
+				this.scanner.pushBack(t);
+			return retval;
+		}
+
+		final String integer = t.toString();
+		final Expression maybe_double = acceptDoubleWithPrefix(integer);
+
+		if (maybe_double != null)
+			return maybe_double;
+		else
+			return new IntLiteral(integer.toCharArray(), pos(), pos());
+	}
+
+	public void
+	expect(int kind, String token)
+	{
+		if (accept(kind))
+			return;
+		fail("Expected " + token);
+	}
+
+	public String
+	expectID()
+	{
+		String s;
+		if (null != (s = acceptID()))
+			return s;
+		fail("Expected identifier");
+		return null;
+	}
+
+	public SingleNameReference
+	useName(SingleNameReference snr)
+	{
+		this.name_set.add(snr);
+		return snr;
+	}
+
+	public SingleNameReference
+	acceptSingleNameReference()
+	{
+		final String n = acceptID();
+		if (n == null)
+			return null;
+		else
+			return useName(new SingleNameReference(n.toCharArray(), combo_pos()));
+	}
+
+	public SingleNameReference
+	expectSingleNameReference()
+	{
+		final String n = expectID();
+		return useName(new SingleNameReference(n.toCharArray(), combo_pos()));
+	}
+
+	public Assertion
+	parseAssertion(final int kind)
+	{
+		final Expression e = parseAssertionExpr(null);
+		final Token t = scanner.next();
+
+		if (t != null)
+			fail("expected Assertion, but found trailing token " + t);
+
+		return new Assertion(kind, e);
+	}
+
+	// fixme: take care of sourceStart, sourceEnd
+
+	// Assertion ::= <Assertion> '<->' <AssertionImplies>
+	// 	       | <AssertionImplies>
+	public Expression
+	parseAssertionExpr(final Expression lhs)
+	{
+		Expression e = parseAssertionImplies(null);
+
+		if (lhs != null) {
+			if (e == null)
+				fail("<-> without rhs");
+
+			e = new EqualExpression(lhs, e, Token.EQ);
+		}
+
+		if (e == null)
+			return null;
+
+		if (accept(Token.IFF))
+			return parseAssertionExpr(e);
+		else
+			return e;
+	}
+
+	// AssertionImplies ::= <AssertionImplies> '->' <AssertionOr>
+	// 	              | <AssertionOr>
+	public Expression
+	parseAssertionImplies(final Expression lhs)
+	{
+		Expression e = parseAssertionOr(null);
+
+		if (lhs != null) {
+			if (e == null)
+				fail("-> without rhs");
+
+			e = new OR_OR_Expression(new UnaryExpression(lhs, NOT), e, OR_OR);
+		}
+
+		if (e == null)
+			return null;
+
+		if (accept(Token.IMPLIES))
+			return parseAssertionImplies(e);
+		else
+			return e;
+	}
+
+	// AssertionOr ::= <AssertionOr> '||' <AssertionAnd>
+	// 	         | <AssertionAnd>
+	public Expression
+	parseAssertionOr(final Expression lhs)
+	{
+		Expression e = parseAssertionAnd(null);
+
+		if (lhs != null) {
+			if (e == null)
+				fail("|| without rhs");
+
+			e = new OR_OR_Expression(lhs, e, OR_OR);
+		}
+
+		if (e == null)
+			return null;
+
+		if (accept(Token.OR))
+			return parseAssertionOr(e);
+		else
+			return e;
+	}
+
+	// AssertionAnd ::= <AssertionAnd> '||' <AssertionAtom>
+	// 	          | <AssertionAtom>
+	public Expression
+	parseAssertionAnd(final Expression lhs)
+	{
+		Expression e = parseAssertionAtom();
+
+		if (lhs != null) {
+			if (e == null)
+				fail("&& without rhs");
+
+			e = new AND_AND_Expression(lhs, e, AND_AND);
+		}
+
+		if (e == null)
+			return null;
+
+		if (accept(Token.AND))
+			return parseAssertionAnd(e);
+		else
+			return e;
+	}
+
+	// AssertionAtom ::= '(' <Assertion> ')'
+	// 	        | <QExpr>
+	// 		| '!' <AssertionAtom>
+	// 	    	| <BoolEq>
+	public Expression
+	parseAssertionAtom()
+	{
+		Expression e = null;
+
+		if (accept(Token.OPAREN)) {
+			e = parseAssertionExpr(null);
+			expect(Token.CPAREN, ")");
+			return e;
+		}
+
+		if (accept(Token.NOT))
+			return new UnaryExpression(expectExpression(parseAssertionAtom()), NOT);
+
+		if (null != (e = parseQExpr()))
+			return e;
+
+		if (null != (e = parseBoolEq(null, -1)))
+			return e;
+		return null;
+	}
+
+	public TypeReference
+	parseType()
+	{
+		String s = acceptID();
+
+		if (accept(Token.PERIOD)) {
+			LinkedList components = new LinkedList();
+
+			components.addLast(s);
+
+			do {
+				components.addLast(expectID());
+			} while (accept(Token.PERIOD));
+
+			Object[] onames = components.toArray();
+			char[][] names = new char[onames.length][];
+			long[] pos = new long[onames.length];
+
+			for (int i = 0; i < onames.length; i++) {
+				names[i] = ((String)onames[i]).toCharArray();
+				pos[i] = combo_pos();
+			}
+
+			return new QualifiedTypeReference(names, pos);
+
+		} else
+			return new SingleTypeReference(s.toCharArray(), pos());
+	}
+
+	public Argument
+	parseArgument(final TypeReference tr)
+	{
+		String s = expectID();
+
+		return new Argument(s.toCharArray(), combo_pos(), tr, 0 /* modifiers */);
+	}
+
+	// Quant ::= 'forall' | 'exists'
+	// QExpr ::= <Quant> <Type> <QName> ':' <BoolExpr>
+	public Expression
+	parseQExpr()
+	{
+		boolean existential;
+
+		if (accept(Token.EXISTS))
+			existential = true;
+		else if (accept(Token.FORALL))
+			existential = false;
+		else return null;
+
+		final TypeReference ty = parseType();
+		if (ty == null)
+			fail("Quantifier not followed by type");
+
+		final Argument var = parseArgument(ty);
+		if (var == null)
+			fail("Quantifier and type not followed by identifier");
+
+		expect(Token.COLON, ":");
+
+		final Expression body = parseBoolExpr(null);
+		if (body == null)
+			fail("Quantification without body");
+
+		return new QuantifiedExpression(existential, var, body);
+	}
+
+
+	public int
+	acceptOneToken(final int[] tokens)
+	{
+		for (int i = 0; i < tokens.length; i++)
+			if (accept(tokens[i]))
+				return tokens[i];
+		return -1;
+	}
+
+	// BinEqRel ::= '=='
+	//            | '!='
+	final int[] eq_ops = new int[] { Token.EQ, Token.NE };
+
+        // BinOpRel ::= '<='
+	// 	      | '<'
+	// 	      | '>'
+	// 	      | '>='
+	final int[] linear_order_binops = new int[] { Token.LE, Token.LT, Token.GT, Token.GE };
+
+	// BoolExpr ::= <BoolExpr> '<->' <BoolExprImplies>
+	//            | <BoolExprImplies>
+	public Expression
+	parseBoolExpr(final Expression lhs)
+	{
+		Expression e = parseBoolExprImplies(null);
+
+		if (lhs != null) {
+			if (e == null)
+				fail("<-> without rhs");
+
+			e = new EqualExpression(lhs, e, Token.EQ);
+		}
+
+		if (e == null)
+			return null;
+
+		if (accept(Token.IFF))
+			return parseBoolExpr(e);
+		else
+			return e;
+	}
+
+
+	// BoolExprImplies ::= <BoolExprImplies> '->' <BoolExprOr>
+	//                   | <BoolExprOr>
+	public Expression
+	parseBoolExprImplies(final Expression lhs)
+	{
+		Expression e = parseBoolExprOr(null);
+
+		if (lhs != null) {
+			if (e == null)
+				fail("-> without rhs");
+
+			e = new OR_OR_Expression(new UnaryExpression(lhs, NOT), e, OR_OR);
+		}
+
+		if (e == null)
+			return null;
+
+		if (accept(Token.IMPLIES))
+			return parseBoolExprImplies(e);
+		else
+			return e;
+	}
+
+
+	// BoolExprOr ::= <BoolExprOr> '||' <BoolExprAnd>
+	// 	        | <BoolExprAnd>
+	public Expression
+	parseBoolExprOr(final Expression lhs)
+	{
+		Expression e = parseBoolExprAnd(null);
+
+		if (lhs != null) {
+			if (e == null)
+				fail("|| without rhs");
+
+			e = new OR_OR_Expression(lhs, e, OR_OR);
+		}
+
+		if (e == null)
+			return null;
+
+		if (accept(Token.OR))
+			return parseBoolExprOr(e);
+		else
+			return e;
+	}
+
+	// BoolExprAnd ::= <BoolExprAnd> '&&' <BoolEq>
+	// 	         | <BoolEq>
+	public Expression
+	parseBoolExprAnd(final Expression lhs)
+	{
+		Expression e = parseBoolEq(null, -1);
+
+		if (lhs != null) {
+			if (e == null)
+				fail("&& without rhs");
+
+			e = new AND_AND_Expression(lhs, e, AND_AND);
+		}
+
+		if (e == null)
+			return null;
+
+		if (accept(Token.AND))
+			return parseBoolExprAnd(e);
+		else
+			return e;
+	}
+
+	// BoolEq ::= <BoolEq> <BinEqRel> <BoolRel>
+	//          | <BoolRel>           
+	public Expression
+	parseBoolEq(Expression lhs, int op)
+	{
+		Expression e = parseBoolRel(null, -1);
+
+		if (lhs != null) {
+			if (e == null)
+				fail("equality operator without rhs");
+
+			e = new EqualExpression(lhs, e, op);
+		}
+
+		if (e == null)
+			return null;
+
+		int new_operator;
+		if (-1 != (new_operator = acceptOneToken(eq_ops)))
+			return parseBoolEq(e, new_operator);
+		else
+			return e;
+	}
+
+
+	// BoolRel ::= <BoolRel> <BinOpRel> <BoolGround>
+	//           | <BoolRel> <instanceof> <Type>
+	//           | <BoolGround>
+	public Expression
+	parseBoolRel(Expression lhs, int op)
+	{
+		Expression e = parseBoolGround();
+
+		if (lhs != null) {
+			if (e == null)
+				fail("comparison operator without rhs");
+
+			e = new BinaryExpression(lhs, e, op);
+		}
+
+		if (e == null)
+			return null;
+
+		int new_operator;
+		if (-1 != (new_operator = acceptOneToken(linear_order_binops)))
+			return parseBoolRel(e, new_operator);
+		else if (accept(Token.INSTANCEOF)) {
+			final TypeReference ty = parseType();
+			return new InstanceOfExpression(e, ty);
+		} else
+			return e;
+	}
+
+
+	// BoolGround ::= '(' <BoolExpr> ')'
+	//            | '!' <BoolGround>
+	//            | 'reach' '(' <ReachSpecSeq> ')' '[' <QName> ']'
+	//            | <Expr>
+	public Expression
+	parseBoolGround()
+	{
+		if (accept(Token.OPAREN)) {
+			Expression e = parseBoolExpr(null);
+			expect(Token.CPAREN, ")");
+			return e;
+		}
+
+		if (accept(Token.NOT))
+			return new UnaryExpression(expectExpression(parseBoolGround()), NOT);
+
+		if (accept(Token.REACH)) {
+			expect(Token.OBRACKET, "[");
+			ReachSpec rs = parseReachSpecSeq();
+			if (rs == null)
+				fail("Expected `reach' path specification");
+			expect(Token.CBRACKET, "]");
+			expect(Token.OPAREN, "(");
+			SingleNameReference name = expectSingleNameReference();
+			expect(Token.CPAREN, ")");
+			return new ReachExpression(name, rs);
+		}
+
+		return parseExpr();
+	}
+
+
+	// ReachSpecSeq ::= <ReachSpec>
+	// 	          | <ReachSpecSeq> ',' <ReachSpec>
+	public ReachSpec
+	parseReachSpecSeq()
+	{
+		final LinkedList l = parseReachSpecSequence(new LinkedList());
+		if (l == null)
+			return null;
+
+		ReachSpec.Traversal[] traversals = new ReachSpec.Traversal[l.size()];
+		for (int i = 0; i < l.size(); i++)
+			traversals[i] = (ReachSpec.Traversal)l.get(i); // yes, slow
+
+		return new ReachSpec(traversals);
+	}
+
+	public LinkedList
+	parseReachSpecSequence(LinkedList entries)
+	{
+		final ReachSpec.Traversal t = parseReachSpec();
+		if (t == null)
+			return null;
+
+		entries.addLast(t);
+
+		// Yes, I'm a functional programmer.  Yes, this is slow in Java.  But this is research code, so deal with it.
+		// If I wanted fast code, I wouldn't be writing a recursive descent parser by hand, now would I?
+		if (accept(Token.COMMA))
+			return parseReachSpecSequence(entries);
+		else
+			return entries;
+	}
+
+	// ReachSpec ::= <ReachSource>
+	// 	    | <ReachSource> '/' <NodeSet>
+	public ReachSpec.Traversal
+	parseReachSpec()
+	{
+		NameReference sources[] = parseReachSource();
+		NameReference ignores[] = null;
+
+		if (accept(Token.SLASH))
+			ignores = parseNodeSet();
+
+		return new ReachSpec.Traversal(sources, ignores);
+	}
+
+	// ReachSource ::= (* empty *)
+	// 	      | <NodeSet>
+	public NameReference[]
+	parseReachSource()
+	{
+		if (peek() != null && peek().kind == Token.SLASH)
+			return new NameReference[0];
+		return parseNodeSet();
+	}
+
+	// NodeSet ::= '{' <NameSet> '}'
+	//           | <Name>
+	public NameReference[]
+	parseNodeSet()
+	{
+		final NameReference singleton = parseQName();
+		if (singleton == null) {
+			expect(Token.OBRACE, "{");
+			final LinkedList ll = parseNameSet(new LinkedList());
+			final NameReference[] retval = new NameReference[ll.size()];
+			for (int i = 0; i < ll.size(); i++)
+				retval[i] = (NameReference)ll.get(i);
+			expect(Token.CBRACE, "}");
+			return retval;
+		}
+		else return new NameReference[] { singleton };
+	}
+
+
+	// NameSet ::= <QName>
+	// 	  | <NameSet> ',' <QName>
+	public LinkedList
+	parseNameSet(LinkedList elements)
+	{
+		elements.addLast(parseQName());
+		if (accept(Token.COMMA))
+			return parseNameSet(elements);
+		else
+			return elements;
+	}
+
+	public NameReference
+	parseQName()
+	{
+		String s = acceptID();
+
+		if (s == null)
+			return null;
+
+		if (accept(Token.PERIOD)) {
+			LinkedList components = new LinkedList();
+
+			components.addLast(s);
+
+			do {
+				components.addLast(expectID());
+			} while (accept(Token.PERIOD));
+
+			Object[] onames = components.toArray();
+			char[][] names = new char[onames.length][];
+			long[] pos = new long[onames.length];
+
+			for (int i = 0; i < onames.length; i++) {
+				names[i] = ((String)onames[i]).toCharArray();
+				pos[i] = combo_pos();
+			}
+
+			return new QualifiedNameReference(names, pos, pos(), pos());
+
+		} else
+			return new SingleNameReference(s.toCharArray(), pos());
+	}
+
+	// Expr ::= <Name>
+	//        | <Expr> '.' <Name>
+	//        | <int>
+	//        | 'null'
+	//        | 'true'
+	//        | 'false'
+	//        | '(' <Expr> ')'
+	public Expression
+	parseExpr()
+	{
+		if (accept(Token.OPAREN)) {
+			final Expression e = parseExpr();
+			expect(Token.CPAREN, ")");
+			return e;
+		}
+
+		if (accept(Token.NULL))
+			return new NullLiteral(pos(), pos());
+		if (accept(Token.TRUE))
+			return new TrueLiteral(pos(), pos());
+		if (accept(Token.FALSE))
+			return new FalseLiteral(pos(), pos());
+		final Expression num_expr = acceptNumber();
+		if (num_expr != null)
+			return num_expr;
+		return parseQName();
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/PredicateFamily.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/PredicateFamily.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/PredicateFamily.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/PredicateFamily.java	2010-03-22 13:37:59.000000000 +0000
@@ -0,0 +1,109 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.ast.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+
+import java.util.*;
+
+/**
+ * A predicate family represents the body of a quantified expression and provides
+ * operations for specialising this operation for various reach specs.
+ */
+public class PredicateFamily
+{
+	BindingWrapper[] env;
+	ReachSpec[] reach_specs;
+	GCANode body;
+	TypeBinding query_var_ty;
+	QuantifiedExpression qexpr;
+
+	public static TypeBinding object_type = null; // initialised the first time we process a spec
+
+	public
+	PredicateFamily(final TypeBinding _query_var_ty,
+			final GCANode _body,
+			final BindingWrapper[] _env,
+			final QuantifiedExpression _owner,
+			final ReachSpec[] _reach_specs)
+	{
+		this.query_var_ty = _query_var_ty;
+		this.body = _body;
+		this.env = _env;
+		this.qexpr = _owner;
+		this.reach_specs = _reach_specs;
+	}
+
+	public void
+	insertClassesInto(final Set /* String */ set) {
+		set.add(this.query_var_ty.debugName());
+
+		this.body.accept(new GCANodeVisitor() {
+				public void visitInstanceOf(final GCAInstanceOf _instance_of) {
+					set.add(_instance_of.ty.debugName());
+				}});
+	}
+
+	public String
+	toString()
+	{
+		String retval = this.body + "\n";
+		for (int i = 0; i < this.env.length; i++)
+			retval += "  $" + i + " = " + env[i] + "\n";
+		for (int i = 0; i < this.reach_specs.length; i++)
+			retval += "  with t#" + i + " = " + reach_specs[i] + "\n";
+		return retval;
+	}
+
+
+	public void
+	emitEnvironmentArray(final CodeStream cs, final BlockScope scope, final PredicateLinkage plinkage)
+	{
+		if (env == null || this.env.length == 0) {
+			cs.aconst_null();
+			return;
+		}
+		cs.generateInlinedValue(this.env.length);
+		cs.anewarray("java/lang/Object".toCharArray());
+		for (int i = 0; i < env.length; i++) {
+			cs.dup();
+			cs.generateInlinedValue(i);
+			this.env[i].emitLoad(cs, scope, plinkage);
+			cs.aastore();
+		}
+	}
+
+
+	/**
+	 * Specialise to a given reach spec
+	 *
+	 * @param spec The reach spec to specialise for, or null to filter out all
+	 */
+	public GCAClosure
+	specialise(final ReachSpec spec)
+	{
+		GCANode clone = this.body.copy();
+		clone = clone.subst(new GCANodeTest() {
+				public final boolean test(GCANode n)
+				{
+					if (n instanceof GCATraversalConstant) {
+						GCATraversalConstant trav = (GCATraversalConstant) n;
+						if (spec != null && spec.equals(trav.reach_spec))
+							return true;
+					}
+					return false;
+				}
+			},
+			GCATrue.TRUE);
+
+		clone = clone.subst(new GCANodeTest() {
+				public final boolean test(GCANode n)
+				{
+					return (n instanceof GCATraversalConstant);
+				}
+			},
+			GCAFalse.FALSE);
+
+		return new GCAClosure(this.query_var_ty, clone.fold(), env);
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/PredicateLinkage.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/PredicateLinkage.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/PredicateLinkage.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/PredicateLinkage.java	2010-03-23 01:40:28.000000000 +0000
@@ -0,0 +1,678 @@
+package org.eclipse.jdt.internal.compiler.gca;
+import org.eclipse.jdt.internal.compiler.*;
+import org.eclipse.jdt.internal.compiler.codegen.*;
+import org.eclipse.jdt.internal.compiler.ast.*;
+import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+
+import java.util.*;
+
+/**
+ * Collection of predicate families for a given assertion.  This class handles the allocation
+ * and management of static predicate function names.
+ */
+public final class PredicateLinkage
+{
+	public ArrayList /* ReachSpec */ reach_specs_list = new ArrayList(); // first entry is always null, cf. `link()'
+	public ReachSpec[] reach_specs = null; // initialised after linking
+	public HashMap /* GCAClosure, Integer */ predicates = new HashMap();
+	public ArrayList /* GCAClosure */ closure_list = new ArrayList();
+	public ArrayList /* PredicateClassLinkage */ predicate_families = new ArrayList();
+	public HashSet /* String */ instance_classes = new HashSet(); // All classes we run instanceof checks of, stringified
+
+	// during code generation
+	public TypeDeclaration declaring_class;
+	public int predicate_method_offset;
+	public CodeStream cs;
+	public BlockScope scope;
+	public boolean assert_disjointness;
+	private int disjoin_id = 1;
+	private static final int NEUTRAL_DISJOIN_ID = 0x0; // this traversal ID is used for `non-intrusive' traversals
+	private static final int MAX_DISJOIN_ID = 0x07;
+	private HashSet /* NameReference */ ignored_nodes; // nodes that we need to traverse as final pass
+
+	private LinkedList /* EmitStep */ steps = new LinkedList();
+
+	public PredicateLinkage()
+	{
+		// Reach spec for `anything not reachable within an intended traversal'
+		this.reach_specs_list.add(null);
+	}
+
+	public void
+	addPredicateFamily(final PredicateFamily _predicate_family)
+	{
+		this.predicate_families.add(new PredicateClassLinkage(_predicate_family));
+
+		// yes, yes.  Quadratic.  Can be made log-linear or better.
+		for (int i = 0; i < _predicate_family.reach_specs.length; i++)
+			this.addReachSpec(_predicate_family.reach_specs[i]);
+	}
+
+	private void
+	addReachSpec(final ReachSpec new_reach_spec)
+	{
+		// first entry is null, so skip it
+		for (int i = 1; i < this.reach_specs_list.size(); i++)
+			if (new_reach_spec.equals(this.reach_specs_list.get(i)))
+				return;
+		this.reach_specs_list.add(new_reach_spec);
+	}
+
+	private static String
+	showReachSpec(ReachSpec s)
+	{
+		if (s == null)
+			return "*";
+		else
+			return s.toString();
+	}
+
+	/**
+	 * Link everything, after all predicate families are accounted for
+	 */
+	public void
+	link()
+	{
+		// pass 1: sort reach specs.  Non-root ones go first, then comes a whole-heap traversal, then come dominance checks.
+		// If we have dominator checks, we don't need a `null' pass at the end:
+		this.reach_specs = new ReachSpec[this.reach_specs_list.size()];
+		int reach_specs_nr = 0;
+		for (int i = 1; i < this.reach_specs_list.size(); i++) {
+			final ReachSpec rs = (ReachSpec)this.reach_specs_list.get(i);
+			if (!rs.isDominator())
+				this.reach_specs[reach_specs_nr++] = rs;
+		}
+		for (int i = 1; i < this.reach_specs_list.size(); i++) {
+			final ReachSpec rs = (ReachSpec)this.reach_specs_list.get(i);
+			if (rs.isDominator())
+				this.reach_specs[reach_specs_nr++] = rs;
+		}
+		this.reach_specs[reach_specs_nr++] = null;
+
+		this.reach_specs_list = null;
+
+		// pass 2: register all GCAClosures
+		for (int i = 0; i < this.predicate_families.size(); i++) {
+			final PredicateClassLinkage pcl = (PredicateClassLinkage) this.predicate_families.get(i);
+			for (int k = 0; k < this.reach_specs.length; k++) {
+				final ReachSpec rs = this.reach_specs[k];
+//				Debug.println("T", " -- T" + i + "(#" + k + ": " + showReachSpec(rs) + ")");
+				final GCAClosure closure = pcl.getClosure(rs);
+
+				if (!closure.isTrivial() && !this.predicates.containsKey(closure)) {
+					int index = this.closure_list.size();
+					this.closure_list.add(closure);
+					this.predicates.put(closure, new Integer(index));
+				}
+				Debug.println("T", "T" + i + "(" + showReachSpec(rs) + ") = " + closure);
+			}
+		}
+
+		// pass 3: link
+		for (int i = 0; i < this.predicate_families.size(); i++) {
+			final PredicateClassLinkage pcl = (PredicateClassLinkage) this.predicate_families.get(i);
+			pcl.link();
+		}
+		if (this.closure_list.size() == 1)
+			Debug.println("T", "1 predicate function needed");
+		else
+			Debug.println("T", (this.closure_list.size()) + " predicate functions needed");
+	}
+
+	/**
+	 * @param method_offset Offset of the first method we will be generating in the method table
+	 * @param class_file class to generate methods in
+	 * @return Number of methods generated
+	 */
+	public int
+	addMethods(final TypeDeclaration declaring_class,
+		   final Assertion assertion,
+		   final int method_offset)
+	{
+		if (predicates.size() == 0)
+			return 0;
+
+		final AbstractMethodDeclaration[] new_methods = new AbstractMethodDeclaration[declaring_class.methods.length + predicates.size()];
+		System.arraycopy(declaring_class.methods, 0, new_methods, 0, method_offset);
+		System.arraycopy(declaring_class.methods, method_offset,
+				 new_methods, method_offset + predicates.size(),
+				 declaring_class.methods.length - method_offset);
+		declaring_class.methods = new_methods;
+
+		for (int i = 0; i < predicates.size(); i++) {
+			final AssertionPredicateMethod apm = new AssertionPredicateMethod(i + method_offset,
+											  assertion,
+											  declaring_class,
+											  (GCAClosure) this.closure_list.get(i));
+			new_methods[i + method_offset] = apm;
+		}
+		return predicates.size();
+	}
+
+	public static final char[] CONSTRUCTOR_NAME = "<init>".toCharArray();
+
+	public static final String GCA_PACKAGE = "org/mmtk/plan/marksweep/gcassertions/spec";
+
+	public static final String GCA_ASSERTION			= (GCA_PACKAGE + "/Assertion");
+	public static final String GCA_PREDICATE_FAMILY			= (GCA_PACKAGE + "/PredicateFamily");
+
+	//----------------------------------------
+	public static final String GCA_STEP				= (GCA_PACKAGE + "/Step");
+
+	public static final String GCA_EXCLUDE_NODES			= (GCA_PACKAGE + "/ExcludeNodesStep");
+	public static final String GCA_INCLUDE_NODES			= (GCA_PACKAGE + "/IncludeNodesStep");
+	public static final String GCA_SET_TRAVERSAL_ID			= (GCA_PACKAGE + "/SetTraversalIdStep");
+	public static final String GCA_SET_TRAVERSAL_PREDICATES		= (GCA_PACKAGE + "/SetTraversalPredicatesStep");
+	public static final String GCA_TRAVERSAL			= (GCA_PACKAGE + "/TraversalStep");
+
+	static final char[]
+	getTy(String s)
+	{
+		return ("L" + s).toCharArray();
+	}
+
+	static final char[]
+	getArrayTy(String s)
+	{
+		return ("[L" + s).toCharArray();
+	}
+
+	public void
+	constructor(final String classname, final String[] args)
+	{
+		cs.doInvokeConstructor(classname, args);
+	}
+
+	public void
+	invokestatic(final String classname, final String methodname, final String[] args, final String retty)
+	{
+		cs.doInvokeStatic(classname, methodname, args, retty);
+	}
+
+
+	public void
+	emitSteps()
+	{
+		cs.generateInlinedValue(this.steps.size() + 4);
+		cs.anewarray(GCA_STEP.toCharArray());
+
+		int offset = 0;
+
+		cs.dup();
+		cs.generateInlinedValue(offset++);
+		cs.aconst_null();
+		cs.aastore();
+
+		Iterator it = this.steps.iterator();
+		while (it.hasNext()) {
+			final EmitStep es = (EmitStep) it.next();
+			Debug.println("traversal", " #" + (offset) + ": " + es);
+			cs.dup();
+			cs.generateInlinedValue(offset++);
+			es.doEmit();
+			cs.aastore();
+		}
+
+		for (int i = 0; i < 3; i++) {
+			cs.dup();
+			cs.generateInlinedValue(offset++);
+			cs.aconst_null();
+			cs.aastore();
+		}
+		
+	}
+
+	private void
+	preloadClasses()
+	{
+		if (!this.instance_classes.isEmpty()) {
+			BranchLabel endlabel = new BranchLabel(this.cs);
+			final Iterator it = this.instance_classes.iterator();
+			while (it.hasNext()) {
+				String class_name = (String)it.next();
+//				System.out.println("Pre-loading class `"+class_name+"'");
+				this.cs.ldc(class_name);
+				this.invokestatic("java/lang/Class", "forName", new String[] { "Ljava/lang/String;" }, "Ljava/lang/Class;");
+				this.cs.pop();
+			}
+			this.cs.goto_(endlabel);
+			cs.new_("java/lang/RuntimeException".toCharArray());
+			cs.dup_x1();
+			cs.swap();
+			this.constructor("java/lang/RuntimeException", new String[] { "Ljava/lang/Throwable;" });
+			cs.athrow();
+			endlabel.place();
+		}
+	}
+
+	/**
+	 * Code emitter for GCA invocation
+	 */
+	public void
+	emit(final CodeStream _cs,
+	     final BlockScope _scope,
+	     final int predicate_array_varid,
+	     final TypeDeclaration _declaring_class,
+	     final int _predicate_method_offset,
+	     final Expression body,
+	     final boolean _assert_disjointness)
+	{
+		this.predicate_method_offset = _predicate_method_offset;
+		this.declaring_class = _declaring_class;
+		this.cs = _cs;
+		this.scope = _scope;
+		this.assert_disjointness = _assert_disjointness && this.reach_specs.length > 2;
+
+		// ---------- Classloading prelude ----------
+		this.preloadClasses();
+
+		// ---------- LINE 1 ----------
+		// first, create the Predicate array
+		cs.generateInlinedValue(this.predicate_families.size());
+		cs.anewarray(GCA_PREDICATE_FAMILY.toCharArray());
+		// Initialise predicate array with our predicates
+   		for (int i = 0; i < this.predicate_families.size(); i++)
+   			((PredicateClassLinkage)this.predicate_families.get(i)).emitPredicateInitialiser(cs, scope, i);
+ 		cs.astore(predicate_array_varid);
+
+		// ---------- LINE 2 ----------
+		// Run the assertion and report any errors
+ 		cs.new_(GCA_ASSERTION.toCharArray());
+ 		cs.dup();
+ 		cs.aload(predicate_array_varid);
+  		this.computeSteps();
+  		this.emitSteps();
+ 		this.constructor(GCA_ASSERTION, new String[] { "[L" + GCA_PREDICATE_FAMILY, "[L" + GCA_STEP });
+ 		this.invokestatic(GCA_ASSERTION, "doAssert", new String[] { "L" + GCA_ASSERTION }, "Z");
+ 		body.generateCode(scope, cs, true);
+  		this.invokestatic(GCA_ASSERTION, "checkAssert", new String[] { "Z", "Z" }, "V");
+
+ 		// ---------- LINE 3 ----------
+ 		// clear the Predicate array
+ 		cs.aconst_null();
+ 		cs.astore(predicate_array_varid);
+	}
+
+
+	void
+	addStep(final EmitStep s)
+	{
+		this.steps.addLast(s);
+	}
+
+	void
+	addTraversalIdStep(final int tid)
+	{
+		if (!assert_disjointness)
+			return;
+		if (tid >= MAX_DISJOIN_ID)
+			throw new RuntimeException("Too many traversal passes!");
+		addStep(new SetTraversalIdStep(tid));
+	}
+
+	void
+	addNeutralTraversalIdStep()
+	{
+		addTraversalIdStep(NEUTRAL_DISJOIN_ID);
+	}
+
+	// Part 1 of mark program: `reach' traversals
+	void
+	computeSteps()
+	{
+		boolean did_root_traversal = false;
+
+		this.ignored_nodes = new HashSet();
+		HashSet local_ignores = new HashSet();
+		for (int i = 0; i < this.reach_specs.length; i++) {
+			local_ignores.clear();
+			final ReachSpec rs = this.reach_specs[i];
+
+			addStep(new SetTraversalPredicatesStep(i));
+			if (rs == null) {
+//				computeIgnoreDominated(i + 1);
+				if (!did_root_traversal) {
+					addNeutralTraversalIdStep();
+					computeRootTraversal(i);
+				}
+//				computeDominateSteps(i + 1);
+				computeFinalCleanup();
+				return;
+			} else {
+				final int traversal_id = disjoin_id++;
+				addTraversalIdStep(traversal_id);
+			}
+
+			for (int k = 0; k < rs.traversals.length; k++) {
+				ReachSpec.Traversal trav = rs.traversals[k];
+				for (int l = 0; l < trav.ignores.length; l++)
+					local_ignores.add(trav.ignores[l]);
+				addStep(new ExcludeNodesStep(trav.ignores));
+				if (trav.sources.length == 0 && !did_root_traversal) {
+					addStep(new MarkRootsStep());
+					did_root_traversal = true;
+				} else
+					addStep(new MarkStep(trav.sources));
+			}
+
+// 			if (local_ignores.size() > 0)
+// 				addStep(new IncludeNodesStep(local_ignores));
+			this.ignored_nodes.addAll(local_ignores);
+		}
+
+	}
+
+	// part 2 of mark program: ignore all dominated nodes
+	void
+	computeIgnoreDominated(final int offset)
+	{
+		HashSet ignores = new HashSet();
+		for (int i = offset; i < this.reach_specs.length; i++) {
+			final ReachSpec rs = this.reach_specs[i];
+			if (rs.traversals.length > 0)
+				for (int k = 0; k < rs.traversals[0].ignores.length; k++) {
+					NameReference nr = rs.traversals[0].ignores[k];
+					ignores.add(nr);
+				}
+		}
+		if (!ignores.isEmpty())
+			addStep(new ExcludeNodesStep(ignores));
+	}
+
+	// part 3 of mark program: mark from root
+	void
+	computeRootTraversal(final int offset)
+	{
+//		addStep(new SetTraversalPredicatesStep(offset));
+		addStep(new MarkRootsStep());
+	}
+
+	// part 4 of mark program: `dominate' tests
+	void
+	computeDominateSteps(final int offset)
+	{
+		HashSet local_ignores = new HashSet();
+		for (int i = offset; i < this.reach_specs.length; i++) {
+			local_ignores.clear();
+			final ReachSpec rs = this.reach_specs[i];
+
+			final int traversal_id = disjoin_id++;
+			addTraversalIdStep(traversal_id);
+			addStep(new SetTraversalPredicatesStep(i));
+			// start at offset 1, since we already ignored the outer level
+			for (int k = 1; k < rs.traversals.length; k++) {
+				ReachSpec.Traversal trav = rs.traversals[k];
+				for (int l = 0; l < trav.ignores.length; l++)
+					local_ignores.add(trav.ignores[l]);
+				addStep(new ExcludeNodesStep(trav.ignores));
+				addStep(new MarkStep(trav.sources));
+			}
+			// Mark `ignored' set for `dominates' check... this is very hackish.
+			if (rs.traversals[0].ignores.length > 0) {
+				addStep(new IncludeNodesStep(rs.traversals[0].ignores));
+				addStep(new MarkStep(rs.traversals[0].ignores));
+			}
+
+			if (local_ignores.size() > 0)
+				addStep(new IncludeNodesStep(local_ignores));
+			this.ignored_nodes.addAll(local_ignores);
+		}
+	}
+
+	void
+	computeFinalCleanup()
+	{
+		if (!ignored_nodes.isEmpty()) {
+			addStep(new IncludeNodesStep(this.ignored_nodes));
+			addStep(new MarkStep(this.ignored_nodes));
+		}
+		// Avoid invalid overlaps with the Assertion cleanup code (this should really be in the runtime):
+		addTraversalIdStep(0);
+	}
+
+
+	public class PredicateClassLinkage
+	{
+		final static int NO_BINDING = -1;
+		public int[] bindings; // magic method indices 
+		public PredicateFamily predicate_family;
+
+		public
+		PredicateClassLinkage(final PredicateFamily _predicate_family)
+		{
+			this.predicate_family = _predicate_family;
+		}
+
+		public GCAClosure
+		getClosure(final ReachSpec _rs)
+		{
+			return this.predicate_family.specialise(_rs);
+		}
+
+		public void
+		link()
+		{
+			this.bindings = new int[PredicateLinkage.this.reach_specs.length];
+			this.predicate_family.insertClassesInto(PredicateLinkage.this.instance_classes);
+
+			for (int i = 0; i < PredicateLinkage.this.reach_specs.length; i++) {
+				final ReachSpec rs = PredicateLinkage.this.reach_specs[i];
+				final GCAClosure closure = this.getClosure(rs);
+
+				if (closure.isTrivial())
+					this.bindings[i] = NO_BINDING;
+				else {
+					Integer key = (Integer) PredicateLinkage.this.predicates.get(closure);
+					if (key == null) {
+						System.out.println("=== Mismatch!");
+						final Iterator it = PredicateLinkage.this.predicates.keySet().iterator();
+						while (it.hasNext()) {
+							Object k = it.next();
+							Object v = PredicateLinkage.this.predicates.get(k);
+							if (k != null)
+								System.out.println("  # " + k + " -> " + v + "[" + k.equals(closure) + "; " + k.hashCode() + ", " + closure.hashCode() + "]");
+							else
+								System.out.println("  # " + null + " -> " + v);
+						}
+						throw new RuntimeException("Internal error: No linkage for linked closure (" + closure + ")?");
+					}
+					this.bindings[i] = key.intValue();
+				}
+			}
+		}
+
+		public void
+		emitPredicateInitialiser(final CodeStream cs, final BlockScope scope, final int index)
+		{
+			cs.dup();
+			cs.generateInlinedValue(index);
+
+			{ // invoke constructor
+				cs.new_(GCA_PREDICATE_FAMILY.toCharArray());
+				cs.dup();
+				// arg 1: class containing our magic methods
+				cs.generateClassLiteralAccessForType(PredicateLinkage.this.declaring_class.binding, null);
+				// arg 2: array with method IDs
+				cs.generateInlinedValue(this.bindings.length);
+				cs.newarray(ClassFileConstants.INT_ARRAY);
+				for (int i = 0; i < this.bindings.length; i++) {
+					cs.dup();
+					cs.generateInlinedValue(i);
+					if (this.bindings[i] == NO_BINDING)
+						cs.generateInlinedValue(NO_BINDING);
+					else
+						cs.generateInlinedValue(this.bindings[i] + PredicateLinkage.this.predicate_method_offset);
+					cs.iastore();
+				}
+				// arg 3: environment array
+				this.predicate_family.emitEnvironmentArray(cs, scope, PredicateLinkage.this);
+				// arg 4: existential flag
+				cs.generateInlinedValue(predicate_family.qexpr.existential);
+				// Constructor
+				PredicateLinkage.this.constructor(GCA_PREDICATE_FAMILY,
+								  new String[] { "Ljava/lang/Class", "[I", "[Ljava/lang/Object", "Z"});
+			}
+
+			cs.aastore();
+		}
+
+
+	}
+
+
+	public abstract class EmitStep {
+		public abstract void doEmit();
+	}
+
+	public abstract class EmitNameReferenceStep extends EmitStep {
+		HashSet nodes = new HashSet();
+		public EmitNameReferenceStep(AbstractSet s)
+		{
+			this.add(s);
+		}
+		public EmitNameReferenceStep(NameReference n)
+		{
+			this.add(n);
+		}
+		public EmitNameReferenceStep(NameReference[] ns)
+		{
+			this.add(ns);
+		}
+		public void
+		add(AbstractSet s)
+		{
+			this.nodes.addAll(s);
+		}
+		public void
+		add(NameReference n)
+		{
+			this.nodes.add(n);
+		}
+		public void
+		add(NameReference[] ns)
+		{
+			for (int i = 0; i < ns.length; i++)
+				this.nodes.add(ns[i]);
+		}
+		protected void
+		inlineValues()
+		{
+			cs.generateInlinedValue(nodes.size());
+			cs.anewarray("java/lang/Object".toCharArray());
+			Iterator it = this.nodes.iterator();
+			int index = 0;
+			while (it.hasNext()) {
+				cs.dup();
+				cs.generateInlinedValue(index++);
+				((NameReference)it.next()).generateCode(scope, cs, true);
+				cs.aastore();
+			}
+		}
+		public String
+		toString()
+		{
+			String s = "";
+			Iterator it = this.nodes.iterator();
+			while (it.hasNext()) {
+				final NameReference nr = (NameReference) it.next();
+				if (s != "")
+					s += ", ";
+				s += nr.toString();
+			}
+			return s;
+		}
+	}
+
+	public class ExcludeNodesStep extends EmitNameReferenceStep {
+		public ExcludeNodesStep(AbstractSet s) { super (s); }
+		public ExcludeNodesStep(NameReference s) { super (s); }
+		public ExcludeNodesStep(NameReference[] s) { super (s); }
+		public void doEmit()
+		{
+			cs.new_(GCA_EXCLUDE_NODES.toCharArray());
+			cs.dup();
+			inlineValues();
+			constructor(GCA_EXCLUDE_NODES, new String[] { "[Ljava/lang/Object" });
+		}
+		public String toString() { return "exclude-nodes(" + super.toString() + ")"; }
+	}
+
+	public class IncludeNodesStep extends EmitNameReferenceStep {
+		public IncludeNodesStep(AbstractSet s) { super (s); }
+		public IncludeNodesStep(NameReference s) { super (s); }
+		public IncludeNodesStep(NameReference[] s) { super (s); }
+		public void doEmit()
+		{
+			cs.new_(GCA_INCLUDE_NODES.toCharArray());
+			cs.dup();
+			inlineValues();
+			constructor(GCA_INCLUDE_NODES, new String[] { "[Ljava/lang/Object" });
+		}
+		public String toString() { return "include-nodes(" + super.toString() + ")"; }
+	}
+
+	public class MarkRootsStep extends EmitStep {
+		public void doEmit()
+		{
+			cs.new_(GCA_TRAVERSAL.toCharArray());
+			cs.dup();
+			constructor(GCA_TRAVERSAL, new String[] { });
+		}
+		public String toString() { return "mark-roots"; }
+	}
+
+	public class MarkStep extends EmitNameReferenceStep {
+		public MarkStep(AbstractSet s) { super (s); }
+		public MarkStep(NameReference s) { super (s); }
+		public MarkStep(NameReference[] s) { super (s); }
+		public void doEmit()
+		{
+			cs.new_(GCA_TRAVERSAL.toCharArray());
+			cs.dup();
+			inlineValues();
+			constructor(GCA_TRAVERSAL, new String[] { "[Ljava/lang/Object" });
+		}
+		public String toString() { return "mark(" + super.toString() + ")"; }
+	}
+
+	public class SetTraversalIdStep extends EmitStep {
+		int id;
+		public SetTraversalIdStep(final int _id)
+		{
+			this.id = _id;
+		}
+
+		public void doEmit()
+		{
+			cs.new_(GCA_SET_TRAVERSAL_ID.toCharArray());
+			cs.dup();
+			cs.generateInlinedValue(id);
+			constructor(GCA_SET_TRAVERSAL_ID, new String[] { "I" });
+		}
+		public String toString() { return "set-traversal-id(" + this.id + ")"; }
+	}
+
+	public class SetTraversalPredicatesStep extends EmitStep {
+		int id;
+		public SetTraversalPredicatesStep(final int _id)
+		{
+			this.id = _id;
+		}
+		public void doEmit()
+		{
+			cs.new_(GCA_SET_TRAVERSAL_PREDICATES.toCharArray());
+			cs.dup();
+			cs.generateInlinedValue(predicate_families.size());
+			cs.newarray(TypeIds.T_int);
+			for (int i = 0; i < predicate_families.size(); i++) {
+				cs.dup();
+				cs.generateInlinedValue(i);
+				cs.generateInlinedValue(this.id);
+				cs.iastore();
+			}
+			constructor(GCA_SET_TRAVERSAL_PREDICATES, new String[] { "[I" });
+		}
+		public String toString() { return "set-traversal-predicates(" + this.id + ")"; }
+	}
+}
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/Scanner.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/Scanner.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/Scanner.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/Scanner.java	2010-03-16 21:55:37.000000000 +0000
@@ -0,0 +1,140 @@
+package org.eclipse.jdt.internal.compiler.gca;
+
+import java.util.*;
+
+/**
+ * Writing this made me realise just how horrible writing scanners in Java is-- in all its
+ * libraries, there is NO sensible support for that task.
+ */
+public class Scanner
+{
+	private char [] input;
+	private final int offset;
+	private int relative_offset;
+
+	private LinkedList pushed_back = new LinkedList();
+
+	public int
+	offset()
+	{
+		return offset + relative_offset;
+	}
+
+	public
+	Scanner(final String _body, final int _offset)
+	{
+		this.offset = _offset;
+		this.input = _body.toCharArray();
+		this.relative_offset = 0;
+	}
+
+	public void
+	pushBack(Token t)
+	{
+		if (t != null)
+			this.pushed_back.addFirst(t);
+	}
+
+	private final Token
+	trySimpleToken(final int id, final String s)
+	{
+		final char[] chars = s.toCharArray(); // Yes, this is terrible.  But this is research code, so I don't care.
+
+		if (chars.length > this.input.length - this.relative_offset)
+			return null;
+
+		for (int i = 0; i < chars.length; i++)
+			if (chars[i] != this.input[i + this.relative_offset])
+				return null;
+
+		return new Token(id, s,
+				 this.offset + this.relative_offset,
+				 this.offset + (this.relative_offset += chars.length));
+	}
+
+	private final Token
+	tryID()
+	{
+		int offset = this.relative_offset;
+
+		if (!Character.isJavaIdentifierStart(this.input[offset++]))
+			return null;
+
+		while (offset < this.input.length
+		       && Character.isJavaIdentifierPart(this.input[offset]))
+			++offset;
+
+		return new Token(Token.ID, new String(this.input, this.relative_offset, offset - this.relative_offset),
+				 this.offset + this.relative_offset,
+				 this.offset + (this.relative_offset = offset));
+	}
+
+	private final Token
+	tryInt()
+	{
+		int offset = this.relative_offset;
+
+		if (!Character.isDigit(this.input[offset++]))
+			return null;
+
+		while (offset < this.input.length && Character.isDigit(this.input[offset]))
+			++offset;
+
+		return new Token.IntToken(Integer.parseInt(new String(this.input, this.relative_offset, offset - this.relative_offset)),
+					  this.offset + this.relative_offset,
+					  this.offset + (this.relative_offset = offset));
+	}
+
+	public Token
+	next()
+	{
+		if (!this.pushed_back.isEmpty())
+			return (Token)this.pushed_back.removeFirst();
+
+		if (this.input.length <= this.relative_offset)
+			return null;
+
+		while (this.input.length > this.relative_offset
+		       && Character.isWhitespace(this.input[this.relative_offset]))
+			++this.relative_offset;
+
+		if (this.input.length <= this.relative_offset)
+			return null;
+
+		Token t;
+
+		if (null != (t = trySimpleToken(Token.OR, "||"))) return t;
+		if (null != (t = trySimpleToken(Token.AND, "&&"))) return t;
+		if (null != (t = trySimpleToken(Token.IFF, "<->"))) return t;
+		if (null != (t = trySimpleToken(Token.IMPLIES, "->"))) return t;
+		if (null != (t = trySimpleToken(Token.PERIOD, "."))) return t;
+		if (null != (t = trySimpleToken(Token.FORALL, "forall"))) return t;
+		if (null != (t = trySimpleToken(Token.EXISTS, "exists"))) return t;
+		if (null != (t = trySimpleToken(Token.REACH, "reach"))) return t;
+		if (null != (t = trySimpleToken(Token.INSTANCEOF, "instanceof"))) return t;
+		if (null != (t = trySimpleToken(Token.OPAREN, "("))) return t;
+		if (null != (t = trySimpleToken(Token.CPAREN, ")"))) return t;
+		if (null != (t = trySimpleToken(Token.OBRACKET, "["))) return t;
+		if (null != (t = trySimpleToken(Token.CBRACKET, "]"))) return t;
+		if (null != (t = trySimpleToken(Token.OBRACE, "{"))) return t;
+		if (null != (t = trySimpleToken(Token.CBRACE, "}"))) return t;
+		if (null != (t = trySimpleToken(Token.COMMA, ","))) return t;
+		if (null != (t = trySimpleToken(Token.NULL, "null"))) return t;
+		if (null != (t = trySimpleToken(Token.EQ, "=="))) return t;
+		if (null != (t = trySimpleToken(Token.NE, "!="))) return t;
+		if (null != (t = trySimpleToken(Token.LE, "<="))) return t;
+		if (null != (t = trySimpleToken(Token.GE, ">="))) return t;
+		if (null != (t = trySimpleToken(Token.LT, "<"))) return t;
+		if (null != (t = trySimpleToken(Token.GT, ">"))) return t;
+		if (null != (t = trySimpleToken(Token.TRUE, "true"))) return t;
+		if (null != (t = trySimpleToken(Token.FALSE, "false"))) return t;
+		if (null != (t = trySimpleToken(Token.NOT, "!"))) return t;
+		if (null != (t = trySimpleToken(Token.COLON, ":"))) return t;
+		if (null != (t = trySimpleToken(Token.SLASH, "/"))) return t;
+		if (null != (t = tryID())) return t;
+		if (null != (t = tryInt())) return t;
+
+		System.err.println("Failed to process: `" + (new String(this.input, this.relative_offset, 30 + this.relative_offset > this.input.length ? this.input.length - this.relative_offset : 30)) + "'");
+		throw new RuntimeException("GCAssertions: Tokeniser failed");
+	}
+}
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/Token.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/Token.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/gca/Token.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/gca/Token.java	2010-03-16 21:55:57.000000000 +0000
@@ -0,0 +1,67 @@
+package org.eclipse.jdt.internal.compiler.gca;
+
+import org.eclipse.jdt.internal.compiler.ast.OperatorIds;
+
+public class Token
+{
+	public static final int ID		= 1000;
+	public static final int INT		= 1001;
+	public static final int OR		= 1002;
+	public static final int AND		= 1003;
+	public static final int IMPLIES		= 1004;
+	public static final int NOT		= 1005;
+	public static final int PERIOD		= 1006;
+	public static final int FORALL		= 1007;
+	public static final int EXISTS		= 1008;
+	public static final int REACH		= 1009;
+	public static final int OPAREN		= 1010;
+	public static final int CPAREN		= 1011;
+	public static final int OBRACKET	= 1012;
+	public static final int CBRACKET	= 1013;
+	public static final int OBRACE		= 1014;
+	public static final int CBRACE		= 1015;
+	public static final int COMMA		= 1016;
+	public static final int NULL		= 1017;
+	public static final int EQ		= OperatorIds.EQUAL_EQUAL;
+	public static final int NE		= OperatorIds.NOT_EQUAL;
+	public static final int LT		= OperatorIds.LESS;
+	public static final int GT		= OperatorIds.GREATER;
+	public static final int LE		= OperatorIds.LESS_EQUAL;
+	public static final int GE		= OperatorIds.GREATER_EQUAL;
+	public static final int TRUE		= 1024;
+	public static final int FALSE		= 1025;
+	public static final int COLON		= 1026;
+	public static final int INSTANCEOF	= OperatorIds.INSTANCEOF;
+	public static final int SLASH		= 1028;
+	public static final int IFF		= 1029;
+
+
+	public int kind;
+	public int start, end;
+	public String description;
+
+	public Token(final int _kind, final String _description, final int _start, final int _end)
+	{
+		this.kind = _kind;
+		this.description = _description;
+		this.start = _start;
+		this.end = _end;
+	}
+
+	public String
+	toString()
+	{
+		return this.description;
+	}
+
+	public static class IntToken extends Token
+	{
+		public int value;
+
+		public IntToken(final int _value, final int _start, final int _end)
+		{
+			super(INT, "" + _value, _start, _end);
+			this.value = _value;
+		}
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java	2009-09-28 17:28:40.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/lookup/BinaryTypeBinding.java	2010-02-20 02:45:08.000000000 +0000
@@ -325,6 +325,21 @@
 		if (needFieldsAndMethods) {
 			createFields(binaryType.getFields(), sourceLevel, missingTypeNames);
 			createMethods(binaryType.getMethods(), sourceLevel, missingTypeNames);
+			boolean isViewedAsDeprecated = isViewedAsDeprecated();
+			if (isViewedAsDeprecated) {
+				for (int i = 0, max = this.fields.length; i < max; i++) {
+					FieldBinding field = this.fields[i];
+					if (!field.isDeprecated()) {
+						field.modifiers |= ExtraCompilerModifiers.AccDeprecatedImplicitly;
+					}
+				}
+				for (int i = 0, max = this.methods.length; i < max; i++) {
+					MethodBinding method = this.methods[i];
+					if (!method.isDeprecated()) {
+						method.modifiers |= ExtraCompilerModifiers.AccDeprecatedImplicitly;
+					}
+				}
+			}
 		}
 		if (this.environment.globalOptions.storeAnnotations)
 			setAnnotations(createAnnotations(binaryType.getAnnotations(), this.environment, missingTypeNames));
@@ -344,7 +359,6 @@
 		if (size > 0) {
 			this.fields = new FieldBinding[size];
 			boolean use15specifics = sourceLevel >= ClassFileConstants.JDK1_5;
-			boolean isViewedAsDeprecated = isViewedAsDeprecated();
 			boolean hasRestrictedAccess = hasRestrictedAccess();
 			int firstAnnotatedFieldIndex = -1;
 			for (int i = 0; i < size; i++) {
@@ -368,8 +382,6 @@
 				field.id = i; // ordinal
 				if (use15specifics)
 					field.tagBits |= binaryField.getTagBits();
-				if (isViewedAsDeprecated && !field.isDeprecated())
-					field.modifiers |= ExtraCompilerModifiers.AccDeprecatedImplicitly;
 				if (hasRestrictedAccess)
 					field.modifiers |= ExtraCompilerModifiers.AccRestrictedAccess;
 				if (fieldSignature != null)
@@ -569,14 +581,11 @@
 		return;
 	}
 
-	boolean isViewedAsDeprecated = isViewedAsDeprecated();
 	boolean hasRestrictedAccess = hasRestrictedAccess();
 	this.methods = new MethodBinding[total];
 	if (total == initialTotal) {
 		for (int i = 0; i < initialTotal; i++) {
 			MethodBinding method = createMethod(iMethods[i], sourceLevel, missingTypeNames);
-			if (isViewedAsDeprecated && !method.isDeprecated())
-				method.modifiers |= ExtraCompilerModifiers.AccDeprecatedImplicitly;
 			if (hasRestrictedAccess)
 				method.modifiers |= ExtraCompilerModifiers.AccRestrictedAccess;
 			this.methods[i] = method;
@@ -585,8 +594,6 @@
 		for (int i = 0, index = 0; i < initialTotal; i++) {
 			if (iClinit != i && (toSkip == null || toSkip[i] != -1)) {
 				MethodBinding method = createMethod(iMethods[i], sourceLevel, missingTypeNames);
-				if (isViewedAsDeprecated && !method.isDeprecated())
-					method.modifiers |= ExtraCompilerModifiers.AccDeprecatedImplicitly;
 				if (hasRestrictedAccess)
 					method.modifiers |= ExtraCompilerModifiers.AccRestrictedAccess;
 				this.methods[index++] = method;
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java	2009-03-18 00:18:35.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/lookup/LocalVariableBinding.java	2010-03-03 17:45:15.000000000 +0000
@@ -22,6 +22,7 @@
 public class LocalVariableBinding extends VariableBinding {
 
 	public int resolvedPosition; // for code generation (position in method context)
+	public boolean quantifier_binding = false; // variable in GCAssertion quantifier?
 
 	public static final int UNUSED = 0;
 	public static final int USED = 1;
@@ -243,4 +244,10 @@
 		}
 		return s;
 	}
+
+	public boolean
+	isQuantifierBinding()
+	{
+		return this.quantifier_binding;
+	}
 }
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java	2009-03-07 01:08:09.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java	2010-03-01 23:32:20.000000000 +0000
@@ -49,7 +49,7 @@
 	// inner-emulation
 	public SyntheticArgumentBinding[] extraSyntheticArguments;
 
-public MethodScope(ClassScope parent, ReferenceContext context, boolean isStatic) {
+public MethodScope(Scope parent, ReferenceContext context, boolean isStatic) {
 	super(METHOD_SCOPE, parent);
 	this.locals = new LocalVariableBinding[5];
 	this.referenceContext = context;
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/lookup/Scope.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/lookup/Scope.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/lookup/Scope.java	2009-09-28 17:28:40.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/lookup/Scope.java	2010-02-20 02:45:08.000000000 +0000
@@ -3593,12 +3593,21 @@
 	}
 
 	// caveat: this is not a direct implementation of JLS
-	protected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType) {
+	protected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, final InvocationSite invocationSite, ReferenceBinding receiverType) {
 		int[] compatibilityLevels = new int[visibleSize];
 		for (int i = 0; i < visibleSize; i++)
 			compatibilityLevels[i] = parameterCompatibilityLevel(visible[i], argumentTypes);
 
-		boolean useTiebreakMethod = invocationSite.genericTypeArguments() == null;
+		InvocationSite tieBreakInvocationSite = new InvocationSite() {
+			public TypeBinding[] genericTypeArguments() { return null; } // ignore genericTypeArgs
+			public boolean isSuperAccess() { return invocationSite.isSuperAccess(); }
+			public boolean isTypeAccess() { return invocationSite.isTypeAccess(); }
+			public void setActualReceiverType(ReferenceBinding actualReceiverType) { /* ignore */}
+			public void setDepth(int depth) { /* ignore */}
+			public void setFieldIndex(int depth) { /* ignore */}
+			public int sourceStart() { return invocationSite.sourceStart(); }
+			public int sourceEnd() { return invocationSite.sourceStart(); }
+		};
 		MethodBinding[] moreSpecific = new MethodBinding[visibleSize];
 		int count = 0;
 		for (int level = 0, max = VARARGS_COMPATIBLE; level <= max; level++) {
@@ -3607,7 +3616,7 @@
 				max = level; // do not examine further categories, will either return mostSpecific or report ambiguous case
 				MethodBinding current = visible[i];
 				MethodBinding original = current.original();
-				MethodBinding tiebreakMethod = useTiebreakMethod ? current.tiebreakMethod() : current;
+				MethodBinding tiebreakMethod = current.tiebreakMethod();
 				for (int j = 0; j < visibleSize; j++) {
 					if (i == j || compatibilityLevels[j] != level) continue;
 					MethodBinding next = visible[j];
@@ -3626,7 +3635,7 @@
 							methodToTest = pNext.originalMethod;
 						}
 					}
-					MethodBinding acceptable = computeCompatibleMethod(methodToTest, tiebreakMethod.parameters, invocationSite);
+					MethodBinding acceptable = computeCompatibleMethod(methodToTest, tiebreakMethod.parameters, tieBreakInvocationSite);
 					/* There are 4 choices to consider with current & next :
 					 foo(B) & foo(A) where B extends A
 					 1. the 2 methods are equal (both accept each others parameters) -> want to continue
diff -ruN ecj-3.5.1/org/eclipse/jdt/internal/compiler/parser/Parser.java ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/parser/Parser.java
--- ecj-3.5.1/org/eclipse/jdt/internal/compiler/parser/Parser.java	2009-09-28 17:28:40.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/eclipse/jdt/internal/compiler/parser/Parser.java	2010-03-03 17:12:09.000000000 +0000
@@ -4617,6 +4617,51 @@
 		m.receiver = getUnspecifiedReference();
 		m.sourceStart = m.receiver.sourceStart;
 	}
+
+	// The following is a bit lame, but since the ecj guys put so much effort into making this fast, let's humour them.
+	if (m.selector.length >= 6
+	    && m.selector[0] == 'a'
+	    && m.selector[1] == 's'
+	    && m.selector[2] == 's'
+	    && m.arguments.length == 1
+	    && m.arguments[0] instanceof StringLiteral
+	    && m.receiver instanceof SingleNameReference) {
+		    final SingleNameReference receiver = (SingleNameReference) m.receiver;
+
+		    if (receiver.token.length == 8
+			&& receiver.token[0] == 'G'
+			&& receiver.token[1] == 'C'
+			&& receiver.token[2] == 'A'
+			&& receiver.token[3] == 's'
+			&& receiver.token[4] == 's'
+			&& receiver.token[5] == 'e'
+			&& receiver.token[6] == 'r'
+			&& receiver.token[7] == 't') {
+			    int assert_kind = 0;
+
+			    final String selector_name = new String(m.selector);
+			    if (selector_name.equals("assert"))
+				    assert_kind = Assertion.ASSERT;
+			    else if (selector_name.equals("assertion"))
+				    assert_kind = Assertion.ASSERT;
+			    else if (selector_name.equals("assertDisjoint"))
+				    assert_kind = Assertion.ASSERT_DISJOINT;
+			    else if (selector_name.equals("assumeDisjoint"))
+				    assert_kind = Assertion.ASSUME_DISJOINT;
+			    else if (selector_name.equals("assertDebug"))
+				    assert_kind = Assertion.ASSERT_DEBUG;
+
+			    if (assert_kind > 0) {
+				    final StringLiteral sl = (StringLiteral)m.arguments[0];
+				    final String assertion = new String(sl.source());
+
+				    org.eclipse.jdt.internal.compiler.gca.Debug.println("hook", "ASSERTION " + selector_name + " (" + assertion + ")");
+				    pushOnExpressionStack(org.eclipse.jdt.internal.compiler.gca.Parser.parse(sl.sourceStart + 1, sl.sourceEnd - 1, assertion, assert_kind, problemReporter()));
+				    return;
+			    }
+		    }
+	}
+
 	pushOnExpressionStack(m);
 }
 protected void consumeMethodInvocationNameWithTypeArguments() {
@@ -7358,11 +7403,11 @@
 	switch (type) {
 		case TokenNameIdentifier :
 			pushIdentifier();
-			if (this.scanner.useAssertAsAnIndentifier  &&
-					this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
-				long positions = this.identifierPositionStack[this.identifierPtr];
-				if(!this.statementRecoveryActivated) problemReporter().useAssertAsAnIdentifier((int) (positions >>> 32), (int) positions);
-			}
+// 			if (this.scanner.useAssertAsAnIndentifier  &&
+// 					this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
+// 				long positions = this.identifierPositionStack[this.identifierPtr];
+// 				if(!this.statementRecoveryActivated) problemReporter().useAssertAsAnIdentifier((int) (positions >>> 32), (int) positions);
+// 			}
 			if (this.scanner.useEnumAsAnIndentifier  &&
 					this.lastErrorEndPositionBeforeRecovery < this.scanner.currentPosition) {
 				long positions = this.identifierPositionStack[this.identifierPtr];
diff -ruN ecj-3.5.1/org/mmtk/plan/marksweep/gcassertions/spec/Assertion.java ecj-3.5.1-gcassertions/org/mmtk/plan/marksweep/gcassertions/spec/Assertion.java
--- ecj-3.5.1/org/mmtk/plan/marksweep/gcassertions/spec/Assertion.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/mmtk/plan/marksweep/gcassertions/spec/Assertion.java	2010-03-22 13:55:06.000000000 +0000
@@ -0,0 +1,53 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+/**
+ * Base assertion class.  Acts as a container for `steps' and analyses
+ * them
+ *
+ */
+public final class Assertion {
+
+  /**
+   * Constructs a new assertion.
+   *
+   * @param _steps The steps to execute, in order.  The first and the last three slots must be null.
+   * @param _checks The check pairs (compiled predicate halves) to include
+   */
+  public Assertion(final PredicateFamily[] _checks,
+		   final Step[] _steps)
+  {
+  }
+
+  /**
+   * Run an assertion
+   *
+   * This executes the garbage collection part of an assertion, assigning valuations to
+   * PredicateFamily objects and the traversal ID.
+   *
+   * @param _assertion The assertion to test
+   * @return whether or not the assertion was indeed tested
+   */
+  public static final boolean
+  doAssert(final Assertion _assertion)
+  {
+    return true;
+  }
+
+  public static final void
+  checkAssert(boolean b, boolean c)
+  {
+  }
+
+}
diff -ruN ecj-3.5.1/org/mmtk/plan/marksweep/gcassertions/spec/ExcludeNodesStep.java ecj-3.5.1-gcassertions/org/mmtk/plan/marksweep/gcassertions/spec/ExcludeNodesStep.java
--- ecj-3.5.1/org/mmtk/plan/marksweep/gcassertions/spec/ExcludeNodesStep.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/mmtk/plan/marksweep/gcassertions/spec/ExcludeNodesStep.java	2010-03-03 16:31:58.000000000 +0000
@@ -0,0 +1,24 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+/**
+ * Assertion step.  One part of assertion execution.
+ *
+ */
+public final class ExcludeNodesStep extends Step {
+  public ExcludeNodesStep(final Object[] _nodes)
+  {
+  }
+}
+
diff -ruN ecj-3.5.1/org/mmtk/plan/marksweep/gcassertions/spec/IncludeNodesStep.java ecj-3.5.1-gcassertions/org/mmtk/plan/marksweep/gcassertions/spec/IncludeNodesStep.java
--- ecj-3.5.1/org/mmtk/plan/marksweep/gcassertions/spec/IncludeNodesStep.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/mmtk/plan/marksweep/gcassertions/spec/IncludeNodesStep.java	2010-03-03 16:32:10.000000000 +0000
@@ -0,0 +1,24 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+/**
+ * Assertion step.  One part of assertion execution.
+ *
+ */
+public final class IncludeNodesStep extends Step {
+  public IncludeNodesStep(final Object[] _nodes)
+  {
+  }
+}
+
diff -ruN ecj-3.5.1/org/mmtk/plan/marksweep/gcassertions/spec/PredicateFamily.java ecj-3.5.1-gcassertions/org/mmtk/plan/marksweep/gcassertions/spec/PredicateFamily.java
--- ecj-3.5.1/org/mmtk/plan/marksweep/gcassertions/spec/PredicateFamily.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/mmtk/plan/marksweep/gcassertions/spec/PredicateFamily.java	2010-03-03 16:44:50.000000000 +0000
@@ -0,0 +1,34 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+/**
+ * A single predicate, specialised to different cases
+ *
+ */
+public final class PredicateFamily
+{
+  public PredicateFamily(final Class c,
+			 final int[] _method_indices,
+			 final Object[] _environment,
+			 final boolean _existential)
+  {
+  }
+
+  public final boolean
+  value()
+  {
+    return true;
+  }
+}
+
diff -ruN ecj-3.5.1/org/mmtk/plan/marksweep/gcassertions/spec/SetTraversalIdStep.java ecj-3.5.1-gcassertions/org/mmtk/plan/marksweep/gcassertions/spec/SetTraversalIdStep.java
--- ecj-3.5.1/org/mmtk/plan/marksweep/gcassertions/spec/SetTraversalIdStep.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/mmtk/plan/marksweep/gcassertions/spec/SetTraversalIdStep.java	2010-03-03 16:45:03.000000000 +0000
@@ -0,0 +1,25 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+/**
+ * Assertion step.  One part of assertion execution.
+ *
+ */
+public final class SetTraversalIdStep extends Step
+{
+  public SetTraversalIdStep(final int _traversal_id)
+  {
+  }
+}
+
diff -ruN ecj-3.5.1/org/mmtk/plan/marksweep/gcassertions/spec/SetTraversalPredicatesStep.java ecj-3.5.1-gcassertions/org/mmtk/plan/marksweep/gcassertions/spec/SetTraversalPredicatesStep.java
--- ecj-3.5.1/org/mmtk/plan/marksweep/gcassertions/spec/SetTraversalPredicatesStep.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/mmtk/plan/marksweep/gcassertions/spec/SetTraversalPredicatesStep.java	2010-03-03 16:45:18.000000000 +0000
@@ -0,0 +1,27 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+/**
+ * Assertion step.  One part of assertion execution.
+ *
+ * Selects a check pair to be installed for the next traversal, and indicates
+ * whether the check pair should use its external or its internal component.
+ */
+public final class SetTraversalPredicatesStep extends Step {
+  public
+  SetTraversalPredicatesStep(final int[] indices)
+  {
+  }
+}
+
diff -ruN ecj-3.5.1/org/mmtk/plan/marksweep/gcassertions/spec/Step.java ecj-3.5.1-gcassertions/org/mmtk/plan/marksweep/gcassertions/spec/Step.java
--- ecj-3.5.1/org/mmtk/plan/marksweep/gcassertions/spec/Step.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/mmtk/plan/marksweep/gcassertions/spec/Step.java	2010-03-03 16:30:10.000000000 +0000
@@ -0,0 +1,21 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+/**
+ * Assertion step.  One part of assertion execution.
+ *
+ */
+public abstract class Step {
+}
+
diff -ruN ecj-3.5.1/org/mmtk/plan/marksweep/gcassertions/spec/TraversalStep.java ecj-3.5.1-gcassertions/org/mmtk/plan/marksweep/gcassertions/spec/TraversalStep.java
--- ecj-3.5.1/org/mmtk/plan/marksweep/gcassertions/spec/TraversalStep.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/org/mmtk/plan/marksweep/gcassertions/spec/TraversalStep.java	2010-03-03 16:44:59.000000000 +0000
@@ -0,0 +1,29 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+/**
+ * Assertion step.  One part of assertion execution.
+ *
+ * Traversal enqueues the specified node(s) and initiates recursive sweeps.
+ */
+public final class TraversalStep extends Step {
+  public TraversalStep(final Object[] _nodes)
+  {
+  }
+
+  public TraversalStep()
+  {
+  }
+}
+
diff -ruN ecj-3.5.1/sed ecj-3.5.1-gcassertions/sed
--- ecj-3.5.1/sed	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/sed	2010-03-19 13:11:26.000000000 +0000
@@ -0,0 +1 @@
+make: *** No rule to make target `s/Collection/\nCollection/'.  Stop.
diff -ruN ecj-3.5.1/test/ASTOpPrecedence.expect ecj-3.5.1-gcassertions/test/ASTOpPrecedence.expect
--- ecj-3.5.1/test/ASTOpPrecedence.expect	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/ASTOpPrecedence.expect	2010-03-18 16:57:44.000000000 +0000
@@ -0,0 +1,4 @@
+(((1) == (2)) && ((3) != (4))) && (true)
+(((((1) <= (2)) == ((3.2) >= (4.1))) == (true)) == ((0) > (1))) == ((2) < (5))
+((true) || ((false) && (true))) || (false)
+((1) == (2)) == ((3) == (4))
diff -ruN ecj-3.5.1/test/ASTOpPrecedence.java ecj-3.5.1-gcassertions/test/ASTOpPrecedence.java
--- ecj-3.5.1/test/ASTOpPrecedence.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/ASTOpPrecedence.java	2010-03-18 16:57:34.000000000 +0000
@@ -0,0 +1,14 @@
+package test;
+
+public class ASTOpPrecedence
+{
+	public static void foo()
+	{
+		Object r;
+
+		GCAssert.assert(" 1 == 2 && 3 != 4 && true");
+		GCAssert.assert(" 1 <= 2 == 3.2 >= 4.1 == true == 0 > 1 == 2 < 5");
+		GCAssert.assert(" true || false && true || false ");
+		GCAssert.assert(" 1 == 2 <-> 3 == 4 ");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/DLL.java ecj-3.5.1-gcassertions/test/DLL.java
--- ecj-3.5.1/test/DLL.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/DLL.java	2010-03-21 22:08:27.000000000 +0000
@@ -0,0 +1,112 @@
+package test;
+/**
+ * A DeAL example that checks well formedness of doubly-linked lists
+ */
+
+public class DLL {
+
+  private LLNode head = null;
+  private LLNode tail = null;
+
+  /** 
+   * Creates a doubly linked list of the specified length
+   */
+  public DLL(int numNodes) {
+    for (int i=0; i<numNodes; i++) {
+      add(null);
+    }
+    //assert(repOK());
+  }
+
+  /**
+   * Adds an element to the end of the linked list
+   */
+  public void add(Object element) {
+    //assert(repOK());
+    if (head == null && tail == null) {
+      head = new LLNode(null, null, element);
+      tail = head;
+    } else {
+      LLNode temp = tail;
+      tail = new LLNode(temp, null, element);
+      temp.next = tail;
+    }
+    //assert(repOK());
+  }
+
+  /**
+   * Incorrectly adds an element to the end of the linked lists.  Fails to 
+   * set the next pointer for the current tail element.
+   */
+  public void addMalformed(Object element) {
+    if (head == null && tail == null) {
+      head = new LLNode(null, null, element);
+      tail = head;
+    } else {
+      LLNode temp = tail;
+      tail = new LLNode(temp, null, element);
+    }
+    //assert(repOK());    // should fail
+  }
+
+  /**
+   * Checks well-formedness of data structure
+   */
+  public boolean repOK() {
+    // head and tail must either both be null or both non-null
+    if (!((head == null && tail == null) || (head != null && tail != null)))
+      return false;
+
+    // head.prev == null, tail.next == null
+    if (!((head.prev == null) || (tail.next == null))) 
+      return false;
+
+    // forall LLNodes, starting from head, node.next.prev == node &&
+    // node.prev.next == node
+    LLNode curr = head;
+    while (curr != null) {
+      if (curr.next != null) 
+        if (!(curr.next.prev == curr)) 
+          return false;
+
+      if (curr.prev != null)
+        if (!(curr.prev.next == curr))
+          return false;
+
+      curr = curr.next;
+    }
+
+    // forall LLNodes, starting from tail node.prev.next == node &&
+    // node.prev.next == node
+    curr = tail;
+    while (curr != null) {
+      if (curr.next != null) 
+        if (!(curr.next.prev == curr)) 
+          return false;
+
+      if (curr.prev != null)
+        if (!(curr.prev.next == curr))
+          return false;
+
+      curr = curr.prev;
+    }
+
+    return true;
+  }
+
+  public static void main(String[] args) {
+    if (args.length != 1) {
+      System.out.println("Usage: java DLL <numNodes>");
+      System.exit(1);
+    }
+
+    DLL list = new DLL(Integer.parseInt(args[0]));
+    list.addMalformed(null);
+
+    //GCAssert.assertion("(forall LLNode x : ((reach[list](x)) -> x.next.prev == x))");
+    GCAssert.assertion("forall LLNode x : x.next.prev == x");
+    //GCAssert.assertion("forall LLNode x : x.payload == null");
+    //GCAssert.assertion("!(forall LLNode x : x.next.prev == null)");
+  }
+
+}
diff -ruN ecj-3.5.1/test/HTIT0.java ecj-3.5.1-gcassertions/test/HTIT0.java
--- ecj-3.5.1/test/HTIT0.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/HTIT0.java	2010-03-09 21:35:36.000000000 +0000
@@ -0,0 +1,16 @@
+package test;
+
+// heap traversal integration test
+public class HTIT0
+{
+	public static final void
+	main(String[] args)
+	{
+		Node a = new Node();
+		Node b = new Node(0, a);
+		Node c = new Node(0, b);
+
+		GCAssert.assertion("forall Object n : reach[c](n) -> n instanceof Node");
+		System.out.println("all-clear");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/HTIT1.java ecj-3.5.1-gcassertions/test/HTIT1.java
--- ecj-3.5.1/test/HTIT1.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/HTIT1.java	2010-03-09 21:35:36.000000000 +0000
@@ -0,0 +1,15 @@
+package test;
+
+public class HTIT1
+{
+	public static final void
+	main(String[] args)
+	{
+		Node a = new Node(1, null);
+		Node b = new Node(0, a);
+		Node c = new Node(0, b);
+
+		GCAssert.assertion("forall Node n : reach[c](n) -> n.v == 0");
+		System.out.println("all-clear");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/HTIT2.java ecj-3.5.1-gcassertions/test/HTIT2.java
--- ecj-3.5.1/test/HTIT2.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/HTIT2.java	2010-03-09 21:35:36.000000000 +0000
@@ -0,0 +1,17 @@
+package test;
+
+// heap traversal integration test
+public class HTIT2
+{
+	public static final void
+	main(String[] args)
+	{
+		Node a = new Node(1, null);
+		Node b = new Node(0, a);
+		Node c = new Node(0, b);
+
+		GCAssert.assertion("exists Node n : reach[c](n) -> n.v == 1");
+		GCAssert.assertion("exists Node n : reach[c](n) -> n.v == 0");
+		System.out.println("all-clear");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/HTIT3.java ecj-3.5.1-gcassertions/test/HTIT3.java
--- ecj-3.5.1/test/HTIT3.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/HTIT3.java	2010-03-09 21:35:36.000000000 +0000
@@ -0,0 +1,18 @@
+package test;
+
+// heap traversal integration test
+public class HTIT3
+{
+	public static final void
+	main(String[] args)
+	{
+		int i = 0;
+		Node a = new Node(0, null);
+		Node b = new Node(0, a);
+		Node c = new Node(0, b);
+		Node d = new Node(2, null);
+
+		GCAssert.assertion("(exists Node n : reach[c](n) -> n.v == i) && (forall Node n: n.v == 2 -> n == d ) ");
+		System.out.println("all-clear");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/HTIT4.java ecj-3.5.1-gcassertions/test/HTIT4.java
--- ecj-3.5.1/test/HTIT4.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/HTIT4.java	2010-03-09 21:35:36.000000000 +0000
@@ -0,0 +1,19 @@
+package test;
+
+// heap traversal integration test
+public class HTIT4
+{
+	public static final void
+	main(String[] args)
+	{
+		int i = 0;
+		Node a = new Node(0, null);
+		Node b = new Node(0, a);
+		Node c = new Node(0, b);
+		Node d = new Node(0, a);
+		Node e = new Node(0, d);
+
+		GCAssert.assertDisjoint("(forall Node n : (reach[c](n) || reach[e](n)) -> n.v == 0)");
+		System.out.println("all-clear");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/HTIT5.java ecj-3.5.1-gcassertions/test/HTIT5.java
--- ecj-3.5.1/test/HTIT5.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/HTIT5.java	2010-03-09 21:35:36.000000000 +0000
@@ -0,0 +1,19 @@
+package test;
+
+// heap traversal integration test
+public class HTIT5
+{
+	public static final void
+	main(String[] args)
+	{
+		int i = 0;
+		Node a = new Node(0, null);
+		Node b = new Node(0, a);
+		Node c = new Node(0, b);
+		Node d = new Node(0, null);
+		Node e = new Node(0, d);
+
+		GCAssert.assumeDisjoint("(forall Node n : (reach[c](n) || reach[e](n)) -> n.v == 0)");
+		System.out.println("all-clear");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/HTIT6.java ecj-3.5.1-gcassertions/test/HTIT6.java
--- ecj-3.5.1/test/HTIT6.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/HTIT6.java	2010-03-09 21:35:36.000000000 +0000
@@ -0,0 +1,19 @@
+package test;
+
+// heap traversal integration test
+public class HTIT6
+{
+	public static final void
+	main(String[] args)
+	{
+		int i = 0;
+		Node a = new Node(1, null);
+		Node b = new Node(0, a);
+		Node c = new Node(0, b);
+		Node d = new Node(1, a);
+		Node e = new Node(1, d);
+
+		GCAssert.assertion("(forall Node n : ((!reach[/c](n)) -> n.v == 0))");
+		System.out.println("all-clear");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/HTIT7.java ecj-3.5.1-gcassertions/test/HTIT7.java
--- ecj-3.5.1/test/HTIT7.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/HTIT7.java	2010-03-19 14:04:02.000000000 +0000
@@ -0,0 +1,32 @@
+package test;
+
+// heap traversal integration test
+public class HTIT7
+{
+	static int i = 0;
+	static Node a = new Node(1, null);
+	static Node b = new Node(0, a);
+	static Node c = new Node(0, b);
+	static Node d = new Node(1, a);
+	static Node e = new Node(1, d);
+
+	static void t()
+	{
+
+
+		GCAssert.assertion("(forall Node n : ((!reach[/c](n)) -> n.v == 0))");
+	}
+
+	public static final void
+	main(String[] args)
+	{
+		for (int k = 0; k < 100; k++) {
+			t();
+			Object o;
+			for (int j = 0; j < 900; j++)
+				o = new char[1000];
+			o = null;
+		}
+		System.out.println("all-clear");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/HTIT8.java ecj-3.5.1-gcassertions/test/HTIT8.java
--- ecj-3.5.1/test/HTIT8.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/HTIT8.java	2010-03-23 11:45:58.000000000 +0000
@@ -0,0 +1,24 @@
+package test;
+
+import java.util.ArrayList;
+
+// heap traversal integration test
+public class HTIT8
+{
+	public static final void
+	main(String[] args)
+	{
+		ArrayList<Node> a = new ArrayList<Node>();
+		ArrayList<Node> b = new ArrayList<Node>();
+
+
+		a.add(new Node(1, new Node(1, null)));
+		a.add(new Node(1, new Node(1, null)));
+		b.add(new Node(0, new Node(0, null)));
+		b.add(new Node(0, new Node(0, null)));
+
+		GCAssert.assertDisjoint("forall Node x : (reach[a](x) || reach[b](x)) && !(reach[/{a,b}](x))");
+
+		System.out.println("all-clear");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/HookPresentAssert.expect ecj-3.5.1-gcassertions/test/HookPresentAssert.expect
--- ecj-3.5.1/test/HookPresentAssert.expect	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/HookPresentAssert.expect	2010-03-09 21:35:36.000000000 +0000
@@ -0,0 +1 @@
+(forall n: (!reach[r](n)) || (!(n.v) == (42))) && (exists o: (o) instanceof Object)
diff -ruN ecj-3.5.1/test/HookPresentAssert.java ecj-3.5.1-gcassertions/test/HookPresentAssert.java
--- ecj-3.5.1/test/HookPresentAssert.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/HookPresentAssert.java	2010-03-09 21:35:36.000000000 +0000
@@ -0,0 +1,12 @@
+package test;
+
+public class HookPresentAssert
+{
+	public static void foo()
+	{
+		Object r;
+		Node kappa = new Node();
+
+		GCAssert.assert(" (forall Node n: reach[r](n) -> !(n.v == 42)) && (exists Object o: o instanceof Object)");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/HookPresentAssertDisjoint.java ecj-3.5.1-gcassertions/test/HookPresentAssertDisjoint.java
--- ecj-3.5.1/test/HookPresentAssertDisjoint.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/HookPresentAssertDisjoint.java	2010-03-09 21:35:36.000000000 +0000
@@ -0,0 +1,9 @@
+package test;
+
+public class HookPresentAssertDisjoint
+{
+	public static void foo()
+	{
+		GCAssert.assertDisjoint("true");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/HookPresentAssumeDisjoint.java ecj-3.5.1-gcassertions/test/HookPresentAssumeDisjoint.java
--- ecj-3.5.1/test/HookPresentAssumeDisjoint.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/HookPresentAssumeDisjoint.java	2010-03-09 21:35:36.000000000 +0000
@@ -0,0 +1,9 @@
+package test;
+
+public class HookPresentAssumeDisjoint
+{
+	public static void foo()
+	{
+		GCAssert.assumeDisjoint("true");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/LLNode.java ecj-3.5.1-gcassertions/test/LLNode.java
--- ecj-3.5.1/test/LLNode.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/LLNode.java	2010-03-21 22:09:01.000000000 +0000
@@ -0,0 +1,18 @@
+package test;
+
+/**
+ * Represents a linked list node
+ */
+public class LLNode {
+
+  public LLNode next;
+  public LLNode prev;
+  public Object payload;
+
+  public LLNode(LLNode prev, LLNode next, Object payload) {
+    this.prev = prev;
+    this.next = next;
+    this.payload = payload;
+  }
+
+}
diff -ruN ecj-3.5.1/test/MagicChecker.java ecj-3.5.1-gcassertions/test/MagicChecker.java
--- ecj-3.5.1/test/MagicChecker.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/MagicChecker.java	2010-03-18 22:31:21.000000000 +0000
@@ -0,0 +1,260 @@
+package test;
+
+public class MagicChecker extends TestHarness
+{
+	final static Object o = new Object();
+	final static Node n0 = new Node(0);
+	final static Node n1 = new Node(1);
+	final static Node n2n1 = new Node(2, n1);
+	final static Node n3n2n1 = new Node(3, n2n1);
+
+	public void
+	test00()
+	{
+		assertFalse(MagicTestLibrary.__magic_predicate$0000(o, null));
+		assertTrue(MagicTestLibrary.__magic_predicate$0000(n0, null));
+		assertFalse(MagicTestLibrary.__magic_predicate$0000(n1, null));
+	}
+
+	public void
+	test01()
+	{
+		assertFalse(MagicTestLibrary.__magic_predicate$0001(n0, new Object[]{ new Integer(1) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0001(n0, new Object[]{ new Integer(0) }));
+	}
+
+	public void
+	test02()
+	{
+		assertFalse(MagicTestLibrary.__magic_predicate$0002(n1, new Object[]{ n0, new Integer(0) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0002(n1, new Object[]{ n1, new Integer(1) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0002(n1, new Object[]{ n1, new Integer(0) }));
+	}
+
+	public void
+	test03()
+	{
+		assertFalse(MagicTestLibrary.__magic_predicate$0003(o, new Object[]{ new Boolean(true) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0003(o, new Object[]{ new Boolean(false) }));
+	}
+
+	// float vs. int
+	public void
+	test04()
+	{
+		assertFalse(MagicTestLibrary.__magic_predicate$0004(o, new Object[]{ new Float(1.0), new Integer(1) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0004(o, new Object[]{ new Float(1.0), new Integer(2) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0004(o, new Object[]{ new Float(1.1), new Integer(1) }));
+	}
+
+	public void
+	test05()
+	{
+		assertFalse(MagicTestLibrary.__magic_predicate$0005(o, new Object[]{ new Integer(1), new Float(1.0) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0005(o, new Object[]{ new Integer(1), new Float(1.1) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0005(o, new Object[]{ new Integer(2), new Float(1.9) }));
+	}
+
+	public void
+	test06()
+	{
+		assertFalse(MagicTestLibrary.__magic_predicate$0006(o, new Object[]{ new Float(1.0), new Integer(1) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0006(o, new Object[]{ new Float(1.0), new Integer(2) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0006(o, new Object[]{ new Float(1.1), new Integer(1) }));
+	}
+
+	public void
+	test07()
+	{
+		assertFalse(MagicTestLibrary.__magic_predicate$0007(o, new Object[]{ new Integer(1), new Float(1.0) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0007(o, new Object[]{ new Integer(1), new Float(1.1) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0007(o, new Object[]{ new Integer(2), new Float(1.9) }));
+	}
+
+	// double vs. int
+	public void
+	test08()
+	{
+		assertFalse(MagicTestLibrary.__magic_predicate$0008(o, new Object[]{ new Double(1.0), new Integer(1) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0008(o, new Object[]{ new Double(1.0), new Integer(2) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0008(o, new Object[]{ new Double(1.1), new Integer(1) }));
+	}
+
+	public void
+	test09()
+	{
+		assertFalse(MagicTestLibrary.__magic_predicate$0009(o, new Object[]{ new Integer(1), new Double(1.0) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0009(o, new Object[]{ new Integer(1), new Double(1.1) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0009(o, new Object[]{ new Integer(2), new Double(1.9) }));
+	}
+
+	public void
+	test10()
+	{
+		assertFalse(MagicTestLibrary.__magic_predicate$0010(o, new Object[]{ new Double(1.0), new Integer(1) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0010(o, new Object[]{ new Double(1.0), new Integer(2) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0010(o, new Object[]{ new Double(1.1), new Integer(1) }));
+	}
+
+	public void
+	test11()
+	{
+		assertFalse(MagicTestLibrary.__magic_predicate$0011(o, new Object[]{ new Integer(1), new Double(1.0) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0011(o, new Object[]{ new Integer(1), new Double(1.1) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0011(o, new Object[]{ new Integer(2), new Double(1.9) }));
+	}
+
+	// --
+
+	public void
+	test12()
+	{
+		assertFalse(MagicTestLibrary.__magic_predicate$0012(o, new Object[]{ new Short((short)0), new Integer(1) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0012(o, new Object[]{ new Short((short)2), new Integer(2) }));
+	}
+
+	public void
+	test13()
+	{
+		assertFalse(MagicTestLibrary.__magic_predicate$0013(n3n2n1, new Object[]{ n2n1 }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0013(n3n2n1, new Object[]{ n1 }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0013(n1, new Object[]{ n1 }));
+	}
+
+
+	public void
+	test14()
+	{
+		assertTrue(MagicTestLibrary.__magic_predicate$0014(n3n2n1, new Object[]{ }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0014(n2n1, new Object[]{ }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0014(n1, new Object[]{ }));
+	}
+
+
+	public void
+	test15()
+	{
+		assertTrue(MagicTestLibrary.__magic_predicate$0015(n2n1, new Object[]{ n1 }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0015(n1, new Object[]{ n1 }));
+	}
+
+	public void
+	test16()
+	{
+		assertTrue(MagicTestLibrary.__magic_predicate$0016(n1, new Object[]{ n1, new Boolean(true) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0016(n1, new Object[]{ n1, new Boolean(false) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0016(n1, new Object[]{ n2n1, new Boolean(true) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0016(n1, new Object[]{ n2n1, new Boolean(false) }));
+	}
+
+	public void
+	test17()
+	{
+		assertTrue(MagicTestLibrary.__magic_predicate$0017(n1, new Object[]{ new Integer(1) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0017(n1, new Object[]{ new Integer(2) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0017(n1, new Object[]{ new Integer(0) }));
+	}
+
+
+	public void
+	test18()
+	{
+		assertFalse(MagicTestLibrary.__magic_predicate$0018(n1, new Object[]{ new Integer(1) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0018(n1, new Object[]{ new Integer(2) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0018(n1, new Object[]{ new Integer(0) }));
+	}
+
+
+	// ||
+	public void
+	test19()
+	{
+		assertTrue(MagicTestLibrary.__magic_predicate$0019(n1, new Object[]{ new Integer(1), new Boolean(true) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0019(n1, new Object[]{ new Integer(1), new Boolean(false) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0019(n1, new Object[]{ new Integer(2), new Boolean(true) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0019(n1, new Object[]{ new Integer(2), new Boolean(false) }));
+	}
+
+	public void
+	test20()
+	{
+		assertTrue(MagicTestLibrary.__magic_predicate$0020(n1, new Object[]{ new Boolean(true), new Integer(1) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0020(n1, new Object[]{ new Boolean(false), new Integer(1) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0020(n1, new Object[]{ new Boolean(true), new Integer(2) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0020(n1, new Object[]{ new Boolean(false), new Integer(2) }));
+	}
+
+	// &&
+	public void
+	test21()
+	{
+		assertTrue(MagicTestLibrary.__magic_predicate$0021(n1, new Object[]{ new Integer(1), new Boolean(true) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0021(n1, new Object[]{ new Integer(1), new Boolean(false) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0021(n1, new Object[]{ new Integer(2), new Boolean(true) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0021(n1, new Object[]{ new Integer(2), new Boolean(false) }));
+	}
+
+	public void
+	test22()
+	{
+		assertTrue(MagicTestLibrary.__magic_predicate$0022(n1, new Object[]{ new Boolean(true), new Integer(1) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0022(n1, new Object[]{ new Boolean(false), new Integer(1) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0022(n1, new Object[]{ new Boolean(true), new Integer(2) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0022(n1, new Object[]{ new Boolean(false), new Integer(2) }));
+	}
+
+
+	// ->
+	public void
+	test23()
+	{
+		assertTrue(MagicTestLibrary.__magic_predicate$0023(n1, new Object[]{ new Integer(1), new Boolean(true) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0023(n1, new Object[]{ new Integer(1), new Boolean(false) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0023(n1, new Object[]{ new Integer(2), new Boolean(true) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0023(n1, new Object[]{ new Integer(2), new Boolean(false) }));
+	}
+
+	public void
+	test24()
+	{
+		assertTrue(MagicTestLibrary.__magic_predicate$0024(n1, new Object[]{ new Boolean(true), new Integer(1) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0024(n1, new Object[]{ new Boolean(false), new Integer(1) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0024(n1, new Object[]{ new Boolean(true), new Integer(2) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0024(n1, new Object[]{ new Boolean(false), new Integer(2) }));
+	}
+
+	public void
+	test25()
+	{
+		assertTrue(MagicTestLibrary.__magic_predicate$0025(n0, new Object[]{ }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0025(n1, new Object[]{ }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0025(n2n1, new Object[]{ }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0025(n3n2n1, new Object[]{ }));
+	}
+
+	public void
+	test26()
+	{
+		Node n2 = n2n1;
+
+		assertTrue(MagicTestLibrary.__magic_predicate$0026(n0, new Object[]{ n1, new Boolean(true), new Integer(1), new Short((short)1) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0026(n0, new Object[]{ n1, new Boolean(true), new Integer(1), new Short((short)2) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0026(n0, new Object[]{ n1, new Boolean(false), new Integer(1), new Short((short)1) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0026(n0, new Object[]{ n1, new Boolean(false), new Integer(1), new Short((short)2) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0026(n0, new Object[]{ n0, new Boolean(true), new Integer(1), new Short((short)1) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0026(n0, new Object[]{ n0, new Boolean(true), new Integer(1), new Short((short)2) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0026(n0, new Object[]{ n0, new Boolean(false), new Integer(1), new Short((short)1) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0026(n0, new Object[]{ n0, new Boolean(false), new Integer(1), new Short((short)2) }));
+
+		assertFalse(MagicTestLibrary.__magic_predicate$0026(n2, new Object[]{ n1, new Boolean(true), new Integer(1), new Short((short)1) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0026(n2, new Object[]{ n1, new Boolean(true), new Integer(1), new Short((short)2) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0026(n2, new Object[]{ n1, new Boolean(false), new Integer(1), new Short((short)1) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0026(n2, new Object[]{ n1, new Boolean(false), new Integer(1), new Short((short)2) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0026(n2, new Object[]{ n2, new Boolean(true), new Integer(1), new Short((short)1) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0026(n2, new Object[]{ n2, new Boolean(true), new Integer(1), new Short((short)2) }));
+		assertTrue(MagicTestLibrary.__magic_predicate$0026(n2, new Object[]{ n2, new Boolean(false), new Integer(1), new Short((short)1) }));
+		assertFalse(MagicTestLibrary.__magic_predicate$0026(n2, new Object[]{ n2, new Boolean(false), new Integer(1), new Short((short)2) }));
+	}
+
+
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/MagicTestLibrary.java ecj-3.5.1-gcassertions/test/MagicTestLibrary.java
--- ecj-3.5.1/test/MagicTestLibrary.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/MagicTestLibrary.java	2010-03-09 21:35:36.000000000 +0000
@@ -0,0 +1,51 @@
+package test;
+
+public class MagicTestLibrary
+{
+	public static Node n;
+	public static Object o;
+	public static double d;
+	public static float f;
+	public static boolean b;
+	public static int i;
+	public static short s;
+
+	public static void foo()
+	{
+		GCAssert.assertDebug(" exists Node x : x.v == 0"); // 0000
+		GCAssert.assertDebug(" exists Node x : x.v == i"); // 0001
+		GCAssert.assertDebug(" exists Node x : (x == n) && (x.v > i)"); // 0002
+		GCAssert.assertDebug(" exists Object o : !b"); // 0003
+
+ 		GCAssert.assertDebug(" exists Object o : f > i"); // 0004
+ 		GCAssert.assertDebug(" exists Object o : i > f"); // 0005
+		GCAssert.assertDebug(" exists Object o : f < i"); // 0006
+		GCAssert.assertDebug(" exists Object o : i < f"); // 0007
+		GCAssert.assertDebug(" exists Object o : d > i"); // 0008
+		GCAssert.assertDebug(" exists Object o : i > d"); // 0009
+		GCAssert.assertDebug(" exists Object o : d < i"); // 0010
+		GCAssert.assertDebug(" exists Object o : i < d"); // 0011
+
+		GCAssert.assertDebug(" exists Object o : s == i"); // 0012
+
+		GCAssert.assertDebug(" exists Node n2 : n2.next.next == n"); // 0013
+		GCAssert.assertDebug(" exists Node n2 : n2.next.next.next == null"); // 0014
+
+		GCAssert.assertDebug(" exists Node n2 : n2 != n"); // 0015
+		GCAssert.assertDebug(" exists Node n2 : (n2 == n) == b"); // 0016
+		GCAssert.assertDebug(" exists Node n2 : i >= 1"); // 0017
+		GCAssert.assertDebug(" exists Node n2 : i < 1"); // 0018
+
+		GCAssert.assertDebug(" exists Node n : (n.v == i) || b"); // 0019
+		GCAssert.assertDebug(" exists Node n : b || (n.v == i)"); // 0020
+
+		GCAssert.assertDebug(" exists Node n : (n.v == i) && b"); // 0021
+		GCAssert.assertDebug(" exists Node n : b && (n.v == i)"); // 0022
+
+		GCAssert.assertDebug(" exists Node n : (n.v == i) -> b"); // 0023
+		GCAssert.assertDebug(" exists Node n : b -> (n.v == i)"); // 0024
+
+		GCAssert.assertDebug(" exists Node n2 : n2.v == 0 || n2.v == 1 || n2.v == 2"); // 0025
+		GCAssert.assertDebug(" exists Node n2 : ((n == n2) && (b != (i == s))) || n2.v == 0"); // 0026
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/Node.java ecj-3.5.1-gcassertions/test/Node.java
--- ecj-3.5.1/test/Node.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/Node.java	2010-03-22 21:46:31.000000000 +0000
@@ -0,0 +1,11 @@
+package test;
+
+public class Node
+{
+	public int v;
+	public Node next;
+
+	public Node() {}
+	public Node(int _v, Node _next) { this.v = _v; this.next = _next; }
+	public Node(int _v) { this.v = _v; }
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/ReachSort.expect ecj-3.5.1-gcassertions/test/ReachSort.expect
--- ecj-3.5.1/test/ReachSort.expect	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/ReachSort.expect	2010-03-09 21:35:36.000000000 +0000
@@ -0,0 +1,5 @@
+exists o: reach[a, b](o)
+exists o: reach[a, b](o)
+exists o: reach[a/c, b/{d, e}](o)
+exists o: reach[{a, b, c, d}](o)
+exists o: reach[/{a, c}](o)
diff -ruN ecj-3.5.1/test/ReachSort.java ecj-3.5.1-gcassertions/test/ReachSort.java
--- ecj-3.5.1/test/ReachSort.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/ReachSort.java	2010-03-09 21:35:36.000000000 +0000
@@ -0,0 +1,15 @@
+package test;
+
+public class ReachSort
+{
+	public static void foo()
+	{
+		Object a, b, c, d, e;
+
+		GCAssert.assert(" exists Object o: reach[a, b](o)");
+		GCAssert.assert(" exists Object o: reach[{a}, b](o)");
+		GCAssert.assert(" exists Object o: reach[a/{c}, b/{d, e}](o)");
+		GCAssert.assert(" exists Object o: reach[{c, a, d, b}](o)");
+		GCAssert.assert(" exists Object o: reach[/{c, a}](o)");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/SanityCheck0.java ecj-3.5.1-gcassertions/test/SanityCheck0.java
--- ecj-3.5.1/test/SanityCheck0.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/SanityCheck0.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,11 @@
+package test;
+
+public class SanityCheck0
+{
+	public static void foo()
+	{
+		Object r = new Object();
+
+		GCAssert.assert("reach[r](r)");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/SanityCheck1.java ecj-3.5.1-gcassertions/test/SanityCheck1.java
--- ecj-3.5.1/test/SanityCheck1.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/SanityCheck1.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,11 @@
+package test;
+
+public class SanityCheck1
+{
+	public static void foo()
+	{
+		Object r = new Object();
+
+		GCAssert.assert("forall Node x : reach[r](r)");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/SanityCheck2.java ecj-3.5.1-gcassertions/test/SanityCheck2.java
--- ecj-3.5.1/test/SanityCheck2.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/SanityCheck2.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,11 @@
+package test;
+
+public class SanityCheck2
+{
+	public static void foo()
+	{
+		Object r = new Object();
+
+		GCAssert.assert("forall Node x : reach[x](x)");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/SanityCheck3.java ecj-3.5.1-gcassertions/test/SanityCheck3.java
--- ecj-3.5.1/test/SanityCheck3.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/SanityCheck3.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,11 @@
+package test;
+
+public class SanityCheck3
+{
+	public static void foo()
+	{
+		Object r = new Object();
+
+		GCAssert.assert("forall Node x : reach[r](r)");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/SanityCheck4.java ecj-3.5.1-gcassertions/test/SanityCheck4.java
--- ecj-3.5.1/test/SanityCheck4.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/SanityCheck4.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,11 @@
+package test;
+
+public class SanityCheck3
+{
+	public static void foo()
+	{
+		Object r = new Object();
+
+		GCAssert.assert("forall Node x : (forall Object y : reach[r](x))");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/SanityCheck5.java ecj-3.5.1-gcassertions/test/SanityCheck5.java
--- ecj-3.5.1/test/SanityCheck5.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/SanityCheck5.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,11 @@
+package test;
+
+public class SanityCheck5
+{
+	public static void foo()
+	{
+		Object r = new Object();
+
+		GCAssert.assert("forall Node x : reach[r/{r, x}](x)");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/SanityCheck6.java ecj-3.5.1-gcassertions/test/SanityCheck6.java
--- ecj-3.5.1/test/SanityCheck6.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/SanityCheck6.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,12 @@
+package test;
+
+public class SanityCheck6
+{
+	public static void foo()
+	{
+		Object r = new Object();
+		Object s = new Object();
+
+		GCAssert.assert("(forall Node x : reach[r/r](x)) && (forall Node x : reach[s/r](x))");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/SanityCheck7.java ecj-3.5.1-gcassertions/test/SanityCheck7.java
--- ecj-3.5.1/test/SanityCheck7.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/SanityCheck7.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,12 @@
+package test;
+
+public class SanityCheck7
+{
+	public static void foo()
+	{
+		Object r = new Object();
+		Object s = new Object();
+
+		GCAssert.assertDisjoint("(forall Node x : reach[r/r](x)) && (forall Node x : reach[s/r](x))");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/SanityCheck8.java ecj-3.5.1-gcassertions/test/SanityCheck8.java
--- ecj-3.5.1/test/SanityCheck8.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/SanityCheck8.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,12 @@
+package test;
+
+public class SanityCheck8
+{
+	public static void foo()
+	{
+		Object r = new Object();
+		Object s = new Object();
+
+		GCAssert.assumeDisjoint("(forall Node x : reach[r/r](x)) && (forall Node x : reach[s/r](x))");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/SanityCheck9.java ecj-3.5.1-gcassertions/test/SanityCheck9.java
--- ecj-3.5.1/test/SanityCheck9.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/SanityCheck9.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,12 @@
+package test;
+
+public class SanityCheck9
+{
+	public static void foo()
+	{
+		Object r = new Object();
+		Object s = new Object();
+
+		GCAssert.assert("(forall Node x : reach[r/r](x) && reach[r/r](x))");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/TestHarness.java ecj-3.5.1-gcassertions/test/TestHarness.java
--- ecj-3.5.1/test/TestHarness.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/TestHarness.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,57 @@
+/*
+ * For some reason JUnit isn't co-operating.  It's faster to write my own
+ * test harness than to debug this, so here we go.
+ */
+
+package test;
+
+import java.lang.reflect.Method;
+public class TestHarness
+{
+	public static void main(String[] _) throws Exception
+	{
+		int tests = 0;
+		int successful = 0;
+
+		Class self = Class.forName("test.MagicChecker");
+		Object o = self.newInstance();
+		Method[] methods = self.getMethods();
+		for (Method m : methods)
+			if (m.getName().startsWith("test")) {
+				boolean failed = false;
+
+				++tests;
+				System.out.print(m.getName() + " : ");
+				try {
+					m.invoke(o);
+				} catch (Exception e) {
+					System.out.println("\u001b[1;31mFAILED\u001b[0m");
+					e.printStackTrace();
+					failed = true;
+				}
+
+				if (!failed) {
+					System.out.println("\u001b[1;32mOK\u001b[0m");
+					++successful;
+				}
+			}
+		System.out.println("\nSummary: " + successful + " / " + tests + " succeeded");
+	}
+
+	public static void
+	assertTrue(boolean b)
+	{
+		if (!b)
+			throw new AssertionFailedException();
+	}
+
+
+	public static void
+	assertFalse(boolean b)
+	{
+		if (b)
+			throw new AssertionFailedException();
+	}
+
+	public static final class AssertionFailedException extends RuntimeException {}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/TestT0.expect ecj-3.5.1-gcassertions/test/TestT0.expect
--- ecj-3.5.1/test/TestT0.expect	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/TestT0.expect	2010-03-09 21:35:36.000000000 +0000
@@ -0,0 +1,4 @@
+T0(*) = true
+T0(a) = ==(#Ltest/Node;public-int-v(x), (int)0)
+T0(b) = ==(#Ltest/Node;public-int-v(x), (int)1)
+3 predicate functions needed
diff -ruN ecj-3.5.1/test/TestT0.java ecj-3.5.1-gcassertions/test/TestT0.java
--- ecj-3.5.1/test/TestT0.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/TestT0.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,12 @@
+package test;
+
+public class TestT0
+{
+	public static Node a, b;
+
+	public static void foo()
+	{
+
+		GCAssert.assertDisjoint("exists Node x : (reach[a](x) -> x.v == 0) && (reach[b](x) -> x.v == 1)");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/TestT1.expect ecj-3.5.1-gcassertions/test/TestT1.expect
--- ecj-3.5.1/test/TestT1.expect	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/TestT1.expect	2010-03-09 21:35:36.000000000 +0000
@@ -0,0 +1,7 @@
+T0(*) = true
+T0(a) = ==(#Ltest/Node;public-int-v(x), (int)0)
+T0(b) = true
+T1(*) = false
+T1(a) = false
+T1(b) = true
+2 predicate functions needed
diff -ruN ecj-3.5.1/test/TestT1.java ecj-3.5.1-gcassertions/test/TestT1.java
--- ecj-3.5.1/test/TestT1.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/TestT1.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,15 @@
+package test;
+
+public class TestT1
+{
+	public static Node a, b;
+
+	public static boolean foo()
+	{
+		double d = 0.0;
+
+		GCAssert.assertDisjoint("(exists Node x : (reach[a](x) -> x.v == 0)) && (exists Object o : reach[b](o))");
+
+		return d > 100.0; // just use it somehow
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/TestT2.expect ecj-3.5.1-gcassertions/test/TestT2.expect
--- ecj-3.5.1/test/TestT2.expect	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/TestT2.expect	2010-03-09 21:35:36.000000000 +0000
@@ -0,0 +1,3 @@
+T0(*) = true
+T0(a) = false
+1 predicate function needed
diff -ruN ecj-3.5.1/test/TestT2.java ecj-3.5.1-gcassertions/test/TestT2.java
--- ecj-3.5.1/test/TestT2.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/TestT2.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,12 @@
+package test;
+
+public class TestT2
+{
+	public static Node a, b;
+
+	public static void foo()
+	{
+
+		GCAssert.assertDisjoint("forall Node x : reach[a](x)");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/TestT3.expect ecj-3.5.1-gcassertions/test/TestT3.expect
--- ecj-3.5.1/test/TestT3.expect	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/TestT3.expect	2010-03-19 03:57:44.000000000 +0000
@@ -0,0 +1,4 @@
+T0(*) = false
+T0(a.next) = !=(x, null)
+T0(b.next) = !=(x, null)
+1 predicate function needed
diff -ruN ecj-3.5.1/test/TestT3.java ecj-3.5.1-gcassertions/test/TestT3.java
--- ecj-3.5.1/test/TestT3.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/TestT3.java	2010-03-19 03:53:36.000000000 +0000
@@ -0,0 +1,12 @@
+package test;
+
+public class TestT3
+{
+	public static Node a, b;
+
+	public static void foo()
+	{
+		// yes, this is impossible.  It's only used to test GVNing.
+		GCAssert.assertDisjoint("forall Node x : (reach[a.next](x) -> x == null) && (reach[{b.next}](x) -> x == null)");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/TyCheck0.java ecj-3.5.1-gcassertions/test/TyCheck0.java
--- ecj-3.5.1/test/TyCheck0.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/TyCheck0.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,11 @@
+package test;
+
+public class TyCheck0
+{
+	public static void foo()
+	{
+		Object r = new Object();
+
+		GCAssert.assert("r == 2");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/TyCheck1.java ecj-3.5.1-gcassertions/test/TyCheck1.java
--- ecj-3.5.1/test/TyCheck1.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/TyCheck1.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,11 @@
+package test;
+
+public class TyCheck1
+{
+	public static void foo()
+	{
+		Object r = new Object();
+
+		GCAssert.assert("forall Object x : x == 2");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/TyCheck2.java ecj-3.5.1-gcassertions/test/TyCheck2.java
--- ecj-3.5.1/test/TyCheck2.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/TyCheck2.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,11 @@
+package test;
+
+public class TyCheck2
+{
+	public static void foo()
+	{
+		Object r = new Object();
+
+		GCAssert.assert("forall Object x : x.v != null");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/TyCheck3.java ecj-3.5.1-gcassertions/test/TyCheck3.java
--- ecj-3.5.1/test/TyCheck3.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/TyCheck3.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,11 @@
+package test;
+
+public class TyCheck3
+{
+	public static void foo()
+	{
+		Object r = new Object();
+
+		GCAssert.assert("forall Object x : 2 > r");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/TyCheck4.java ecj-3.5.1-gcassertions/test/TyCheck4.java
--- ecj-3.5.1/test/TyCheck4.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/TyCheck4.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,11 @@
+package test;
+
+public class TyCheck4
+{
+	public static void foo()
+	{
+		Object r = new Object();
+
+		GCAssert.assert("forall Object x : reach[r](x) > 1");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/TyCheck5.java ecj-3.5.1-gcassertions/test/TyCheck5.java
--- ecj-3.5.1/test/TyCheck5.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/TyCheck5.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,9 @@
+package test;
+
+public class TyCheck0
+{
+	public static void foo()
+	{
+		GCAssert.assert("2");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/TyCheck6.java ecj-3.5.1-gcassertions/test/TyCheck6.java
--- ecj-3.5.1/test/TyCheck6.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/TyCheck6.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,11 @@
+package test;
+
+public class TyCheck6
+{
+	public static void foo()
+	{
+		Object r = new Object();
+
+		GCAssert.assert("forall java.util.LinkedList x : x");
+	}
+}
\ No newline at end of file
diff -ruN ecj-3.5.1/test/TyCheck7.java ecj-3.5.1-gcassertions/test/TyCheck7.java
--- ecj-3.5.1/test/TyCheck7.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/TyCheck7.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,9 @@
+package test;
+
+public class TyCheck7
+{
+	public static void foo()
+	{
+		GCAssert.assert("forall int x : x > 0");
+	}
+}
diff -ruN ecj-3.5.1/test/TyCheck8.java ecj-3.5.1-gcassertions/test/TyCheck8.java
--- ecj-3.5.1/test/TyCheck8.java	1970-01-01 00:00:00.000000000 +0000
+++ ecj-3.5.1-gcassertions/test/TyCheck8.java	2010-03-09 21:35:37.000000000 +0000
@@ -0,0 +1,9 @@
+package test;
+
+public class TyCheck8
+{
+	public static void foo()
+	{
+		GCAssert.assert("(forall Object x : x != null) && x == null");
+	}
+}
