diff -ruN jikesrvm-3.1.0/GCASSERTIONS.README jikesrvm-3.1.0-gcassertions/GCASSERTIONS.README
--- jikesrvm-3.1.0/GCASSERTIONS.README	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/GCASSERTIONS.README	2010-03-19 14:09:52.000000000 +0000
@@ -0,0 +1,254 @@
+This is the README file for the Jikes RVM part of the GC Assertions
+framework, version 3.
+
+
+If you have not yet the README for the ECJ part of the GC Assertions
+framework for this version, do so now, as this README only covers
+low-level matters.
+
+
+
+Configuring
+===========
+Make sure to set your .ant.properties, in your project root, to the
+correct architecture, e.g.
+
+  host.name=x86_64-linux
+
+if you are on AMD64 and Linux.
+
+Building
+========
+Quick build:
+
+  ant -Dconfig.name=BaseBaseGCAssertions
+
+
+Build for fast runtime:
+
+  ant -Dconfig.name=FastAdaptiveGCAssertions
+
+
+Testing
+=======
+  make
+
+or, for the fast adaptive tests,
+
+  make fastadaptive
+
+
+Running
+=======
+
+  The system supports the following command-line arguments:
+
+  -X:gc:dummyGCAssertion=true
+    This ensures that during every GC that does not check a regular
+    assertion, we will instead apply a dummy assertion check to each
+    object encountered.  The assertion check is minimal and therefore
+    ideal to measure system overhead.
+
+  -X:gc:dummyGCAssertionwithtraversalID=true
+    (should only be used in conjunction with
+    -X:gc:dummyGCAssertion=true)
+    This extends -X:gc:dummyGCAssertion=true to also track traversal
+    IDs on each object.
+
+  -X:gc:assertfrequency=<n>
+    Assertion checking frequency:
+    -1: never
+    0: always (default)
+    n: every (n+1)st time
+
+  -X:gc:assertonheapfull=true
+    If we decided not assertion checking by frequency: check GC
+    heuristics and collect if we'd normally GC now
+   
+
+
+
+Limitations
+===========
+This won't work on PPC for now (the code generator would have to be
+updated.)
+
+Overlap checks are limited to 15 nested checks:  you can check that
+the reachable or dominated nodes of S0 and S1 do (or do not) overlap,
+then that S2 does (or does not) overlap with (S0 \union S1), and so
+on, up to S14, due to limitations on the number of bits we have
+available.
+
+
+Using the system `by hand'
+==========================
+The easiest way to use this system is to use the ECJ frontend.  If
+that is not available (or not powerful enough or not a good enough
+choice for other reasons), below are the steps needed to run a
+GCAssertion.
+
+First, all relevant classes are in the package
+
+  org.mmtk.plan.marksweep.gcassertions.spec
+
+Assertion
+---------
+This is the main entry point for running assertions.  The static
+`doAssert' method invokes an assertion and returns a boolean to
+determine whether the assertion held up or failed.  Usage:
+
+  PredicateFamily[] predicate_families = ...
+  Step[] steps = ...
+  doAssert(new Assertion(predicate_families, steps));
+
+where PredicateFamily and Step are described below.
+
+PredicateFamily
+---------------
+Each assertion tests a list of predicate families.  Each predicate
+family describes one quantified expression (forall ..., exists ...).
+However, as we pass through different regions on the heap, each of
+these quantified expressions has to test different properties.  For
+example, to check
+
+  forall Node x : (reach(a)[x] -> x.v == 0) &&( reach(b)[x] -> x.v == 1)
+
+has to test three different things:  when `x' is reachable from `a',
+it has to test `x.v == 0' (if `x' is a node); when `x' is reachable
+from `b', it has to test `x.v == 1', and otherwise it has to test
+`true'.  These three cases are three different predicates.  When we
+construct a predicate family, we must provide implementations for each
+of these predicates, as a static helper method in some class C, of the
+following form:
+
+
+  // 2nd static method in this file
+  public static boolean
+  P_a(Object _x, Object[] env)
+  {
+    if (!(_x instanceof Node))
+      return false;
+    final Node x = (Node) _x;
+    return !(x.v == 0);
+  }
+
+  // 3rd static method in this file
+  public static boolean
+  P_b(Object _x, Object[] env)
+  {
+    if (!(_x instanceof Node))
+      return false;
+    final Node x = (Node) _x;
+    return !(x.v == 1);
+  }
+
+Note two things:  first, we included the type check in the
+predicate, and second, negated the return value (only in the case that
+_x had the right type.)  Negating the return value is necessary for
+universal quantification (`forall') due to a technical reason:  the
+predicate should return `true' iff the check is `done,' and for
+`forall' the word `done' means `failed' and for `exists' the word
+`done' means `succeeded' (this hack slightly simplifies the common
+case of the runtime logic.)
+
+To pass P_a and P_b to the PredicateFamily, we tell the family the
+how-many-eth static method in that particular class they are, as
+follows:
+
+PredicateFamily fam =
+   new PredicateFamily(C.class,              // which class
+       		       new int { 1, 2, -1 }, // which methods
+		       null,		     // env
+		       PredicateFamily.UNIVERSAL);
+
+The first parameter is the class storing the predicates.  The second
+is an array of ints containing the indices.  The 2nd static method
+(offset 1) would be represented by `1', the 3rd method (offset 2) by
+`2', and so on.  Methods that always return `not finished yet', i.e.,
+`false' in the existential case or `true' in the universal case, can
+be denoted as -1 (which is slightly faster than producing a `proper'
+predicate.)
+
+The `env' parameter is an optional array of objects.  These are passed
+to the predicates as the second, `env,' parameter.  In conjunction
+with the ECJ frontend they are used to pass the local environment to
+the predicates.
+
+The last parameter can be either PredicateFamily.UNIVERSAL or
+PredicateFamily.EXISTENTIAL and is fairly self-explanatory.
+
+
+Step
+----
+The second parameter to an Assertion is a list of Step objects.  Step
+itself is an abstract class; the remaindeer of this section lists
+various valid steps.  Note that the array of steps must be well-formed,
+accoriding to the following criteria:
+
+- the first entry in the array must be null (used by the Assertion to
+  exclude internal assertion data from the traversal)
+- the last three entries in the array must be null (as above)
+- no other entry may be `null'
+- there must be at least one root node traversal
+- each `ExcludeNodesStep(N)' must eventually be followed by an
+  `IncludeNodesStep(N)', which must in turn be eventually followed by
+  a `TraversalStep(N).'
+
+
+ExcludeNodesStep
+----------------
+Removes a list of nodes from traversal by marking them as `already
+visited.'  This can be exploited for dominance checks or other kinds
+of filtering.
+
+
+IncludeNodesStep
+----------------
+Marks a list of nodes as not having been visited yet.  This operation
+cancels out the ExcludeNodesStep.
+
+
+SetTraversalPredicatesStep
+--------------------------
+This operation sets, for each predicate family (in order) the
+predicate that should be tested during the next TraversalStep.  For
+example, with
+
+SetTraversalPredicatesStep({ 1, 1, 0 })
+
+predicate family #0 would test their predicate at offset 1
+predicate family #1 would test their predicate at offset 1
+predicate family #2 would test their predicate at offset 0
+
+
+SetTraversalIdStep
+------------------
+This operation sets an ID for the current traversal.  If, during the
+traversal, we encounter a heap node that has been tagged with a lower
+ID, we record this fact (cf. Assertion.traversalOverlapped()).  Note
+that using SetTraversalIdStep in a traversal program will activate
+additional code in the GC Assertions system that may slow down
+traversal by up to 10% (over total GC runtime.)  This slowdown is per
+traversal program and independent of where in the program the first
+`SetTraversalIdStep' appears.
+
+TraversalStep
+-------------
+This operation exists in two forms:  without a parameter or with a
+list of nodes.  Without a parameter, this operation recursively marks
+the heap, starting from the root set, ignoring any previously touched
+(or excluded-and-not-yet-re-included) nodes and applying traversal
+predicates and checking for overlap.
+
+With a parameter, the operation does the same, except that it starts
+on the nodes specified as parameter rather than at the root set. 
+
+
+See gtest/Test.java for examples.
+
+
+Playing around with the system
+==============================
+Most of the system logic is in
+MMTk/src/org/mmtk/plan/marksweep/gcassertions/, with some support
+throughout the RVM code.
diff -ruN jikesrvm-3.1.0/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ObjectModel.java jikesrvm-3.1.0-gcassertions/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ObjectModel.java
--- jikesrvm-3.1.0/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ObjectModel.java	2009-04-24 15:00:43.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/ObjectModel.java	2010-02-10 15:35:41.000000000 +0000
@@ -14,6 +14,7 @@
 
 import org.mmtk.utility.alloc.Allocator;
 
+import org.jikesrvm.VM;
 import org.jikesrvm.runtime.Magic;
 import org.jikesrvm.objectmodel.JavaHeaderConstants;
 import org.jikesrvm.objectmodel.TIB;
@@ -427,5 +428,8 @@
   public void dumpObject(ObjectReference object) {
     DebugUtil.dumpRef(object);
   }
+  
+  
+
 }
 
diff -ruN jikesrvm-3.1.0/MMTk/harness/vmmagic/org/vmmagic/StaticOptTable.java jikesrvm-3.1.0-gcassertions/MMTk/harness/vmmagic/org/vmmagic/StaticOptTable.java
--- jikesrvm-3.1.0/MMTk/harness/vmmagic/org/vmmagic/StaticOptTable.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/harness/vmmagic/org/vmmagic/StaticOptTable.java	2010-01-26 18:33:02.000000000 +0000
@@ -0,0 +1,27 @@
+package org.vmmagic;
+
+import org.vmmagic.unboxed.Address;
+
+public class StaticOptTable
+{
+
+  /* [CR]
+   * Magic method table operations
+   */
+
+  /** Opt-compile method and return a handle to it for later use. */
+  public static int registerStaticMethodHook(Class<?> c, int static_method_index) {
+    return -1;
+  }
+
+  public static Address lookupStaticMethodHook(int hook) {
+    return null;
+  }
+
+  public static void flushStaticMethodHooks() {
+  }
+
+  public static boolean invokeStaticMethod(Object param1, Object[] param2, Address address) {
+    return false;
+  }
+}
\ No newline at end of file
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/Plan.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/Plan.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/Plan.java	2009-04-24 15:00:43.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/Plan.java	2010-07-24 03:33:51.000000000 +0000
@@ -114,6 +114,9 @@
   private static final Word LOG_CLEAR_MASK = LOG_SET_MASK.not();
   public static final Word UNLOGGED_BIT = VM.activePlan.constraints().unloggedBit();
 
+  /* Some plans may need to reserve extra bits otherwise used by the `policy' code (i.e., spaces) */
+  public static final int EXTRA_RESERVED_BITS = 0; //VM.activePlan.constraints().extraBitsInHeader();
+
   /****************************************************************************
    * Class variables
    */
@@ -934,7 +937,7 @@
    * @param spaceFull Space request failed, must recover pages within 'space'.
    * @return True if a collection is requested by the plan.
    */
-  protected boolean collectionRequired(boolean spaceFull) {
+  public boolean collectionRequired(boolean spaceFull) {
     boolean stressForceGC = stressTestGCRequired();
     boolean heapFull = getPagesReserved() > getTotalPages();
 
@@ -942,6 +945,16 @@
   }
 
   /**
+   * @return True if a collection is coming up reasonably soon.
+   */
+  public boolean collectionAlmostRequired() {
+    boolean stressForceGC = stressTestGCRequired();
+    boolean heapNearFull = (getPagesReserved() * 100l) > (getTotalPages() * 95l);
+
+    return stressForceGC || heapNearFull;
+  }
+
+  /**
    * This method controls the triggering of an atomic phase of a concurrent
    * collection. It is called periodically during allocation.
    *
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/PlanConstraints.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/PlanConstraints.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/PlanConstraints.java	2009-05-27 00:07:59.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/PlanConstraints.java	2010-02-19 14:53:17.000000000 +0000
@@ -89,4 +89,7 @@
 
   /** @return A bit which represents that a header is unlogged */
   public Word logSetBitMask() {return Word.zero(); }
+
+  /** @return The number of additional bits (max 3) that the MarkSweepSpace should leave untouched */
+  public int extraBitsInheader() { return 0; }
 }
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/TraceLocal.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/TraceLocal.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/TraceLocal.java	2009-04-24 15:00:43.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/TraceLocal.java	2010-03-22 23:57:25.000000000 +0000
@@ -34,6 +34,9 @@
  */
 @Uninterruptible
 public abstract class TraceLocal extends TransitiveClosure implements Constants {
+
+  public static final boolean DEBUG_TRACING = false; // [CR] Dump objects and collection phases for external debuggery
+
   /****************************************************************************
    *
    * Instance variables
@@ -102,6 +105,11 @@
    */
   @Inline
   public final void reportDelayedRootEdge(Address slot) {
+    if (DEBUG_TRACING) {
+      Log.write("  @@root ");
+      Log.write(slot);
+      Log.writeln("");
+    }
     rootLocations.push(slot);
   }
 
@@ -116,6 +124,7 @@
    */
   @Inline
   public final void processRootEdge(Address slot, boolean untraced) {
+//	  Log.writeln("  (processing root edge)");
     ObjectReference object;
     if (untraced) object = slot.loadObjectReference();
     else     object = VM.activePlan.global().loadObjectReference(slot);
@@ -134,6 +143,7 @@
    * @param root True if this is a root edge.
    */
   public final void processInteriorEdge(ObjectReference target, Address slot, boolean root) {
+//	  Log.writeln("  (processing interior edge)");
     Address interiorRef = slot.loadAddress();
     Offset offset = interiorRef.diff(target.toAddress());
     ObjectReference newTarget = traceObject(target, root);
@@ -163,6 +173,7 @@
    */
   @Inline
   protected void scanObject(ObjectReference object) {
+//	  Log.writeln("  (scanning object)");
     if (specializedScan >= 0) {
       VM.scanning.specializedScanObject(specializedScan, this, object);
     } else {
@@ -183,10 +194,30 @@
    */
   @Inline
   public final void processNode(ObjectReference object) {
+    if (DEBUG_TRACING) {
+      Log.write("  @@tracing ");
+      Log.write(object);
+      Log.writeln("");
+    }
     values.push(object);
+    postProcessNode(object);
+//    ++processed_count;
   }
 
   /**
+   * Hook for handling a node after it has been pushed to the values queue
+   *
+   * @param obj A recently added object
+   */
+  @Inline
+  protected void
+  postProcessNode(ObjectReference obj)
+  {
+  }
+
+//  public int processed_count = 0;
+
+  /**
    * Flush the local buffers of all deques.
    */
   public final void flush() {
@@ -254,6 +285,11 @@
    */
   @Inline
   public ObjectReference traceObject(ObjectReference object) {
+//     if (DEBUG_TRACING) {
+//       Log.write("  @@tracing ");
+//       Log.write(object);
+//       Log.writeln("");
+//     }
     if (Space.isInSpace(Plan.VM_SPACE, object))
       return (Plan.SCAN_BOOT_IMAGE) ? object : Plan.vmSpace.traceObject(this, object);
     if (Space.isInSpace(Plan.IMMORTAL, object))
@@ -461,7 +497,11 @@
   public void processRoots() {
     logMessage(5, "processing delayed root objects");
     while (!rootLocations.isEmpty()) {
-      processRootEdge(rootLocations.pop(), true);
+	    final Address a = rootLocations.pop();
+//	    Log.write(" -- root object ");
+//	    Log.write(a);
+//	    Log.writeln("");
+      processRootEdge(a, true);
     }
   }
 
@@ -480,6 +520,9 @@
     do {
       while (!values.isEmpty()) {
         ObjectReference v = values.pop();
+// 	    Log.write(" -- object reference ");
+// 	    Log.write(v);
+// 	    Log.writeln("");
         scanObject(v);
       }
       processRememberedSets();
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/TransitiveClosure.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/TransitiveClosure.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/TransitiveClosure.java	2009-04-24 15:00:43.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/TransitiveClosure.java	2010-01-29 16:31:20.000000000 +0000
@@ -15,6 +15,7 @@
 import org.mmtk.vm.VM;
 import org.vmmagic.pragma.*;
 import org.vmmagic.unboxed.*;
+import org.mmtk.utility.Log;
 
 /**
  * This abstract class is the fundamental mechanism for performing a
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/MS.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/MS.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/MS.java	2009-04-24 15:00:43.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/MS.java	2010-02-07 17:30:13.000000000 +0000
@@ -146,4 +146,5 @@
     TransitiveClosure.registerSpecializedScan(SCAN_MARK, MSTraceLocal.class);
     super.registerSpecializedMethods();
   }
+
 }
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/MSCollector.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/MSCollector.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/MSCollector.java	2009-04-24 15:00:43.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/MSCollector.java	2010-02-08 15:12:21.000000000 +0000
@@ -14,6 +14,7 @@
 
 import org.mmtk.plan.*;
 import org.mmtk.vm.VM;
+import org.mmtk.utility.Log;
 
 import org.vmmagic.pragma.*;
 
@@ -39,9 +40,24 @@
   /****************************************************************************
    * Instance fields
    */
-  protected MSTraceLocal fullTrace = new MSTraceLocal(global().msTrace, null);;
-  protected TraceLocal currentTrace = fullTrace;
+  protected MSTraceLocal fullTrace;
+  protected TraceLocal currentTrace;
+  
+  /****************************************************************************
+   * Initialization
+   */
 
+  /**
+   * Constructor
+   */
+  public MSCollector() {
+    this(new MSTraceLocal(global().msTrace, null));
+  }
+  
+  public MSCollector(MSTraceLocal trace) {
+    fullTrace = trace;
+    currentTrace = fullTrace;
+  }
 
   /****************************************************************************
    * Collection
@@ -57,6 +73,7 @@
   @Override
   public void collectionPhase(short phaseId, boolean primary) {
     if (phaseId == MS.PREPARE) {
+//      fullTrace.processed_count = 0;
       super.collectionPhase(phaseId, primary);
       fullTrace.prepare();
       return;
@@ -70,6 +87,8 @@
     if (phaseId == MS.RELEASE) {
       fullTrace.release();
       super.collectionPhase(phaseId, primary);
+//      Log.write("processed nodes: ");
+//      Log.writeln(fullTrace.processed_count);
       return;
     }
 
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/MSTraceLocal.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/MSTraceLocal.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/MSTraceLocal.java	2009-04-24 15:00:43.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/MSTraceLocal.java	2010-02-07 17:30:46.000000000 +0000
@@ -26,7 +26,7 @@
  * closure over a mark-sweep space.
  */
 @Uninterruptible
-public final class MSTraceLocal extends TraceLocal {
+public class MSTraceLocal extends TraceLocal {
   /****************************************************************************
    * Instance fields
    */
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertions.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertions.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertions.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertions.java	2010-03-22 12:32:20.000000000 +0000
@@ -0,0 +1,120 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions;
+
+import org.mmtk.vm.Lock;
+import org.mmtk.vm.SynchronizedCounter;
+import org.mmtk.plan.Phase;
+import org.mmtk.plan.TransitiveClosure;
+import org.mmtk.plan.marksweep.MS;
+import org.mmtk.plan.marksweep.gcassertions.GCAssertionsHeader;
+import org.mmtk.utility.Log;
+import org.mmtk.utility.deque.SharedDeque;
+import org.mmtk.utility.options.Options;
+import org.mmtk.utility.options.GCAssertionsDummy;
+import org.mmtk.utility.options.GCAssertionsCollectionOnPressure;
+import org.mmtk.utility.options.GCAssertionsCollectionFrequency;
+import org.mmtk.utility.options.PrintGCAssertionsWarnings;
+import org.mmtk.utility.options.PrintGCAssertionsStats;
+import org.mmtk.utility.ArrayHelpers;
+import org.mmtk.vm.VM;
+
+import org.vmmagic.pragma.*;
+import org.vmmagic.unboxed.*;
+
+/**
+ * This class implements the global state of a our GCAssertions collector.
+ * It is based on the full-heap mark-sweep collector.
+ *
+ */
+@Uninterruptible
+public class GCAssertions extends MS {
+  
+  /* We require locks to ensure that multiple mutator threads calling assertions 
+   * at the same time do not step on one another.
+   */
+  private static final SynchronizedCounter gcLock = VM.newSynchronizedCounter();
+  private static final Lock lock = VM.newLock("Finalizer");
+  
+  public static final short PROCESS = Phase.createSimple("gca");
+  protected static final short processPhase = Phase.createComplex("gca.process", null,
+      Phase.scheduleGlobal     (PROCESS),
+      Phase.scheduleCollector  (PROCESS));
+
+  /**
+   * Constructor
+   */
+  public GCAssertions() {
+    super();
+
+    // Reachability and dominator phases need to happen befor
+    this.insertPhaseAfter(Phase.scheduleCollector(PRECOPY), Phase.scheduleComplex(processPhase));
+    
+    Options.printGCAssertionsWarnings = new PrintGCAssertionsWarnings();
+    Options.printGCAssertionsStats = new PrintGCAssertionsStats();
+    Options.dummyAssertion = new GCAssertionsDummy();
+    Options.assertOnHeapFull = new GCAssertionsCollectionOnPressure();
+    Options.assertFrequency = new GCAssertionsCollectionFrequency();
+  }
+  
+  /**
+   * This assertion tells the system that this is the start of a region of 
+   * allocation we want to examine.  Used in conjunction with 
+   * {@link #allDead()}.
+   */
+  @Interruptible
+  public static void startRegion() {
+    ((GCAssertionsMutator)VM.activePlan.mutator()).inRegion = true;
+  }
+
+//   /**
+//    * This assertion tells the system that all objects allocated since the 
+//    * last call to {@link #startRegion()} should be unreachable at
+//    * the next garbage collection.
+//    */
+//   @Interruptible
+//   public static void allDead() {
+//     GCAssertionsMutator mutatorContext = (GCAssertionsMutator)VM.activePlan.mutator();
+//     mutatorContext.allDead();
+//   }
+
+  
+  /**
+   * Register specialized methods.
+   */
+  @Interruptible
+  protected void registerSpecializedMethods() {
+    super.registerSpecializedMethods();
+    TransitiveClosure.registerSpecializedScan(SCAN_MARK, GCAssertionsTraceLocal.class);
+  }
+  
+  /****************************************************************************
+  *
+  * Collection
+  */
+
+  public void collectionPhase(short phaseId) {
+    
+    //  msTrace.prepare();
+
+    if (phaseId == GCAssertions.PROCESS)
+      return;
+
+    else {
+
+      super.collectionPhase(phaseId);
+
+    }
+  }
+  
+}
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsCollector.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsCollector.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsCollector.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsCollector.java	2010-03-23 02:06:42.000000000 +0000
@@ -0,0 +1,333 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions;
+
+import org.mmtk.plan.marksweep.gcassertions.spec.Step;
+import org.mmtk.plan.marksweep.gcassertions.spec.*;
+import org.mmtk.plan.CollectorContext;
+import org.mmtk.plan.StopTheWorldCollector;
+import org.mmtk.plan.Phase;
+import org.mmtk.plan.marksweep.MS;
+import org.mmtk.plan.marksweep.MSCollector;
+import org.mmtk.plan.marksweep.MSMutator;
+import org.mmtk.utility.options.Options;
+import org.mmtk.vm.VM;
+import org.mmtk.policy.Space;
+import org.vmmagic.pragma.*;
+import org.vmmagic.unboxed.*;
+import org.mmtk.utility.Log;
+
+/**
+ * This class implements <i>per-collector thread</i> behavior
+ * and state for the <i>MS</i> plan, which implements a full-heap
+ * mark-sweep collector.<p>
+ *
+ * Specifically, this class defines <i>MS</i> collection behavior
+ * (through <code>trace</code> and the <code>collectionPhase</code>
+ * method).<p>
+ *
+ * @see MS for an overview of the mark-sweep algorithm.<p>
+ *
+ * FIXME The SegregatedFreeList class (and its descendants such as
+ * MarkSweepLocal) does not properly separate mutator and collector
+ * behaviors, so the ms field below should really not exist in
+ * this class as there is no collection-time allocation in this
+ * collector.
+ *
+ * @see MS
+ * @see MSMutator
+ * @see StopTheWorldCollector
+ * @see CollectorContext
+ */
+@Uninterruptible 
+public class GCAssertionsCollector extends MSCollector {
+  
+  /** Trivial magic query method, used if we are running a fake query */
+  private static final boolean
+  __magic_true(Object _, Object[] __)
+  {
+    return false;
+  }
+
+  /** magic instance-of query method, for running a fake query */
+  private static final boolean
+  __magic_true3(Object obj, Object[] __)
+  {
+    return (obj instanceof Faux);
+  }
+
+
+  public static final boolean ASSERTIONS_ENABLED = true; // set to false to disable all assertion processing (and, hopefully, overhead)
+  public static final boolean ALWAYS_TAG_TRAVERSAL = false; // If true: disable the `don't traversal tag unless GCAsserting' optimisation
+
+  /****************************************************************************
+   * Instance fields
+   */
+  protected GCAssertionsTraceLocal gcaTrace;
+  
+  /****************************************************************************
+   *
+   * Initialization
+   */
+  
+   /**
+   * Constructor
+   */
+  public GCAssertionsCollector() {
+    
+    super(new GCAssertionsTraceLocal(
+        ((GCAssertions)VM.activePlan.global()).msTrace, null));
+    gcaTrace = (GCAssertionsTraceLocal)fullTrace;
+    init_static();
+  }
+
+
+  /****************************************************************************
+  *
+  * Hooks for predicate execution
+  */
+
+  @Inline
+  public final void
+  excludeNode(Object object)
+  {
+    final ObjectReference obj = ObjectReference.fromObject(object);
+
+    if (!obj.isNull()
+	&& Space.isInSpace(MS.MARK_SWEEP, obj)) {
+//       Log.write("Excluding: ");
+//       Log.writeln(obj);
+
+      GCAssertionsHeader.setExcludedVisited(obj, GCAssertions.msSpace.isLive(obj));
+
+      GCAssertions.msSpace.mark(obj);
+      GCAssertionsHeader.setTraversalId(obj, GCAssertionsHeader.MAX_TRAVERSAL_ID);
+    }
+  }
+
+  /**
+   * Untag a boundary nodes and add it to the to-trace set
+   *
+   */
+  @Inline
+  public final void
+  includeNode(Object object)
+  {
+    final ObjectReference obj = ObjectReference.fromObject(object);
+
+    if (!obj.isNull()
+	&& Space.isInSpace(MS.MARK_SWEEP, obj)) {
+//       Log.write("Including: ");
+//       Log.writeln(obj);
+      if (GCAssertionsHeader.isExcludedVisited(obj))
+	GCAssertions.msSpace.mark(obj);
+      else
+	GCAssertions.msSpace.unmark(obj);
+      GCAssertionsHeader.setTraversalId(obj, GCAssertionsTraceLocal.getTraversalId());
+    }
+  }
+
+  /**
+   * Sets the Id to apply to heap traversals and activates traversal ID/overlap checking
+   *
+   */
+  public final void
+  setTraversalId(final int _trace_id)
+  {
+    GCAssertionsTraceLocal.setTraversalId(_trace_id);
+  }
+
+  /**
+   * Enqueues a node for (parallel) collection
+   *
+   */
+  @Inline
+  public final void
+  enqueueNodeForCollection(final Object obj)
+  {
+//     Log.write("Enqueueing: ");
+//     Log.writeln(ObjectReference.fromObject(obj));
+    MS.msSpace.traceObject(gcaTrace, ObjectReference.fromObject(obj));
+    //    gcaTrace.processNode(ObjectReference.fromObject(obj));
+  }
+
+  /**
+   * Enqueues the root set for traversal
+   */
+  public final void
+  enqueueRootSet()
+  {
+//     Log.writeln("Root set traversal...");
+    VM.scanning.computeThreadRoots(getCurrentTrace());
+    VM.scanning.computeGlobalRoots(getCurrentTrace());
+    VM.scanning.computeStaticRoots(getCurrentTrace());
+    VM.scanning.computeBootImageRoots(getCurrentTrace());
+    gcaTrace.processRoots();
+  }
+  
+  /****************************************************************************
+  *
+  * Collection
+  */
+
+  /**
+   * Perform a per-collector collection phase.
+   *
+   * @param phaseId The collection phase to perform
+   * @param primary Perform any single-threaded activities using this thread.
+   */
+  @Inline
+  public void collectionPhase(short phaseId, boolean primary) {
+    if (org.mmtk.plan.TraceLocal.DEBUG_TRACING) {
+      Log.write(" collectionPhase: ");
+      Log.write(phaseId);
+      Log.write(": ");
+      Log.writeln(org.mmtk.plan.Phase.getName(phaseId));
+    }
+
+    if (phaseId == MS.ROOTS) // handled in the assertion program
+      return;
+    else if (phaseId == MS.STACK_ROOTS) // handled in the assertion program
+      return;
+    else if (phaseId == GCAssertions.INITIATE) {
+      super.collectionPhase(phaseId, primary);
+
+    } else if (phaseId == GCAssertions.PROCESS) {
+      if (Assertion.getAssertion() == null) {
+        int dummyAssertion = Options.dummyAssertion.getValue();
+        if (dummyAssertion > 0) {
+          switch (dummyAssertion) {
+            case 1: 
+              Assertion.setAssertion(fake_debug_assertion);
+              //Log.writeln("Always true");
+              break;
+            case 2:
+              Assertion.setAssertion(fake_debug_assertion2);
+              //Log.writeln("Always true with traversal ID");
+              break;
+            case 3:
+              Assertion.setAssertion(fake_debug_assertion3);
+              //Log.writeln("instanceof");
+              break;
+            case 4: 
+              Assertion.setAssertion(fake_debug_assertion4);
+              //Log.writeln("instanceof with traversal ID");
+              break;
+            default: 
+              VM.assertions._assert(false, "Invalid dummy assertion");
+          }
+	}
+	else
+	  Assertion.setAssertion(default_assertion);
+      }
+
+      final Assertion assertion = Assertion.getAssertion();
+
+      final Step[] steps = assertion.getSteps();
+      int program_counter = 0;
+      setTraversalId(0);
+
+      // execute program
+      while (program_counter < steps.length) {
+
+	final boolean needs_closure = steps[program_counter++].run(this);
+
+	if (needs_closure)
+	  super.collectionPhase(MS.CLOSURE, primary);
+
+	if (GCAssertionsTraceLocal.getOverlapObject() != null) {
+	  Assertion.getAssertion().setTouchedFlag();
+	}
+      }
+      // finished executing
+
+      return;
+    }
+  
+    super.collectionPhase(phaseId, primary);
+  }
+
+
+  // --------------------------------------------------------------------------------
+  // Debug predicate
+  private static Assertion fake_debug_assertion;
+  private static Assertion fake_debug_assertion2;
+  private static Assertion fake_debug_assertion3;
+  private static Assertion fake_debug_assertion4;
+  private static Assertion default_assertion;
+
+  @Interruptible
+  static private final void init_static ()
+  {
+    default_assertion =
+      new Assertion(new PredicateFamily[0],
+		    new Step[] { null,
+				 new TraversalStep(), // mark everything from the roots
+				 null,
+				 null,
+				 null });
+
+
+    final PredicateFamily dummy_predicate =
+      new PredicateFamily(GCAssertionsCollector.class,
+			  new int[] { 0 },
+			  new Object[] {},
+			  PredicateFamily.UNIVERSAL);
+
+    final PredicateFamily dummy_predicate3 =
+      new PredicateFamily(GCAssertionsCollector.class,
+			  new int[] { 1 },
+			  new Object[] {},
+			  PredicateFamily.UNIVERSAL);
+
+    fake_debug_assertion =
+      new Assertion(new PredicateFamily[] { dummy_predicate },
+		    new Step[] { null,
+				 new SetTraversalPredicatesStep(new int[] { 0 }), // activate test
+				 new TraversalStep(), // mark everything from the roots
+				 null,
+				 null,
+				 null });
+
+    fake_debug_assertion2 =
+      new Assertion(new PredicateFamily[] { dummy_predicate },
+		    new Step[] { null,
+				 new SetTraversalIdStep(0), // Nonsensical traversal ID setting will trigger traversal ID accounting
+				 new SetTraversalPredicatesStep(new int[] { 0 }), // activate test
+				 new TraversalStep(), // mark everything from the roots
+				 null,
+				 null,
+				 null });
+
+    fake_debug_assertion3 =
+      new Assertion(new PredicateFamily[] { dummy_predicate3 },
+		    new Step[] { null,
+				 new SetTraversalPredicatesStep(new int[] { 0 }), // activate test
+				 new TraversalStep(), // mark everything from the roots
+				 null,
+				 null,
+				 null });
+    
+    fake_debug_assertion4 =
+      new Assertion(new PredicateFamily[] { dummy_predicate3 },
+        new Step[] { null,
+         new SetTraversalIdStep(0), // Nonsensical traversal ID setting will trigger traversal ID accounting
+         new SetTraversalPredicatesStep(new int[] { 0 }), // activate test
+         new TraversalStep(), // mark everything from the roots
+         null,
+         null,
+         null });
+  }
+
+  private static final class Faux {};
+}
\ No newline at end of file
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsConstraints.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsConstraints.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsConstraints.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsConstraints.java	2010-02-19 14:53:17.000000000 +0000
@@ -0,0 +1,37 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions;
+
+import org.mmtk.plan.marksweep.MSConstraints;
+import org.mmtk.policy.MarkSweepSpace;
+import org.vmmagic.pragma.*;
+
+/**
+ * GCAssertions common constants.
+ */
+@Uninterruptible public class GCAssertionsConstraints extends MSConstraints {
+  
+  public int gcHeaderBits() { 
+    return MarkSweepSpace.LOCAL_GC_BITS_REQUIRED + GCAssertionsHeader.LOCAL_GC_BITS_REQUIRED; 
+  }
+  
+  public int gcHeaderWords() { 
+    return MarkSweepSpace.GC_HEADER_WORDS_REQUIRED + GCAssertionsHeader.GC_HEADER_WORDS_REQUIRED; 
+  }
+
+  // Reserve two extra bits to mark objects that we are specifically `on the lookout' for and objects that we have tagged with a desired traversal ID
+  public int extraBitsInheader() {
+    return 2;
+  }
+  
+}
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsHeader.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsHeader.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsHeader.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsHeader.java	2010-03-23 02:01:46.000000000 +0000
@@ -0,0 +1,244 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions;
+
+import org.mmtk.policy.MarkSweepSpace;
+import org.mmtk.utility.Constants;
+import org.mmtk.vm.VM;
+
+import org.vmmagic.unboxed.*;
+import org.vmmagic.pragma.*;
+
+/**
+ * Each instance of this class corresponds to one MarkSweepSpace.  In other 
+ * words, it maintains and performs actions with
+ * respect to state that is global to a given MarpSweepSpace.
+ * Each of the instance methods of this class may be called by any
+ * thread (i.e. synchronization must be explicit in any instance or
+ * class method).
+ */
+@Uninterruptible public final class GCAssertionsHeader implements Constants {
+
+  /****************************************************************************
+   *
+   * Class variables
+   */
+
+  public static final int LOCAL_GC_BITS_REQUIRED = 4;
+  public static final int GLOBAL_GC_BITS_REQUIRED = 0;
+  public static final int GC_HEADER_WORDS_REQUIRED = 0;
+  public static final Offset GC_HEADER_WORD1_OFFSET = VM.objectModel.GC_HEADER_OFFSET();
+  public static final Offset GC_HEADER_WORD2_OFFSET = GC_HEADER_WORD1_OFFSET.plus(Constants.BYTES_IN_WORD);
+
+  
+  /**
+   * We use bits in the header for our GC Assertions.  We assume that the 
+   * first four bits are used for the mark-sweep collector, so we use begin 
+   * use at the fifth bit.  
+   * 
+   * Since ADDRESS_BASED_HASHING is true, there are 8 bits available.  4 
+   * are used by the mark sweep space, and the other 4 are used for 
+   * GC Assertions. 
+   * 
+   * Bit 4 is used for our dead() assertion.
+   * Bit 5 is used for our unshared() assertion.
+   * Bits 6 and 7 are used for our ownedBy() assertion.
+   */
+  public static final int MAX_TRAVERSAL_ID = 0x7;
+  private static final int OVERLAP_TEST_SHIFT = MarkSweepSpace.LOCAL_GC_BITS_REQUIRED;
+  private static final Word OVERLAP_TEST_MASK = Word.fromIntZeroExtend(MAX_TRAVERSAL_ID).lsh(OVERLAP_TEST_SHIFT);  // ...01111000
+
+
+  /**
+   * The excluded-visited flag is set on excluded objects that we've visitedbefore, to properly avoid re-traversal.
+   */
+  private static final int EXCLUDED_VISITED_SHIFT = MarkSweepSpace.LOCAL_GC_BITS_REQUIRED + 3;
+  private static final Word EXCLUDED_VISITED_MASK = Word.fromIntZeroExtend(0x1).lsh(EXCLUDED_VISITED_SHIFT);  // ...01111000
+
+
+//   private static final Word DEAD = Word.one().lsh(
+//       MarkSweepSpace.LOCAL_GC_BITS_REQUIRED);     // ...00010000
+//   private static final Word UNSHARED = Word.one().lsh(
+//       MarkSweepSpace.LOCAL_GC_BITS_REQUIRED+1);   // ...00100000
+//   private static final Word OWNEE = Word.one().lsh(  
+//       MarkSweepSpace.LOCAL_GC_BITS_REQUIRED+2);   // ...01000000
+//   private static final Word OWNED_ENCOUNTERED = Word.one().lsh(  
+//       MarkSweepSpace.LOCAL_GC_BITS_REQUIRED+3);   // ...10000000
+  
+  /****************************************************************************
+  *
+  * Object tagging methods
+  */
+
+  @Inline
+  @Uninterruptible
+  public static int getTraversalId(ObjectReference object) { 
+    Word value = VM.objectModel.readAvailableBitsWord(object);
+    return value.and(OVERLAP_TEST_MASK).rshl(OVERLAP_TEST_SHIFT).toInt();
+  }
+
+  @Inline
+  @Uninterruptible
+  public static void setTraversalId(ObjectReference object, int id) { 
+    Word value = VM.objectModel.readAvailableBitsWord(object);
+    /*if (VM.VERIFY_ASSERTIONS)
+      VM.assertions._assert(value.and(DEAD).NE(DEAD));*/
+    VM.objectModel.writeAvailableBitsWord(object, value.or(Word.fromIntZeroExtend(id).lsh(OVERLAP_TEST_SHIFT)));
+  }
+
+  @Inline
+  @Uninterruptible
+  public static boolean isExcludedVisited(ObjectReference object) { 
+    Word value = VM.objectModel.readAvailableBitsWord(object);
+    return 0 != value.and(EXCLUDED_VISITED_MASK).toInt();
+  }
+
+  @Inline
+  @Uninterruptible
+  public static void setExcludedVisited(ObjectReference object, boolean ev) { 
+    Word value = VM.objectModel.readAvailableBitsWord(object);
+    /*if (VM.VERIFY_ASSERTIONS)
+      VM.assertions._assert(value.and(DEAD).NE(DEAD));*/
+    VM.objectModel.writeAvailableBitsWord(object, value.or(Word.fromIntZeroExtend(ev ? 1 : 0).lsh(EXCLUDED_VISITED_SHIFT)));
+  }
+  
+//   /**
+//    * Return true if <code>object</code> has been marked as unreachable. 
+//    *
+//    * @param object The object in question
+//    * @return <code>true</code> if <code>object</code> has been marked as 
+//    * reachable
+//    */
+//   @Inline
+//   @Uninterruptible
+//   public static boolean isDead(ObjectReference object) { 
+//     Word value = VM.objectModel.readAvailableBitsWord(object);
+//     return value.and(DEAD).EQ(DEAD);
+//   }
+  
+//   /**
+//    * Mark <code>object</code> as unreachable.  
+//    *
+//    * <code>object</code> is left in the <code>DEAD</code> state.
+//    *
+//    * @param object The object whose state is to be changed.
+//    */
+//   @Inline
+//   @Uninterruptible
+//   public static void makeDead(ObjectReference object) {
+//     Word value = VM.objectModel.readAvailableBitsWord(object);
+//     /*if (VM.VERIFY_ASSERTIONS)
+//       VM.assertions._assert(value.and(DEAD).NE(DEAD));*/
+//     VM.objectModel.writeAvailableBitsWord(object, value.or(DEAD));
+//   }
+
+//   /**
+//    * Mark given object as unshared.
+//    * 
+//    * @param object The object that should be marked unshared
+//    */
+//   @Inline
+//   @Uninterruptible
+//   public static void makeUnshared(ObjectReference object) {
+//     Word value = VM.objectModel.readAvailableBitsWord(object);
+//     VM.objectModel.writeAvailableBitsWord(object, value.or(UNSHARED));
+//   }
+  
+//   /**
+//    * Return true if given object has been marked as unshared. 
+//    *
+//    * @param object The object in question
+//    * @return <code>true</code> if <code>object</code> has been marked as 
+//    * unshared
+//    */
+//   @Inline
+//   @Uninterruptible
+//   public static boolean isUnshared(ObjectReference object) { 
+//     Word value = VM.objectModel.readAvailableBitsWord(object);
+//     return value.and(UNSHARED).EQ(UNSHARED);
+//   }
+  
+//   /**
+//    * Set the bit indicating this object is the ownee in an ownership assertion
+//    * 
+//    * @param object The object that is involved in an ownership assertion
+//    */
+//   @Inline
+//   @Uninterruptible
+//   public static void setOwnee(ObjectReference object) {
+//     Word value = VM.objectModel.readAvailableBitsWord(object);
+//     VM.objectModel.writeAvailableBitsWord(object, value.or(OWNEE));
+//   }
+
+//   /**
+//    * Check whether this object is the ownee in an ownership assertion
+//    * 
+//    * @param object The object that we want to check
+//    * @return Whether the object is involved in an ownership assertion
+//    */
+//   @Inline
+//   @Uninterruptible
+//   public static boolean isOwnee(ObjectReference object) {
+//     Word value = VM.objectModel.readAvailableBitsWord(object);
+//     return value.and(OWNEE).EQ(OWNEE);
+//   }
+
+//   /**
+//    * Set the "owned and encountered" bit in the header.  This should be 
+//    * set when an ownee object is encountered on a path through the owner.
+//    * 
+//    * @param object The object that should be marked as "owned and encountered"
+//    */
+//   @Inline
+//   @Uninterruptible
+//   public static void setEncountered(ObjectReference object) {
+//     if (VM.VERIFY_ASSERTIONS)
+//       VM.assertions._assert(isOwnee(object));
+//     Word value = VM.objectModel.readAvailableBitsWord(object);
+//     VM.objectModel.writeAvailableBitsWord(object, value.or(OWNED_ENCOUNTERED));
+//   }
+  
+//   /**
+//    * Unset the "owned and encountered" owned bit in the header.  This 
+//    * should be unset after every collection.
+//    * 
+//    * @param object The object whose "owned and encountered" bit should be unset
+//    */
+//   @Inline
+//   @Uninterruptible
+//   public static void unsetEncountered(ObjectReference object) {
+//     if (VM.VERIFY_ASSERTIONS)
+//       VM.assertions._assert(isOwnee(object));
+//     Word value = VM.objectModel.readAvailableBitsWord(object);
+//     VM.objectModel.writeAvailableBitsWord(object, value.and(OWNED_ENCOUNTERED.not()));
+//   }
+
+//   /**
+//    * Return true if given object has been marked as "owned and encountered." 
+//    * This should have been set if this ownee object was encountered on 
+//    * a path through the owner.
+//    *
+//    * @param object The object in question
+//    * @return <code>true</code> if <code>object</code> has been marked as "owned and encountered"
+//    */
+//   @Inline
+//   @Uninterruptible
+//   public static boolean isEncountered(ObjectReference object) { 
+//     if (VM.VERIFY_ASSERTIONS)
+//       VM.assertions._assert(isOwnee(object));
+//     Word value = VM.objectModel.readAvailableBitsWord(object);
+//     return value.and(OWNED_ENCOUNTERED).EQ(OWNED_ENCOUNTERED);
+//   }
+  
+
+}
\ No newline at end of file
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsMutator.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsMutator.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsMutator.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsMutator.java	2010-02-04 23:16:50.000000000 +0000
@@ -0,0 +1,171 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions;
+
+import org.mmtk.plan.MutatorContext;
+import org.mmtk.plan.StopTheWorldMutator;
+import org.mmtk.plan.marksweep.MS;
+import org.mmtk.plan.marksweep.MSCollector;
+import org.mmtk.plan.marksweep.MSMutator;
+import org.mmtk.utility.Log;
+import org.mmtk.utility.deque.ObjectReferenceDeque;
+import org.mmtk.utility.deque.SharedDeque;
+
+import org.vmmagic.pragma.*;
+import org.vmmagic.unboxed.ObjectReference;
+
+
+/**
+ * This class implements <i>per-mutator thread</i> behavior
+ * and state for the <i>MS</i> plan, which implements a full-heap
+ * mark-sweep collector.<p>
+ *
+ * Specifically, this class defines <i>MS</i> mutator-time allocation
+ * and per-mutator thread collection semantics (flushing and restoring
+ * per-mutator allocator state).<p>
+ *
+ * @see org.mmtk.plan.markcompact.MC for an overview of the mark-compact algorithm.<p>
+ *
+ * FIXME The SegregatedFreeList class (and its decendents such as
+ * MarkSweepLocal) does not properly separate mutator and collector
+ * behaviors, so the ms field below should really not exist in
+ * this class as there is no collection-time allocation in this
+ * collector.
+ *
+ * @see MS
+ * @see MSCollector
+ * @see StopTheWorldMutator
+ * @see MutatorContext
+ */
+@Uninterruptible public class GCAssertionsMutator extends MSMutator {
+  
+  public boolean inRegion = false;
+  private SharedDeque objectsInRegionPool;
+  public ObjectReferenceDeque objectsInRegion;
+  
+  public GCAssertionsMutator() {
+    objectsInRegionPool = new SharedDeque("objectsInRegionPool", 
+        GCAssertions.metaDataSpace, 1);
+    objectsInRegionPool.prepareNonBlocking();
+    objectsInRegion = new ObjectReferenceDeque("objectsInRegion", 
+        objectsInRegionPool);
+  }
+
+
+//   /**
+//      * Perform post-allocation actions.  For many allocators none are
+//      * required.
+//      *
+//      * @param object The newly allocated object
+//      * @param typeRef the type reference for the instance being created
+//      * @param bytes The size of the space to be allocated (in bytes)
+//      * @param allocator The allocator number to be used for this allocation
+//      */
+//   @Inline
+//   public final void postAlloc(ObjectReference object, ObjectReference typeRef,
+//       int bytes, int allocator) {
+// //     if (inRegion) {
+// //       objectsInRegion.push(object);
+// //     }
+    
+//     super.postAlloc(object, typeRef, bytes, allocator);
+//   }
+
+
+//   /**
+//    * This method is called when an allDead region ends and we need to mark
+//    * all objects allocated since the call to startRegion().  We unset the
+//    * inRegion field and then iterate through the objectsInRegion 
+//    * SharedDeque, marking objects.
+//    */
+//   public void allDead() {
+// //     inRegion = false;
+// //     while (objectsInRegion.isNonEmpty()) {
+// //       ObjectReference obj = objectsInRegion.pop();
+// //       GCAssertionsHeader.makeDead(obj);
+// //     }    
+//   }
+  
+  
+//   /****************************************************************************
+//   *
+//   * Collection
+//   */
+
+//   /**
+//    * Perform a per-mutator collection phase.
+//    *
+//    * @param phaseId The collection phase to perform
+//    * @param primary Perform any single-threaded activities using this thread.
+//    */
+//   @Inline
+//   public void collectionPhase(short phaseId, boolean primary) {
+
+// //     /**
+// //      * In RELEASE phase, the MarkSweepSpace is swept.  This happens when
+// //      * MS.collectionPhase(RELEASE) is called.
+// //      */
+// //     if (phaseId == MS.RELEASE) {
+// //       fixRegionObjectReferences();
+
+// //       super.collectionPhase(phaseId, primary);
+// //       return;
+// //     }
+
+//     super.collectionPhase(phaseId, primary);
+//   }
+ 
+//   /**
+//    * After each GC, if we are in an assertAllDead region, we need to scan
+//    * the list of objects in the region and remove any dead objects.
+//    * 
+//    * TODO: this is actually unnecessary because the ObjectReferenceDeque
+//    * will keep the objects alive, preventing them from being collected.
+//    * Fix this somehow.
+//    */
+//   private void fixRegionObjectReferences() {
+
+// //     ObjectReference firstObj = ObjectReference.nullReference();
+// //     ObjectReference obj = ObjectReference.nullReference();
+
+// //     /* Treat first object reference differently.  We need to keep track of it
+// //      * so we know when to stop looping.  
+// //      * 
+// //      * Note that it is impossible for an object to appear twice in the list
+// //      * because objects are added to the list only when they are allocated,
+// //      * and two objects cannot be allocated to the same address.
+// //      */
+// //     while (objectsInRegion.isNonEmpty()) {
+// //       obj = objectsInRegion.pop();
+// //       if (GCAssertions.msSpace.isLive(obj)) {
+// //         objectsInRegion.insert(obj);
+// //         firstObj = obj;
+// //         break;
+// //       }
+// //     }
+
+// //     if (firstObj != ObjectReference.nullReference()) { 
+// //       // Handle rest of objects
+// //       obj = objectsInRegion.pop();
+// //       while (obj != firstObj) {
+// //         if (GCAssertions.msSpace.isLive(obj)) {
+// //           objectsInRegion.insert(obj);
+// //         }
+// //         obj = objectsInRegion.pop();
+// //       }
+// //     }
+//   }
+    
+    
+
+}
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsTraceLocal.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsTraceLocal.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsTraceLocal.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/GCAssertionsTraceLocal.java	2010-03-23 02:06:49.000000000 +0000
@@ -0,0 +1,203 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions;
+
+import org.mmtk.plan.marksweep.gcassertions.spec.Assertion;
+import org.mmtk.plan.Trace;
+import org.mmtk.plan.marksweep.MS;
+import org.mmtk.plan.marksweep.MSTraceLocal;
+import org.mmtk.plan.marksweep.gcassertions.GCAssertionsHeader;
+import org.mmtk.policy.Space;
+import org.mmtk.policy.MarkSweepSpace;
+import org.mmtk.utility.ArrayHelpers;
+import org.mmtk.utility.Log;
+import org.mmtk.utility.deque.ObjectReferenceDeque;
+import org.mmtk.utility.options.Options;
+import org.mmtk.vm.VM;
+
+import org.vmmagic.pragma.*;
+import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.AddressArray;
+import org.vmmagic.unboxed.ObjectReference;
+import org.vmmagic.unboxed.Word;
+
+/**
+ * This abstract class implements the core functionality for a transitive
+ * closure over the heap graph.
+ */
+@Uninterruptible public final class GCAssertionsTraceLocal extends MSTraceLocal {
+  
+  // Marks an ObjectReference as seen in the deque
+  private static final Word SEEN_MASK = Word.one();   
+  private static final Word SEEN = Word.one(); 
+  
+  /**
+   * Constructor
+   *
+   * @param trace The global trace to use.
+   */
+  public GCAssertionsTraceLocal(Trace trace, ObjectReferenceDeque modBuffer) {
+    super(trace, modBuffer);
+  }
+
+  private static Object detected_overlap = null; // Reference to an object that caused an overlap to take place
+  private static int current_traversal_id = 0; // ID of the traversal currently taking place, if any
+
+  /**
+   * Set the ID of the current traversal, and reset detected_overlap.
+   *
+   * During object tracing, detected_overlap will be set to the first object encountered
+   * that has a lower traversal ID, if any (indicating that it was encountered in an earlier traversal.)
+   *
+   * @param id The new traversal ID to assume
+   */
+  public final static void
+  setTraversalId(int id)
+  {
+    if (id < 0 || id > GCAssertionsHeader.MAX_TRAVERSAL_ID) {
+      Log.write("Invalid traversal ID: ");
+      Log.writeln(id);
+      return;
+    }
+    current_traversal_id = id;
+    detected_overlap = null;
+  }
+
+  /**
+   * Retrieves the most recently set traversal ID
+   */
+  public static final int
+  getTraversalId()
+  {
+    return current_traversal_id;
+  }
+
+  public static final Object
+  getOverlapObject()
+  {
+    return detected_overlap;
+  }
+  
+  /**
+   * This method is the core method during the trace of the object graph.
+   * The role of this method is to:
+   *
+   * 1. Ensure the traced object is not collected.
+   * 2. If this is the first visit to the object enqueue it to be scanned.
+   * 3. Return the forwarded reference to the object.
+   * 4. Check the overlap predicate: if we met this object in a previous traversal,
+   *    we are overlapping.
+   *
+   * @param object The object to be traced.
+   * @return The new reference to the same object instance.
+   */
+  @Inline
+  public ObjectReference traceObject(ObjectReference object) {
+//     if (!object.isNull() && Space.isInSpace(GCAssertions.MARK_SWEEP, object)) {
+//       Log.write("  Considering ");
+//       Log.write(object);
+//       Log.write(" : ");
+//       Log.write(VM.objectModel.getTypeDescriptor(object));
+//       Log.write(", liveness is ");
+//       Log.writeln(GCAssertions.msSpace.isLive(object));
+//     }
+
+    if (GCAssertionsCollector.ASSERTIONS_ENABLED) {
+      if (GCAssertionsCollector.ALWAYS_TAG_TRAVERSAL || Assertion.getTraversalId() >= 0) { // are we disjointness-testing?
+	if (!object.isNull() && Space.isInSpace(GCAssertions.MARK_SWEEP, object)) {
+	  if (GCAssertions.msSpace.isLive(object)) { // has been reached during this iteration?
+	    final int traversal_id = GCAssertionsHeader.getTraversalId(object);
+	    if (traversal_id < current_traversal_id)
+	      detected_overlap = object;
+	  } else
+	    GCAssertionsHeader.setTraversalId(object, current_traversal_id);
+	}
+      }
+    }
+    return super.traceObject(object);
+  }
+  
+  /**
+   * This method traces an object with knowledge of the fact that object
+   * is a root or not. In the GCAssertions framework, we need to know whether
+   * the object is a root to report the correct warning to the user.
+   *
+   * @param object The object to be traced.
+   * @return The new reference to the same object instance.
+   */
+  @Inline
+  public ObjectReference traceObject(ObjectReference object, boolean root) {
+    return traceObject(object);
+  }
+
+//   /**
+//    * Finishing processing all GC work.  This method iterates until all work queues
+//    * are empty.
+//    */
+//   @Inline
+//   public void completeTrace() {
+//     logMessage(4, "Processing GC in parallel");
+//     if (!rootLocations.isEmpty()) {
+//       processRoots();
+//     }
+//     logMessage(5, "processing gray objects");
+//     //assertMutatorRemsetsFlushed();
+//     do {
+//       while (!values.isEmpty()) {
+//         ObjectReference v = values.pop();
+
+//         /* Check for black objects (objects that have already been scanned but
+//          * are still in the values queue).  We had previously set the low-order
+//          * bit on these objects so we can reconstruct the path through the
+//          * heap to the object we are currently tracing.
+//          */
+//         Word w = v.toAddress().toWord();
+//         if (w.and(SEEN_MASK).EQ(SEEN)) {
+//           continue;
+//         }
+        
+//         // set low-order bit to 1 to signify we have seen this, then push back on deque
+//         w = w.or(SEEN);
+//         values.push(w.toAddress().toObjectReference());
+                
+//         scanObject(v);
+//       }
+//       processRememberedSets();
+//     } while (!values.isEmpty());
+//     //assertMutatorRemsetsFlushed();
+        
+//   }
+  
+  public static boolean printTraced = false;
+
+  /**
+   * Apply the assertion node processor (if any) to a node that has just been enqueued
+   *
+   * @param obj The node we are investigating
+   */
+  @Inline
+  protected void
+  postProcessNode(ObjectReference obj)
+  {
+    if (GCAssertionsCollector.ASSERTIONS_ENABLED)
+      Assertion.test(obj);
+
+//     if (printTraced) {
+//       Log.write("  traced ");
+//       Log.write(obj);
+//       Log.write(", ");
+//       Log.write(VM.objectModel.getTypeDescriptor(obj));
+//       Log.writeln("");
+//     }
+  }
+}
\ No newline at end of file
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/AssertStep.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/AssertStep.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/AssertStep.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/AssertStep.java	2010-02-19 14:53:17.000000000 +0000
@@ -0,0 +1,51 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+import org.mmtk.plan.marksweep.gcassertions.*;
+import org.vmmagic.pragma.*;
+import org.vmmagic.unboxed.*;
+
+import org.mmtk.utility.Log;
+import org.mmtk.vm.VM;
+
+
+/**
+ * Assertion step.  One part of assertion execution.
+ *
+ * Asserts that a specific property is set.
+ * Not implemented at this time.
+ */
+@Uninterruptible
+public abstract class AssertStep extends Step {
+  private final TestExpr test;
+  private final String explanation;
+
+  public AssertStep(final TestExpr _test, final String _explanation)
+  {
+    this.test = _test;
+    this.explanation = _explanation;
+  }
+
+  public abstract boolean
+  run(final GCAssertionsCollector _collector);
+//   {
+//     if (!this.test.eval()) {
+//       Assertion.assertion.fail();
+//       Log.write("  ");
+//       Log.writeln(this.explanation);
+//     }
+//     return false;
+//   }
+}
+
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/Assertion.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/Assertion.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/Assertion.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/Assertion.java	2010-07-24 03:34:16.000000000 +0000
@@ -0,0 +1,287 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+import org.mmtk.plan.marksweep.gcassertions.*;
+import org.vmmagic.pragma.*;
+import org.vmmagic.unboxed.*;
+
+import org.mmtk.utility.Log;
+import org.mmtk.vm.VM;
+import org.mmtk.plan.marksweep.MS;
+
+import org.mmtk.utility.options.Options;
+
+/**
+ * Base assertion class.  Acts as a container for `steps' and analyses
+ * them
+ *
+ */
+@Uninterruptible
+public final class Assertion {
+
+  private final Step[] steps;
+  private final PredicateFamily[] predicate_families;
+
+ // references to PredicateFamilys from check_pair
+  private static ObjectReferenceArray active_predicate_families;
+  private static int active_predicate_families_nr;
+  static int traversal_id; // ID of our current traversal
+
+  private long overlap_flags;
+  private static long last_overlap_flags;
+
+  // current assertion object
+  static Assertion assertion = null;
+
+  private void
+  init()
+  {
+    active_predicate_families = ObjectReferenceArray.create(this.predicate_families.length + 1);
+    active_predicate_families_nr = 0;
+    traversal_id = -1;
+  }
+
+  int flags; // Flags.  Reset before each gc.  Updated and read by GC steps.
+
+  /**
+   * Constructs a new assertion.
+   *
+   * @param _steps The steps to execute, in order.  The first and the last three slots must be null.
+   * @param _checks The check pairs (compiled predicate halves) to include
+   */
+  public Assertion(final PredicateFamily[] _checks,
+		   final Step[] _steps)
+  {
+    this.steps = _steps;
+    this.predicate_families = _checks;
+
+    // First and last two steps exclude `this' from reachability/dominance analysis and make sure it is traced in the end
+    if (VM.VERIFY_ASSERTIONS) VM.assertions._assert(_steps.length >= 3);
+    if (VM.VERIFY_ASSERTIONS) VM.assertions._assert(_steps[0] == null);
+    if (VM.VERIFY_ASSERTIONS) VM.assertions._assert(_steps[_steps.length - 1] == null);
+    if (VM.VERIFY_ASSERTIONS) VM.assertions._assert(_steps[_steps.length - 2] == null);
+    if (VM.VERIFY_ASSERTIONS) VM.assertions._assert(_steps[_steps.length - 3] == null);
+
+    final Object[] self_root = new Object[_checks.length + 2];
+    self_root[0] = this;
+    self_root[1] = _steps;
+    for (int i = 0; i < _checks.length; i++)
+      self_root[i+2] = _checks[i];
+
+    _steps[0] = new ExcludeNodesStep(self_root);
+    _steps[_steps.length - 3] = new SetTraversalPredicatesStep(new int[] {}); // disable all checks
+    _steps[_steps.length - 2] = new IncludeNodesStep(self_root);
+    _steps[_steps.length - 1] = new TraversalStep(self_root);
+
+    this.overlap_flags = 0l;
+  }
+
+  public final void
+  setPredicateFamilyIndexVector(final int[] indices)
+  {
+    active_predicate_families_nr = 0;
+
+    for (int i = 0; i < indices.length; i++) {
+      if (this.predicate_families[i].prepareTest(indices[i])) {
+	active_predicate_families.set(active_predicate_families_nr++,
+				      ObjectReference.fromObject(this.predicate_families[i]));
+      }
+    }
+  }
+
+  @Inline
+  public static final void
+  test(final Object o)
+  {
+    for (int i = 0; i < active_predicate_families_nr; i++)
+      if (((PredicateFamily)active_predicate_families.get(i).toObject()).test(o)) {
+	// If the test yielded `true', we need no more testing for the predicate family.
+	active_predicate_families.set(i--, active_predicate_families.get(--active_predicate_families_nr));
+      }
+  }
+
+  @Inline
+  public final void
+  setTouchedFlag()
+  {
+    this.overlap_flags |= (1l << traversal_id);
+  }
+
+  @Inline
+  public final void
+  resetTouchedFlag()
+  {
+    this.overlap_flags &= ~(1l << traversal_id);
+  }
+
+  public boolean
+  traversalOverlapped(final int _traversal_id)
+  {
+    return 0l != (this.overlap_flags & (1 << _traversal_id));
+  }
+
+  @Inline
+  public static final int
+  getTraversalId()
+  {
+    return traversal_id;
+  }
+
+  public final Step[]
+  getSteps()
+  {
+    return this.steps;
+  }
+
+
+  /* ********************* */
+  /* Public interface      */
+
+  /**
+   * Set the current assertion.  Used for debugging.
+   *
+   * @param _assertion The assertion to set
+   */
+  public static void
+  setAssertion(final Assertion _assertion)
+  {
+    assertion = _assertion;
+
+    int traversals = 0;
+    for (Step step : _assertion.getSteps()) {
+      if (step instanceof SetTraversalIdStep)
+	++traversals;
+    }
+
+    final int traversals_allowed = GCAssertionsHeader.MAX_TRAVERSAL_ID;
+
+    if (traversals > traversals_allowed) {
+      Log.write("  Assertion:  Too many assertion overlaps checks:  ");
+      Log.write(traversals);
+      Log.write(" > ");
+      Log.writeln(traversals_allowed);
+      return;
+    }
+
+    assertion.init();
+  }
+
+  /**
+   * Run an assertion
+   *
+   * This executes the garbage collection part of an assertion, assigning valuations to
+   * PredicateFamily objects and the traversal ID.
+   *
+   * @param _assertion The assertion to test
+   * @return whether or not the assertion was indeed tested
+   */
+  @Interruptible
+  public static final boolean
+  doAssertAlways(final Assertion _assertion)
+  {
+    setAssertion(_assertion);
+    System.gc();
+    last_overlap_flags = assertion.overlap_flags;
+    assertion = null;
+    return true;
+  }
+
+  private static boolean initialised = false;
+  private static int collection_counter = 0;
+  private static int collection_frequency = 0;
+  private static boolean collect_on_pressure = false;
+
+  /**
+   * Sets the frequency of GCAssert collections, outside of memory-pressure mandated ones.
+   *
+   * @param _frequency Frequency of extra collections.  0: always, -1: never, n: every (n+1)th opportunity
+   */
+  public static void
+  setCollectionFrequency(final int _frequency)
+  {
+    collection_counter = collection_frequency = _frequency;
+  }
+
+  public static void
+  setCollectOnMemoryPressure(boolean _do_collect)
+  {
+    collect_on_pressure = _do_collect;
+  }
+
+  @Interruptible
+  private static final void
+  initialise_config()
+  {
+    if (!initialised) {
+      setCollectOnMemoryPressure(Options.assertOnHeapFull.getValue());
+      setCollectionFrequency(Options.assertFrequency.getValue());
+      initialised = true;
+    }
+  }
+
+  /**
+   * same as doAssertAlways, but only executes if there is enough gc pressure that we'd normally collect
+   *
+   * @param _assertion The assertion to test
+   * @return whether or not the assertion was indeed tested
+   */
+  @Interruptible
+  public static final boolean
+  doAssert(final Assertion _assertion)
+  {
+    initialise_config();
+//     System.err.print(collection_counter);
+//     System.err.print(":");
+    final boolean must_collect = (collection_counter--) == 0;
+    if (collection_counter < 0)
+      collection_counter = collection_frequency;
+
+    setAssertion(_assertion);
+    System.gc();
+    last_overlap_flags = assertion.overlap_flags;
+    assertion = null;
+
+    final boolean suggest_collection = VM.activePlan.global().collectionAlmostRequired();
+
+//     System.err.print("Collection decision: ");
+//     System.err.print(must_collect);
+//     System.err.print(" || (");
+//     System.err.print(collect_on_pressure);
+//     System.err.print(" && ");
+//     System.err.print(suggest_collection);
+//     System.err.println(")");
+
+    if (collect_on_pressure)
+	    return suggest_collection;
+    else
+	    return must_collect;
+  }
+
+  @Interruptible
+  public static final void
+  checkAssert(boolean b, boolean c)
+  {
+    if (b && !c)
+      throw new Error("GC Assertions: failed assertion!");
+    if (b && (last_overlap_flags != 0L))
+      throw new Error("GC Assertions: not disjoint!");
+  }
+
+  @Inline
+  public static final Assertion
+  getAssertion()
+  {
+    return assertion;
+  }
+}
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/ExcludeNodesStep.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/ExcludeNodesStep.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/ExcludeNodesStep.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/ExcludeNodesStep.java	2010-02-19 14:53:17.000000000 +0000
@@ -0,0 +1,45 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+import org.mmtk.plan.marksweep.gcassertions.*;
+import org.vmmagic.pragma.*;
+import org.vmmagic.unboxed.*;
+
+import org.mmtk.utility.Log;
+import org.mmtk.vm.VM;
+
+
+/**
+ * Assertion step.  One part of assertion execution.
+ *
+ */
+@Uninterruptible
+public final class ExcludeNodesStep extends Step {
+  private final Object[] nodes;
+
+  public ExcludeNodesStep(final Object[] _nodes)
+  {
+    this.nodes = _nodes;
+  }
+
+  public boolean
+  run(final GCAssertionsCollector _collector)
+  {
+    if (this.nodes != null)
+      for (Object o : this.nodes)
+	_collector.excludeNode(o);
+    return false;
+  }
+}
+
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/IncludeNodesStep.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/IncludeNodesStep.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/IncludeNodesStep.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/IncludeNodesStep.java	2010-02-19 14:53:17.000000000 +0000
@@ -0,0 +1,45 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+import org.mmtk.plan.marksweep.gcassertions.*;
+import org.vmmagic.pragma.*;
+import org.vmmagic.unboxed.*;
+
+import org.mmtk.utility.Log;
+import org.mmtk.vm.VM;
+
+
+/**
+ * Assertion step.  One part of assertion execution.
+ *
+ */
+@Uninterruptible
+public final class IncludeNodesStep extends Step {
+  private final Object[] nodes;
+
+  public IncludeNodesStep(final Object[] _nodes)
+  {
+    this.nodes = _nodes;
+  }
+
+  public boolean
+  run(final GCAssertionsCollector _collector)
+  {
+    if (this.nodes != null)
+      for (Object o : this.nodes)
+	_collector.includeNode(o);
+    return false;
+  }
+}
+
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/PredicateFamily.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/PredicateFamily.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/PredicateFamily.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/PredicateFamily.java	2010-03-23 02:11:21.000000000 +0000
@@ -0,0 +1,154 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+import org.vmmagic.pragma.*;
+import org.vmmagic.unboxed.*;
+
+import org.mmtk.utility.Log;
+
+/**
+ * A single predicate, specialised to different cases
+ *
+ */
+@Uninterruptible
+public final class PredicateFamily
+{
+  private final int[] call_address_indices; // Which address to invoke for the nth variant of the predicate (index into the compiler-internal table)
+  private Address current_address;
+  private final Object[] environment;
+  private final boolean existential; // Existential test?  Otherwise universal.
+
+  private boolean completed = false; // `completed' for a universal test means `failed', for an extistential test it means `satisfied'
+
+  public static final int IGNORE_TEST = -1;
+
+  public static final boolean UNIVERSAL = false;
+  public static final boolean EXISTENTIAL = true;
+
+  private final static int
+  cache_test(final Class c, final int test_index)
+  {
+    if (test_index == IGNORE_TEST)
+      return IGNORE_TEST;
+    else
+      return org.vmmagic.StaticOptTable.registerStaticMethodHook(c, test_index);
+  }
+
+  /**
+   *
+   * If this is a universal family, the predicates must return the negation of whether they apply.  That is,
+   * each test returns true iff the test concludes testing for this predicate family.
+   *
+   * @param c A class containing a static method of signature "(Object, Object[]): boolean" that encodes the test
+   * @param _method_indices list of indices of static methods on class c, or IGNORE_TEST, implementing each predicate
+   * @param _environment Any variables that should be passed into the test as its environment
+   * @param _existential Whether the test is existentially quantified
+   */
+  public PredicateFamily(final Class c,
+			 final int[] _method_indices,
+			 final Object[] _environment,
+			 final boolean _existential)
+  {
+    this.call_address_indices = new int[_method_indices.length];
+    for (int i = 0; i < _method_indices.length; i++)
+      this.call_address_indices[i] = cache_test(c, _method_indices[i]);
+
+    this.environment = _environment;
+    this.existential = _existential;
+  }
+
+
+  // --------------------------------------------------------------------------------
+  // test running
+
+  private final Address
+  lookupTestAddress(final int index)
+  {
+    if (index == IGNORE_TEST)
+      return null;
+    else
+      return org.vmmagic.StaticOptTable.lookupStaticMethodHook(index);
+  }
+
+  /**
+   * Set the predicate (by index) within the family
+   *
+   * @param index Predicate index to set
+   * @return false iff the predicate is trivial (in that case, the predicate's test method must not be called)
+   */
+  final boolean
+  prepareTest(int index)
+  {
+    this.current_address = lookupTestAddress(this.call_address_indices[index]);
+    return this.shouldBeTested();
+  }
+
+  /**
+   * Run the relevant test
+   *
+   * @param node The node to test
+   * @return true iff the predicate family is definitely satisfied/dissatisfied and needs not to be tested anymore
+   */
+  @Inline
+  public final boolean
+  test(final Object node)
+  {
+    if (org.vmmagic.StaticOptTable.invokeStaticMethod(node, this.environment, this.current_address)) {
+      // set the following to trigger NPEs to make sure that `Assertion' doesn't forget to take care of them
+//       Log.write("Finished on: ");
+//       Log.writeln(ObjectReference.fromObject(node));
+    
+      this.current_address = null;
+      this.completed = true;
+      return true;
+    }
+    return false;
+  }
+
+  /**
+   * Compute the boolean valuation of this predicate family
+   *
+   * Only meaningful after all traversals have been completed.
+   *
+   * @return true iff the predicate family evaluates to `true.'
+   */
+  public final boolean
+  value()
+  {
+    return this.existential == this.completed; // We EITHER found a witness for an existential test OR no counter-example for a universal test.
+  }
+
+  /**
+   * Determine whether the selected predicate in this predicate family can and should be tested
+   *
+   * @return true iff this predicate family should be tested
+   */
+  @Inline
+  public final boolean
+  shouldBeTested()
+  {
+    return !this.completed && this.current_address != null;
+  }
+
+  /**
+   * determine whether this is an existential test
+   */
+  @Inline
+  public final boolean
+  isExistential()
+  {
+    return this.existential;
+  }
+}
+
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/SetTraversalIdStep.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/SetTraversalIdStep.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/SetTraversalIdStep.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/SetTraversalIdStep.java	2010-03-03 16:17:08.000000000 +0000
@@ -0,0 +1,45 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+import org.mmtk.plan.marksweep.gcassertions.*;
+import org.vmmagic.pragma.*;
+import org.vmmagic.unboxed.*;
+
+import org.mmtk.utility.Log;
+import org.mmtk.vm.VM;
+
+
+/**
+ * Assertion step.  One part of assertion execution.
+ *
+ */
+@Uninterruptible
+public final class SetTraversalIdStep extends Step
+{
+  private int traversal_id;
+
+  public SetTraversalIdStep(final int _traversal_id)
+  {
+    this.traversal_id = _traversal_id;
+  }
+
+  public boolean
+  run(final GCAssertionsCollector _collector)
+  {
+    Assertion.assertion.traversal_id = this.traversal_id;
+    _collector.setTraversalId(this.traversal_id);
+    return false;
+  }
+}
+
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/SetTraversalPredicatesStep.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/SetTraversalPredicatesStep.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/SetTraversalPredicatesStep.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/SetTraversalPredicatesStep.java	2010-02-19 14:53:17.000000000 +0000
@@ -0,0 +1,46 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+import org.mmtk.plan.marksweep.gcassertions.*;
+import org.vmmagic.pragma.*;
+import org.vmmagic.unboxed.*;
+
+import org.mmtk.utility.Log;
+import org.mmtk.vm.VM;
+
+
+/**
+ * Assertion step.  One part of assertion execution.
+ *
+ * Selects a check pair to be installed for the next traversal, and indicates
+ * whether the check pair should use its external or its internal component.
+ */
+@Uninterruptible
+public final class SetTraversalPredicatesStep extends Step {
+  private final int[] indices;
+
+  public
+  SetTraversalPredicatesStep(final int[] indices)
+  {
+    this.indices = indices;
+  }
+
+  public boolean
+  run(final GCAssertionsCollector _collector)
+  {
+    Assertion.getAssertion().setPredicateFamilyIndexVector(this.indices);
+    return false;
+  }
+}
+
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/Step.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/Step.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/Step.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/Step.java	2010-02-19 14:53:17.000000000 +0000
@@ -0,0 +1,39 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+import org.mmtk.plan.marksweep.gcassertions.*;
+import org.vmmagic.pragma.*;
+import org.vmmagic.unboxed.*;
+
+import org.mmtk.utility.Log;
+import org.mmtk.vm.VM;
+
+
+/**
+ * Assertion step.  One part of assertion execution.
+ *
+ */
+@Uninterruptible
+public abstract class Step {
+
+  /**
+   * Execute the step for the given collector and indicate whether a closure is requested.
+   *
+   * @param _collector The collector to execute the assertion step for.
+   * @return true iff this execution should be followed by heap closure.
+   */
+  public abstract boolean
+  run(final GCAssertionsCollector _collector);
+}
+
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/TestExpr.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/TestExpr.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/TestExpr.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/TestExpr.java	2010-02-19 14:53:17.000000000 +0000
@@ -0,0 +1,59 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+import org.mmtk.plan.marksweep.gcassertions.*;
+import org.vmmagic.pragma.*;
+import org.vmmagic.unboxed.*;
+
+import org.mmtk.utility.Log;
+import org.mmtk.vm.VM;
+
+
+/**
+ * Boolean expression, tests for certain properties.
+ *
+ */
+@Uninterruptible
+public abstract class TestExpr
+{
+  /**
+   *
+   */
+  public abstract boolean
+  eval();
+
+  public TestExpr
+  touchedTraversal(final int index)
+  {
+    return new TestExpr() {
+      public boolean eval() { return Assertion.getAssertion().traversalOverlapped(index); }
+    };
+  }
+
+  public TestExpr
+  literal(final boolean v)
+  {
+    return new TestExpr() {
+      public boolean eval() { return v; }
+    };
+  }
+
+  public TestExpr
+  negate(final TestExpr e)
+  {
+    return new TestExpr() {
+      public boolean eval() { return !e.eval(); }
+    };
+  }
+}
\ No newline at end of file
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/TrackObjectStep.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/TrackObjectStep.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/TrackObjectStep.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/TrackObjectStep.java	2010-02-19 14:53:17.000000000 +0000
@@ -0,0 +1,55 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+import org.mmtk.plan.marksweep.gcassertions.*;
+import org.vmmagic.pragma.*;
+import org.vmmagic.unboxed.*;
+
+import org.mmtk.utility.Log;
+import org.mmtk.vm.VM;
+
+
+/**
+ * Assertion step.  One part of assertion execution.
+ *
+ * Tracks a specified object:  if we encounter this object at any time, we will set the flag at the index specified within.
+ *
+ * Not yet implemented, and left out for simplicity for now.
+ */
+@Uninterruptible
+public abstract class TrackObjectStep extends Step {
+  private final Object tracee;
+  private final int flag_nr;
+
+  /**
+   * @param _obj The object to keep on the lookout for
+   * @param _flag_nr Number of the flag to toggle if the object is encountered
+   */
+  public
+  TrackObjectStep(final Object _obj, final int _flag_nr)
+  {
+    this.tracee = _obj;
+    this.flag_nr = _flag_nr;
+  }
+
+  /**
+   * Execute the step for the given collector and indicate whether a closure is requested.
+   *
+   * @param _collector The collector to execute the assertion step for.
+   * @return true iff this execution should be followed by heap closure.
+   */
+  public abstract boolean
+  run(final GCAssertionsCollector _collector);
+}
+
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/TraversalStep.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/TraversalStep.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/TraversalStep.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/plan/marksweep/gcassertions/spec/TraversalStep.java	2010-03-22 22:50:33.000000000 +0000
@@ -0,0 +1,59 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Common Public License (CPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/cpl1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.plan.marksweep.gcassertions.spec;
+
+import org.mmtk.plan.marksweep.gcassertions.*;
+import org.vmmagic.pragma.*;
+import org.vmmagic.unboxed.*;
+
+import org.mmtk.utility.Log;
+import org.mmtk.vm.VM;
+
+
+/**
+ * Assertion step.  One part of assertion execution.
+ *
+ * Traversal enqueues the specified node(s) and initiates recursive sweeps.
+ */
+@Uninterruptible
+public final class TraversalStep extends Step {
+  private final Object[] nodes;
+
+  /**
+   * Traverse the specified nodes.
+   */
+  public TraversalStep(final Object[] _nodes)
+  {
+    this.nodes = _nodes;
+  }
+
+  /**
+   * Traverse the root set.
+   */
+  public TraversalStep()
+  {
+    this.nodes = null;
+  }
+
+  public boolean
+  run(final GCAssertionsCollector _collector)
+  {
+    if (this.nodes == null)
+      _collector.enqueueRootSet();
+    else for (Object obj : this.nodes)
+	   if (obj != null)
+	     _collector.enqueueNodeForCollection(obj);
+    return true; // demand closure
+  }
+}
+
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/policy/MarkSweepSpace.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/policy/MarkSweepSpace.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/policy/MarkSweepSpace.java	2009-04-24 15:00:43.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/policy/MarkSweepSpace.java	2010-06-20 21:09:27.000000000 +0000
@@ -14,11 +14,13 @@
 
 import org.mmtk.plan.Plan;
 import org.mmtk.plan.TransitiveClosure;
+import org.mmtk.plan.marksweep.gcassertions.GCAssertionsTraceLocal;
 import org.mmtk.utility.heap.*;
 import org.mmtk.utility.options.Options;
 import org.mmtk.utility.options.MarkSweepMarkBits;
 import org.mmtk.utility.options.EagerCompleteSweep;
 import org.mmtk.utility.Constants;
+import org.mmtk.utility.Log;
 
 import org.mmtk.vm.VM;
 
@@ -48,7 +50,7 @@
    */
   public static final boolean HEADER_MARK_BITS = VM.config.HEADER_MARK_BITS;
   /** highest bit bits we may use */
-  private static final int MAX_BITS = 4;
+  private static final int MAX_BITS = 4 - Plan.EXTRA_RESERVED_BITS;
 
   /* mark bits */
   private static final int COUNT_BASE = 0;
@@ -262,6 +264,10 @@
       Word markValue = Plan.NEEDS_LOG_BIT_IN_HEADER ? markState.or(Plan.UNLOGGED_BIT) : markState;
       if (testAndMark(object, markValue)) {
         markBlock(object);
+// 	      Log.write("MARKED: ");
+// 	      Log.write(object);
+// 	      Log.write(", ");
+// 	      Log.writeln(isLive(object));
         trace.processNode(object);
       }
     } else {
@@ -271,6 +277,66 @@
     }
     return object;
   }
+
+  /**
+   * Marks an object reference as having been reached
+   *
+   * This only works correctly if HEADER_MARK_BITS is set.
+   *
+   * @param object The object reference to tag
+   */
+  @Inline
+  public void
+  mark(ObjectReference object)
+  {
+    final Word markValue = Plan.NEEDS_LOG_BIT_IN_HEADER ? markState.or(Plan.UNLOGGED_BIT) : markState;
+    final int oldValue = VM.objectModel.readAvailableByte(object);
+    VM.objectModel.writeAvailableByte(object, (byte)((oldValue & ~MARK_BITS_MASK.toInt()) | markValue.toInt()));
+  }
+
+  /**
+   * Marks an object reference as not having been reached
+   *
+   * This only works correctly if HEADER_MARK_BITS is set.
+   *
+   * @param object The object reference to untag
+   */
+  @Inline
+  public void
+  unmark(ObjectReference object)
+  {
+    final int oldValue = VM.objectModel.readAvailableByte(object);
+    VM.objectModel.writeAvailableByte(object, (byte)((oldValue & ~MARK_BITS_MASK.toInt()) | allocState.toInt()));
+  }
+
+  /**
+   * Trace a reference to an object under a mark sweep collection
+   * policy.  If the object header is not already marked, mark the
+   * object in either the bitmap or by moving it off the treadmill,
+   * and enqueue the object for subsequent processing. The object is
+   * marked as (an atomic) side-effect of checking whether already
+   * marked.
+   *
+   * @param object The object to be traced.
+   * @return The object (there is no object forwarding in this
+   * collector, so we always return the same object: this could be a
+   * void method but for compliance to a more general interface).
+   */
+  @Inline
+  public ObjectReference traceOwneeObject(GCAssertionsTraceLocal trace, ObjectReference object) {
+    if (HEADER_MARK_BITS) {
+      Word markValue = Plan.NEEDS_LOG_BIT_IN_HEADER ? markState.or(Plan.UNLOGGED_BIT) : markState;
+      if (testAndMark(object, markValue)) {
+        markBlock(object);
+//        trace.processOwnee(object);
+      }
+//     } else {
+//       if (testAndSetLiveBit(object)) {
+//         trace.processOwnee(object);
+//       }
+    }
+    return object;
+  }
 
   /**
    *
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/utility/ArrayHelpers.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/utility/ArrayHelpers.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/utility/ArrayHelpers.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/utility/ArrayHelpers.java	2009-08-25 17:59:56.000000000 +0000
@@ -0,0 +1,81 @@
+package org.mmtk.utility;
+
+import org.mmtk.vm.VM;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.AddressArray;
+
+
+/**
+ * This is a helper class to handle sorting operations on AddressArrays 
+ * and ObjectReferenceArrays.  If we were doing this in a nice object-
+ * oriented way, we would extend AddressArray and ObjectReferenceArray.
+ * But because they are "magic" types, I am not sure if we can do that.
+ */
+public class ArrayHelpers {
+
+  /**
+   * Given a sorted AddressArray and a target value, returns the index 
+   * of the last occurrence of the value in it.
+   * 
+   * If the target value is not in the array, returns the index of
+   * the last Address *less* than this object in the array. 
+   * 
+   * @param arr The AddressArray to search
+   * @param arrEnd The length of the array (1+the index of the last element)
+   * @param value The Address to search for
+   * @return If the target value is in the array, the index of that value. If not,
+   * the index of the last Address less than the target value.
+   */
+  @Uninterruptible
+  public static int findSorted(AddressArray arr, int arrEnd, Address value) {
+    
+    int high = arrEnd, low = -1, mid;
+    while (high - low > 1) {
+      mid = (low + high)/2;
+      if (arr.get(mid).toWord().GT(value.toWord())) {
+        high = mid;
+      } else {
+        low = mid;
+      }
+    }
+
+    /* if the value was found, low points to it.  if it was not found
+     * low points to the last array value smaller than the target.
+     */
+    return low;
+
+  }
+  
+  /**
+   * Given a sorted AddressArray and a value to insert, inserts
+   * the value at the correct place in the array to maintain
+   * the sort.  Does not insert if the value is already in the array.
+   * Assumes there is enough room in the array to add one element.
+   * 
+   * @param arr The AddressArray to insert into
+   * @param arrEnd The length of the array (1+the index of the last element)
+   * @param value The Address to insert
+   * @return True if the value was inserted, false if it already existed
+   * in the array
+   */
+  @Uninterruptible
+  public static boolean insertSorted(AddressArray arr, int arrEnd, Address value) {
+    
+    // check that there is room in the array for this insertion
+    if (VM.VERIFY_ASSERTIONS) VM.assertions._assert(arrEnd < arr.length());
+        
+    int index = findSorted(arr, arrEnd, value);
+    if ((index >= 0) && (arr.get(index) == value)) {
+      return false;
+    } else {
+      for (int i=arrEnd-1; i>index; i--) {
+        arr.set(i+1, arr.get(i));
+      }
+      arr.set(index+1, value);
+      return true;
+    }
+  }
+    
+  
+}
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/utility/deque/SharedDeque.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/utility/deque/SharedDeque.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/utility/deque/SharedDeque.java	2009-04-24 15:00:43.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/utility/deque/SharedDeque.java	2009-08-25 17:59:57.000000000 +0000
@@ -251,7 +251,10 @@
       if (VM.VERIFY_ASSERTIONS) VM.assertions._assert(tail.isZero() && head.isZero());
       // no buffers available
       if (waiting) {
-        int ordinal = TRACE ? 0 : VM.activePlan.collector().getId();
+        int ordinal = 0;
+        if (!TRACE && VM.activePlan.collector() != null) {
+          ordinal = VM.activePlan.collector().getId();
+        }
         setNumConsumersWaiting(numConsumersWaiting + 1);
         while (rtn.isZero()) {
           if (numConsumersWaiting == numConsumers)
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/utility/options/GCAssertionsCollectionFrequency.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/utility/options/GCAssertionsCollectionFrequency.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/utility/options/GCAssertionsCollectionFrequency.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/utility/options/GCAssertionsCollectionFrequency.java	2010-03-19 12:57:28.000000000 +0000
@@ -0,0 +1,29 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.utility.options;
+
+import org.vmmagic.unboxed.Address;
+
+/**
+ * 
+ */
+public final class GCAssertionsCollectionFrequency extends org.vmutil.options.IntOption {
+  /**
+   * Create the option
+   */
+  public GCAssertionsCollectionFrequency() {
+    super(Options.set, "assertFrequency",
+          "Frequency of GC assertions collections. -1: never, 0: always (default), n: every (n+1)th opportunity",
+	  0);
+  }
+}
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/utility/options/GCAssertionsCollectionOnPressure.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/utility/options/GCAssertionsCollectionOnPressure.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/utility/options/GCAssertionsCollectionOnPressure.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/utility/options/GCAssertionsCollectionOnPressure.java	2010-03-19 12:57:43.000000000 +0000
@@ -0,0 +1,27 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.mmtk.utility.options;
+
+/**
+ * 
+ */
+public final class GCAssertionsCollectionOnPressure extends org.vmutil.options.BooleanOption {
+  /**
+   * Create the option.
+   */
+  public GCAssertionsCollectionOnPressure() {
+    super(Options.set, "assertOnHeapFull",
+          "If we would not normally collect already (cg. assertFrequency), check heap pressure with the usual heuristics to decide collection (default: false)",
+          false);
+  }
+}
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/utility/options/GCAssertionsDummy.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/utility/options/GCAssertionsDummy.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/utility/options/GCAssertionsDummy.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/utility/options/GCAssertionsDummy.java	2010-03-22 12:32:20.000000000 +0000
@@ -0,0 +1,15 @@
+package org.mmtk.utility.options;
+
+import org.mmtk.utility.options.Options;
+
+public final class GCAssertionsDummy extends org.vmutil.options.EnumOption {
+  /**
+   * Create the option.
+   */
+  public GCAssertionsDummy() {
+    super(Options.set, "Dummy GCAssertion",
+          "Use this to select a dummy whole-heap query to run",
+          new String[] {"NONE", "ALWAYS_TRUE", "ALWAYS_TRUE_WITH_TRAVERSAL_ID", "INSTANCEOF", "INSTANCEOF_WITH_TRAVERSAL_ID"},
+          "NONE");
+  }
+}
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/utility/options/Options.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/utility/options/Options.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/utility/options/Options.java	2009-04-24 15:00:43.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/utility/options/Options.java	2010-03-22 12:32:20.000000000 +0000
@@ -21,6 +21,9 @@
   public static OptionSet set;
 
   /* Other options */
+  public static GCAssertionsDummy dummyAssertion;
+  public static GCAssertionsCollectionOnPressure assertOnHeapFull;
+  public static GCAssertionsCollectionFrequency assertFrequency;
   public static BoundedNursery boundedNursery;
   public static ConcurrentTrigger concurrentTrigger;
   public static CycleFilterThreshold cycleFilterThreshold;
@@ -55,6 +58,8 @@
   public static NurserySize nurserySize;
   public static PerfMetric perfMetric;
   public static PrintPhaseStats printPhaseStats;
+  public static PrintGCAssertionsWarnings printGCAssertionsWarnings;
+  public static PrintGCAssertionsStats printGCAssertionsStats;
   public static ProtectOnRelease protectOnRelease;
   public static SanityCheck sanityCheck;
   public static StressFactor stressFactor;
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/utility/options/PrintGCAssertionsStats.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/utility/options/PrintGCAssertionsStats.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/utility/options/PrintGCAssertionsStats.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/utility/options/PrintGCAssertionsStats.java	2009-08-25 17:59:56.000000000 +0000
@@ -0,0 +1,14 @@
+package org.mmtk.utility.options;
+
+public class PrintGCAssertionsStats extends org.vmutil.options.BooleanOption {
+  
+  /**
+   * Create the option.
+   */
+  public PrintGCAssertionsStats() {
+    super(Options.set, "Print GCAssertions Stats",
+          "Should we print GC Assertions statistics?",
+        false);
+  }
+
+}
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/utility/options/PrintGCAssertionsWarnings.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/utility/options/PrintGCAssertionsWarnings.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/utility/options/PrintGCAssertionsWarnings.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/utility/options/PrintGCAssertionsWarnings.java	2009-08-25 17:59:56.000000000 +0000
@@ -0,0 +1,14 @@
+package org.mmtk.utility.options;
+
+public class PrintGCAssertionsWarnings extends org.vmutil.options.BooleanOption {
+  
+  /**
+   * Create the option.
+   */
+  public PrintGCAssertionsWarnings() {
+    super(Options.set, "Print GCAssertions Warnings",
+          "Should we print GC Assertions warnings?",
+        true);
+  }
+
+}
diff -ruN jikesrvm-3.1.0/MMTk/src/org/mmtk/vm/ObjectModel.java jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/vm/ObjectModel.java
--- jikesrvm-3.1.0/MMTk/src/org/mmtk/vm/ObjectModel.java	2009-04-24 15:00:43.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/MMTk/src/org/mmtk/vm/ObjectModel.java	2010-02-10 15:35:41.000000000 +0000
@@ -253,4 +253,6 @@
   static Offset arrayBaseOffsetTrapdoor(ObjectModel o) {
     return o.getArrayBaseOffset();
   }
+  
+  /* GCAssertions methods - used to implement assert-instances() */
 }
diff -ruN jikesrvm-3.1.0/Makefile jikesrvm-3.1.0-gcassertions/Makefile
--- jikesrvm-3.1.0/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/Makefile	2010-02-07 13:32:55.000000000 +0000
@@ -0,0 +1,66 @@
+# Default to basebase configuration
+#CP=${CLASSPATH}:target/BaseBaseGCAssertions_x86_64-linux/jksvm.jar:.
+#JAVAC=javac -classpath ${CP}
+#JAVA=./dist/BaseBaseGCAssertions_x86_64-linux/rvm -classpath ${CP}
+JAVA=JAVA
+JAVAC=JAVAC
+
+.PHONY: default basebase fastadaptive bytecode-verifier
+
+default: basebase
+
+basebase: CP="${CLASSPATH}:target/BaseBaseGCAssertions_x86_64-linux/jksvm.jar:."
+basebase: JAVAC=javac -classpath ${CP}
+basebase: JAVA="./dist/BaseBaseGCAssertions_x86_64-linux/rvm"
+basebase: all-tests
+
+fastadaptive: CP = "${CLASSPATH}:target/FastAdaptiveGCAssertions_x86_64-linux/jksvm.jar:."
+fastadaptive: JAVAC = javac -classpath ${CP}
+fastadaptive: JAVA = "./dist/FastAdaptiveGCAssertions_x86_64-linux/rvm"
+fastadaptive: all-tests
+
+all-tests: gtest/Tests.class gtest/TestHarness.class
+	${JAVA} gtest.TestHarness gtest.Tests gtest.Tests
+
+bytecode-verifier: CP="${CLASSPATH}:../../../target/BaseBaseGCAssertions_x86_64-linux/jksvm.jar:."
+bytecode-verifier: JAVAC=javac -classpath ${CP}
+bytecode-verifier: JAVA=../../../dist/BaseBaseGCAssertions_x86_64-linux/rvm -classpath ${CP}
+bytecode-verifier:
+	(cd gtest/bytecode-hack/sound; ${JAVAC} Test.java)
+	(cd gtest/bytecode-hack/unsound; ${JAVAC} C.java; cp ../sound/Test.class .; ${JAVA} Test)
+
+avrora-annot: CP="${CLASSPATH}:target/BaseBaseGCAssertions_x86_64-linux/jksvm.jar:."
+avrora-annot: JAVAC="javac -classpath ${CP}"
+avrora-annot: JAVA="./dist/BaseBaseGCAssertions_x86_64-linux/rvm"
+avrora-annot:
+	${JAVA} -jar dacapo-9.12-bach.jar -c MMTkCallback avrora
+
+avrora-ms: CP="${CLASSPATH}:target/BaseBaseMarkSweep_x86_64-linux/jksvm.jar:."
+avrora-ms: JAVAC="javac -classpath ${CP}"
+avrora-ms: JAVA="./dist/BaseBaseMarkSweep_x86_64-linux/rvm"
+avrora-ms:
+	${JAVA} -jar dacapo-9.12-bach.jar -c MMTkCallback avrora
+#	${JAVA} -jar dacapo-9.12-bach.jar avrora
+
+avrora-fa-annot: CP="${CLASSPATH}:target/FastAdaptiveGCAssertions_x86_64-linux/jksvm.jar:."
+avrora-fa-annot: JAVAC="javac -classpath ${CP}"
+avrora-fa-annot: JAVA="./dist/FastAdaptiveGCAssertions_x86_64-linux/rvm"
+avrora-fa-annot:
+	${JAVA} -jar dacapo-9.12-bach.jar -c MMTkCallback avrora
+
+avrora-fa-ms: CP="${CLASSPATH}:target/FastAdaptiveMarkSweep_x86_64-linux/jksvm.jar:."
+avrora-fa-ms: JAVAC="javac -classpath ${CP}"
+avrora-fa-ms: JAVA="./dist/FastAdaptiveMarkSweep_x86_64-linux/rvm"
+avrora-fa-ms:
+	${JAVA} -jar dacapo-9.12-bach.jar -c MMTkCallback avrora
+#	${JAVA} -jar dacapo-9.12-bach.jar avrora
+
+avrora-gen: CP="${CLASSPATH}:target/BaseBaseGenMS_x86_64-linux/jksvm.jar:."
+avrora-gen: JAVAC="javac -classpath ${CP}"
+avrora-gen: JAVA="./dist/BaseBaseGenMS_x86_64-linux/rvm"
+avrora-gen:
+	${JAVA} -jar dacapo-9.12-bach.jar -c MMTkCallback avrora
+#	${JAVA} -jar dacapo-9.12-bach.jar avrora
+
+%.class: %.java
+	${JAVAC} $<
diff -ruN jikesrvm-3.1.0/average.awk jikesrvm-3.1.0-gcassertions/average.awk
--- jikesrvm-3.1.0/average.awk	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/average.awk	2010-02-21 23:01:32.000000000 +0000
@@ -0,0 +1,27 @@
+#! /usr/bin/awk -f
+
+BEGIN {
+  accumulator = 0.0;
+  count = 0;
+}
+
+{
+  data[count++] = $1;
+  accumulator += $1;
+}
+
+END {
+  mean = accumulator / count;
+
+  variance_sum = 0.0;
+  for (i = 0; i < count; i++) {
+    delta = (data[i] - mean);
+    variance_sum = delta*delta;
+  }
+  variance = variance_sum / count;
+
+  printf "mean     \t%f\n", mean;
+  printf "variance \t%f\n", variance;
+  printf "standard-dev\t%f\n", sqrt(variance);
+}
+
diff -ruN jikesrvm-3.1.0/benchmark.sh jikesrvm-3.1.0-gcassertions/benchmark.sh
--- jikesrvm-3.1.0/benchmark.sh	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/benchmark.sh	2010-02-23 12:38:51.000000000 +0000
@@ -0,0 +1,33 @@
+#! /bin/sh
+HEAPSIZE=150m
+
+# Apologies for the spaghetti style, but this was a command-line one-liner.
+
+# Varying the environment, as per Todd Mytkowicz, Amer Diwan, Matthias Hauswirth, Peter F. Sweeney: "Producing wrong data without doing anything obviously wrong!" ASPLOS 2009: 265-276
+
+mkdir bench
+
+export PADDING=0000000
+for n in `seq 0 63`
+do  PADDING=${PADDING}00000000
+    for B in avrora luindex lusearch pmd sunflow xalan
+    do  for K in "ms" "gca" "gca1" "gca2"
+	do  G=""
+
+	    if [ $K == gca1 ]
+	    then G=-X:gc:dummyGCAssertion=true
+	    fi
+
+	    if [ $K == gca2 ]
+	    then G="-X:gc:dummyGCAssertionwithtraversalID=true -X:gc:dummyGCAssertion=true"
+	    fi
+
+	    VM="GCAssertions"
+	    if [ $K == ms ]
+	    then VM="MarkSweep"
+	    fi
+
+	    ./dist/FastAdaptive${VM}_x86_64-linux/rvm  -Xms${HEAPSIZE} -Xmx${HEAPSIZE} -X:gc:variableSizeHeap=false $G -jar dacapo-9.12-bach.jar -c MMTkCallback -n 4 $B >& bench/${B}.${K}.${n}; echo $n $B $VM $K
+	done
+    done
+done
diff -ruN jikesrvm-3.1.0/benchmark2.sh jikesrvm-3.1.0-gcassertions/benchmark2.sh
--- jikesrvm-3.1.0/benchmark2.sh	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/benchmark2.sh	2010-03-20 15:51:53.000000000 +0000
@@ -0,0 +1,33 @@
+#! /bin/sh
+HEAPSIZE=150m
+
+# Apologies for the spaghetti style, but this was a command-line one-liner.
+
+# Varying the environment, as per Todd Mytkowicz, Amer Diwan, Matthias Hauswirth, Peter F. Sweeney: "Producing wrong data without doing anything obviously wrong!" ASPLOS 2009: 265-276
+
+mkdir bench
+
+export PADDING=0000000
+for n in `seq 0 3`
+do  PADDING=${PADDING}00000000
+    for B in luindex lusearch pmd sunflow xalan
+    do  for K in "gca1" "gca3"
+	do  G=""
+
+	    if [ $K == gca1 ]
+	    then G=-X:gc:dummyGCAssertion=true
+	    fi
+
+	    if [ $K == gca3 ]
+	    then G="-X:gc:dummyGCAssertionwithinstanceof=true"
+	    fi
+
+	    VM="GCAssertions"
+	    if [ $K == ms ]
+	    then VM="MarkSweep"
+	    fi
+
+	    ./dist/FastAdaptive${VM}_x86_64-linux/rvm  -Xms${HEAPSIZE} -Xmx${HEAPSIZE} -X:gc:variableSizeHeap=false $G -jar dacapo-9.12-bach.jar -c MMTkCallback -n 4 $B >& bench/${B}.${K}.${n}; echo $n $B $VM $K
+	done
+    done
+done
diff -ruN jikesrvm-3.1.0/benchmarking/BmConfig.pm jikesrvm-3.1.0-gcassertions/benchmarking/BmConfig.pm
--- jikesrvm-3.1.0/benchmarking/BmConfig.pm	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/benchmarking/BmConfig.pm	2010-03-18 15:08:38.000000000 +0000
@@ -0,0 +1,72 @@
+package BmConfig;
+use strict;
+
+require Exporter;
+our @ISA = qw{Exporter};
+our @EXPORT = qw{ gen_command_line 
+                  $jvm98_dir 
+                  $dacapo2006_dir
+                  $dacapo2009_dir
+                  $pjbb2000_dir     };
+
+# where are the benchmarks?
+my $home_dir = $ENV{"HOME"};
+our $jvm98_dir = "$home_dir/SPECjvm98";
+our $dacapo2006_dir = "$home_dir/dacapo";
+our $dacapo2009_dir = "$home_dir/dacapo-9.12";
+our $pjbb2000_dir = "$home_dir/pseudojbb/src";
+
+# arguments for both the rvm and the benchmarks
+my $rvm_args = "-X:gc:variableSizeHeap=false";
+my $jvm98_args = "-s100";   # use largest input size
+my $dacapo2006_args = "-c MMTkCallback";
+my $dacapo2009_args = "-c MMTkCallback";
+my $pjbb2000_args = "-propfile SPECjbb.props";
+
+# arguments:
+#   $bmgroup = one of "jvm98", "dacapo2006", "dacapo2009", "pjbb2000"
+#   $configurations = a reference to a hash of configurations
+#   $config = the Jikes RVM configuration to use
+#   $benchmark = benchmark to run
+#   $heap_size = heap size to use
+#   $iterations = number of iterations within a single invocation
+sub gen_command_line {
+  my ($bmgroup, $configurations, $config, $benchmark, $heap_size, $iterations) = @_;
+
+  if ($bmgroup eq "jvm98") {
+    my $cmdline = "$home_dir/$configurations->{$config}[0]/dist/$configurations->{$config}[1]_ia32-linux/rvm -Xms${heap_size}M -Xmx${heap_size}M $configurations->{$config}[2] ";
+    $cmdline .= "$rvm_args ";
+    $cmdline .= "SpecApplication ";
+    $cmdline .= "$jvm98_args ";
+    $cmdline .= "$benchmark " x ($iterations-1);
+    $cmdline .= "_997_begin $benchmark _998_end ";
+  } elsif ($bmgroup eq "dacapo2006") {
+    my $cmdline = "";
+    if ($benchmark eq "chart") {
+      # special case chart -- have to run with xvfb
+      $cmdline .= "xvfb-run ";
+    }
+    $cmdline .= "$home_dir/$configurations->{$config}[0]/dist/$configurations->{$config}[1]_ia32-linux/rvm -Xms${heap_size}M -Xmx${heap_size}M $configurations->{$config}[2] ";
+    $cmdline .= "$rvm_args ";
+    $cmdline .= "-jar dacapo-2006-10-MR2.jar ";
+    $cmdline .= "$dacapo2006_args ";
+    $cmdline .= "-n $iterations ";
+    $cmdline .= "$benchmark ";
+  } elsif ($bmgroup eq "dacapo2009") {
+    my $cmdline = "";
+    $cmdline .= "$home_dir/$configurations->{$config}[0]/dist/$configurations->{$config}[1]_ia32-linux/rvm -Xms${heap_size}M -Xmx${heap_size}M $configurations->{$config}[2] ";
+    $cmdline .= "$rvm_args ";
+    $cmdline .= "-jar dacapo-9.12-bach.jar ";
+    $cmdline .= "$dacapo2009_args ";
+    $cmdline .= "-n $iterations ";
+    $cmdline .= "$benchmark ";
+  } elsif ($bmgroup eq "pjbb2000") {
+    my $cmdline = "$home_dir/$configurations->{$config}[0]/dist/$configurations->{$config}[1]_ia32-linux/rvm -Xms${heap_size}M -Xmx${heap_size}M $configurations->{$config}[2] ";
+    $cmdline .= "$rvm_args ";
+    $cmdline .= "spec.jbb.JBBmain ";
+    $cmdline .= "$pjbb2000_args ";
+    $cmdline .= "-iterations $iterations ";
+  } else {
+    die "Benchmark group $bmgroup not supported";
+  }
+}
diff -ruN jikesrvm-3.1.0/benchmarking/README.txt jikesrvm-3.1.0-gcassertions/benchmarking/README.txt
--- jikesrvm-3.1.0/benchmarking/README.txt	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/benchmarking/README.txt	2010-03-18 15:08:38.000000000 +0000
@@ -0,0 +1,40 @@
+Eddie Aftandilian
+eaftan@cs.tufts.edu
+
+This directory contains scripts to automate benchmarking Jikes RVM.  These 
+scripts support running and analyzing 4 different benchmark suites:
+- SPEC JVM 98
+- Pseudo JBB 2000
+- Dacapo 2006 MR2
+- Dacapo 9.12 (2009 release)
+We may want to consider supporting SPEC JBB 2005 and SPEC JVM 2008 in 
+the future.
+
+find_min_heap_sizes.pl finds the minimum heap size for each benchmark for
+a given set of configurations of Jikes RVM.  It has a 20-minute timeout
+per invocation to catch JVM nontermination.  However, it a benchmark fails
+repeatedly (i.e. Jikes RVM just won't run that benchmark), the script will 
+not terminate.
+Usage: ./find_min_heap_sizes.pl > min_heap_sizes.txt
+
+run_benchmarks.pl runs the benchmarks.  It runs each benchmark through 4 
+iterations, timing only the last one, and repeats 20 times to reduce 
+variation from the adaptive optimizer.  Methodology was suggested by Steve 
+Blackburn via email.  Results include the full output from each benchmark run 
+and are stored in the current directory under "results."
+
+compile_results.pl takes the output from the run scripts and compiles them 
+into summaries, computing the mean, standard deviation, and 90% confidence 
+intervals for all the different time values we have.
+
+Order of use:
+1) Find minimum heap sizes, if not done already:
+   find_min_heap_sizes.pl > min_heap_sizes.txt
+2) Update run_benchmarks.pl with minimum heap sizes.
+3) run_benchmarks.pl
+4) compile_results.pl [results dir] > output_all.txt
+
+TODO: Currently we have scripts that normalize data against the Base 
+configuration and output jgraph files that we can render to EPS or PDF.  In
+these scripts, the names of the configurations are hardcoded.  We may want
+to make them configurable via the command line or a configuration file.
diff -ruN jikesrvm-3.1.0/benchmarking/Stats.pm jikesrvm-3.1.0-gcassertions/benchmarking/Stats.pm
--- jikesrvm-3.1.0/benchmarking/Stats.pm	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/benchmarking/Stats.pm	2010-03-18 15:08:38.000000000 +0000
@@ -0,0 +1,77 @@
+package Stats;
+use strict;
+
+require Exporter;
+our @ISA = qw{Exporter};
+our @EXPORT = qw{average
+       stddev
+       confidence
+       };
+
+sub average {
+  my $sum;
+  my $count;
+  foreach (@_) {
+    $sum += $_;
+  }
+  return $sum/@_;
+}
+
+# For standard deviation, we use "sample standard deviation" since we do not
+# have the whole population.  The formula is:
+# sqrt( sum ((x - m)^2) / (n - 1))
+# where x is each sample, m is the mean, and n is the number of samples
+sub stddev {
+  my $avg = &average(@_);
+  my $temp;
+  foreach (@_) {
+    $temp += ($_ - $avg)**2;  
+  }
+  $temp /= (@_ - 1);
+  return sqrt $temp;
+}
+
+# We compute confidence intervals here using the formulas in Georges et al., 
+# "Statistically Rigorous Java Performance Evaluation."
+# For n <= 30, we base this on a Gaussian distribution; for n < 30, we use a 
+# Student's t-distribution.  We take critical values for the Student's 
+# t-distribution from the Wikipedia page: 
+# http://en.wikipedia.org/wiki/Student%27s_t-distribution
+#
+# Note that the Wikipedia page gives *one-sided* confidence intervals, so we
+# have to halve them to get our confidence intervals.  For example, our 90%
+# confidence interval corresponds to Wikipedia's 95%.
+#
+# Formula for this is as follows:
+# m +- a * s / sqrt(n)
+# where m is the mean, a is the critical number, s is the standard deviation,
+# and n is the number of samples
+# 
+sub confidence {
+  my ($confidence_value, @values) = @_;
+  my $stddev = &stddev(@values);
+  my $n = scalar(@values);
+  my $a = &get_critical_value($n, $confidence_value);
+
+  return $a * $stddev / sqrt($n);
+}
+
+# critical values for Student's t-distribution. for use when n < 30.
+# can fill in more of these as needed.
+my %students_critical_values = (
+  19 => {90 => 1.729, 95 => 2.093, 99 => 2.861},
+);
+
+# critical values for Gaussian distribution. for use when n >= 30
+my %gaussian_critical_values = (90 => 1.645, 95 => 1.960, 99 => 2.576);
+
+
+sub get_critical_value {
+  my ($n, $confidence_value) = @_;
+
+  if ($n >= 30) {
+    return $gaussian_critical_values{$confidence_value};
+  } else {
+    return $students_critical_values{$n-1}->{$confidence_value};
+  }
+}
diff -ruN jikesrvm-3.1.0/benchmarking/TimedSystem.pm jikesrvm-3.1.0-gcassertions/benchmarking/TimedSystem.pm
--- jikesrvm-3.1.0/benchmarking/TimedSystem.pm	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/benchmarking/TimedSystem.pm	2010-03-18 15:08:38.000000000 +0000
@@ -0,0 +1,45 @@
+package TimedSystem;
+use strict;
+use POSIX ":sys_wait_h";
+
+require Exporter;
+our @ISA = qw{Exporter};
+our @EXPORT = qw{ timed_system };
+
+
+# This function works similarly to the standard Perl system function, except
+# it also enforces a timeout on the child process.  It allows you to execute
+# a command line in a different process, and if that process runs longer than
+# the timeout, it kills the process.  The timeout value is in seconds.
+#
+# Returns the exit status if the child exits within the timeout, or -2
+# if the child ran longer than the timeout and was killed.
+#
+# NOTE: The timeout is approximate (within 1-3 seconds).  Do not rely on this 
+# for exact timing.
+sub timed_system {
+
+  my ($cmdline, $timeout) = @_;
+
+  my $pid = fork();
+  if ($pid == 0) {
+    # child
+    exec $cmdline;
+  } else {
+    # parent
+    my $slept = 0;
+    my $died;
+    do {
+      sleep(1);
+      $slept++;
+      $died = waitpid($pid, WNOHANG);
+    } while ($died != $pid && $slept <= $timeout);
+
+    if ($died != $pid) {
+      kill(9, $pid);
+      return(-2);
+    } else {
+      return($?);
+    }
+  }
+}
diff -ruN jikesrvm-3.1.0/benchmarking/compile_results.pl jikesrvm-3.1.0-gcassertions/benchmarking/compile_results.pl
--- jikesrvm-3.1.0/benchmarking/compile_results.pl	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/benchmarking/compile_results.pl	2010-03-18 15:08:38.000000000 +0000
@@ -0,0 +1,159 @@
+#!/usr/bin/perl -w
+use strict;
+
+use Stats;
+use Cwd;
+
+# This script processes the benchmark output files from run_dacapo.pl 
+# and produces a summary of the results.  
+
+my $confidence_value = 90;
+my @benchmarks = ("dacapo2006", "dacapo2009", "jvm98", "pjbb2000");
+my $iterations = 4;
+
+my %gc_counts;
+my %times_total;
+my %times_mutator;
+my %times_gc;
+my %perfs_mutator;
+my %perfs_gc;
+my %times_refType;
+my %times_scan;
+my %times_finalize;
+my %times_prepare;
+my %times_precopy;
+my %times_stacks;
+my %times_root;
+my %times_forward;
+my %times_release;
+my %times_init;
+my %times_finish;
+
+if (@ARGV == 1) {
+  chdir $ARGV[0] or die "Cannot chdir to $ARGV[0]: $!";
+}
+
+# process all benchmark files in directory
+foreach (<*>) {
+  if (/^(\w*)\.(\w*)\.(\w*)\.(\d*)$/) {
+    my $config = $1;
+    my $bmgroup = $2;
+    my $benchmark = $3;
+    my $run_num = $4;
+    my $name = "$config.$bmgroup.$benchmark";
+
+    my $result_ok;    # this is set when we're sure the benchmark succeeded
+    my $mmtk_stats_ok;
+    my $result_count = 0;  # count of number of successful iterations
+
+    # Success is defined as follows:
+    # For Dacapo, we see the string "DaCapo $benchmark PASSED"
+    # For SPECjvm98 and pseudoJBB2000, we see the string "$benchmark Finished"
+    # $iterations times
+    open(INFILE, "<", $_) or die "Cannot open file: $!";
+    while (<INFILE>) {
+      if (/DaCapo $benchmark PASSED/) {
+        $result_ok = 1;
+      } elsif (/$benchmark Finished/) {
+        $result_count++;
+      } elsif (/^=* MMTk Statistics Totals =*$/) {
+        <INFILE>;  # throw away header line
+        my $line = <INFILE>;
+#        print $line;
+        my @mmtk_stats = split /\s+/, $line;
+        push @{ $gc_counts{"$name"} }, shift(@mmtk_stats);
+        push @{ $times_mutator{"$name"} }, shift(@mmtk_stats);
+        push @{ $times_gc{"$name"} }, shift(@mmtk_stats);
+        push @{ $perfs_mutator{"$name"} }, shift(@mmtk_stats);
+        push @{ $perfs_gc{"$name"} }, shift(@mmtk_stats);
+        push @{ $times_refType{"$name"} }, shift(@mmtk_stats);
+        push @{ $times_scan{"$name"} }, shift(@mmtk_stats);
+        push @{ $times_finalize{"$name"} }, shift(@mmtk_stats);
+        push @{ $times_prepare{"$name"} }, shift(@mmtk_stats);
+        push @{ $times_precopy{"$name"} }, shift(@mmtk_stats);
+        push @{ $times_stacks{"$name"} }, shift(@mmtk_stats);
+        push @{ $times_root{"$name"} }, shift(@mmtk_stats);
+        push @{ $times_forward{"$name"} }, shift(@mmtk_stats);
+        push @{ $times_release{"$name"} }, shift(@mmtk_stats);
+        push @{ $times_init{"$name"} }, shift(@mmtk_stats);
+        push @{ $times_finish{"$name"} }, shift(@mmtk_stats);
+
+        # get total time
+        $line = <INFILE>;
+        if ($line =~ /^Total time: ([\d\.]+) ms$/) {
+          push @{ $times_total{"$name"} }, $1;
+          $mmtk_stats_ok = 1;
+        }
+      }
+    }
+    close INFILE;
+
+    # For SPECjvm98 and pseudojbb, we need to make sure all $iterations 
+    # runs succeeded
+    if ((($bmgroup eq "jvm98") || ($bmgroup eq "pjbb2000")) && ($result_count = $iterations)) {
+      $result_ok = 1;
+    }
+
+    if (!$result_ok || !$mmtk_stats_ok) {
+      print "WARNING: $config.$bmgroup.$benchmark.$run_num failed\n";
+    }
+  }
+}
+
+
+foreach (sort keys %times_total) {
+  print "$_\n";
+  print "gc count -- avg " . &average(@{$gc_counts{$_}}) . 
+    ", stddev " . &stddev(@{$gc_counts{$_}}) . 
+    ", confidence " . &confidence($confidence_value, @{$gc_counts{$_}}) . "\n";
+  print "total time -- avg " . &average(@{$times_total{$_}}) . 
+    ", stddev " . &stddev(@{$times_total{$_}}) . 
+    ", confidence " . &confidence($confidence_value, @{$times_total{$_}}) . "\n";
+  print "mutator time -- avg " . &average(@{$times_mutator{$_}}) . 
+    ", stddev " . &stddev(@{$times_mutator{$_}}) . 
+    ", confidence " . &confidence($confidence_value, @{$times_mutator{$_}}) . "\n";
+  print "gc time -- avg " . &average(@{$times_gc{$_}}) . 
+    ", stddev " . &stddev(@{$times_gc{$_}}) . 
+    ", confidence " . &confidence($confidence_value, @{$times_gc{$_}}) . "\n";
+  print "mutator perfctr -- avg " . &average(@{$perfs_mutator{$_}}) . 
+    ", stddev " . &stddev(@{$perfs_mutator{$_}}) .
+    ", confidence " . &confidence($confidence_value, @{$times_mutator{$_}}) . "\n";
+  print "gc perfctr -- avg " . &average(@{$perfs_gc{$_}}) . 
+    ", stddev " . &stddev(@{$perfs_gc{$_}}) . 
+    ", confidence " . &confidence($confidence_value, @{$perfs_gc{$_}}) . "\n";
+  print "refType -- avg " . &average(@{$times_refType{$_}}) . 
+    ", stddev " . &stddev(@{$times_refType{$_}}) . 
+    ", confidence " . &confidence($confidence_value, @{$times_refType{$_}}) . "\n";
+  print "scan -- avg " . &average(@{$times_scan{$_}}) . 
+    ", stddev " . &stddev(@{$times_scan{$_}}) .
+    ", confidence " . &confidence($confidence_value, @{$times_scan{$_}}) . "\n";
+  print "finalize -- avg " . &average(@{$times_finalize{$_}}) . 
+    ", stddev " . &stddev(@{$times_finalize{$_}}) . 
+    ", confidence " . &confidence($confidence_value, @{$times_finalize{$_}}) . "\n";
+  print "prepare -- avg " . &average(@{$times_prepare{$_}}) . 
+    ", stddev " . &stddev(@{$times_prepare{$_}}) .
+    ", confidence " . &confidence($confidence_value, @{$times_prepare{$_}}) . "\n";
+  print "precopy -- avg " . &average(@{$times_precopy{$_}}) . 
+    ", stddev " . &stddev(@{$times_precopy{$_}}) .
+    ", confidence " . &confidence($confidence_value, @{$times_precopy{$_}}) . "\n";
+  print "stacks -- avg " . &average(@{$times_stacks{$_}}) . 
+    ", stddev " . &stddev(@{$times_stacks{$_}}) . 
+    ", confidence " . &confidence($confidence_value, @{$times_stacks{$_}}) . "\n";
+  print "root -- avg " . &average(@{$times_root{$_}}) . 
+    ", stddev " . &stddev(@{$times_root{$_}}) . 
+    ", confidence " . &confidence($confidence_value, @{$times_root{$_}}) . "\n";
+  print "forward -- avg " . &average(@{$times_forward{$_}}) . 
+    ", stddev " . &stddev(@{$times_forward{$_}}) . 
+    ", confidence " . &confidence($confidence_value, @{$times_forward{$_}}) . "\n";
+  print "release -- avg " . &average(@{$times_release{$_}}) . 
+    ", stddev " . &stddev(@{$times_release{$_}}) . 
+    ", confidence " . &confidence($confidence_value, @{$times_release{$_}}) . "\n";
+  print "init -- avg " . &average(@{$times_init{$_}}) . 
+    ", stddev " . &stddev(@{$times_init{$_}}) . 
+    ", confidence " . &confidence($confidence_value, @{$times_init{$_}}) . "\n";
+  print "finish -- avg " . &average(@{$times_finish{$_}}) . 
+    ", stddev " . &stddev(@{$times_finish{$_}}) . 
+    ", confidence " . &confidence($confidence_value, @{$times_finish{$_}}) . "\n";
+  print "\n";
+}
+
diff -ruN jikesrvm-3.1.0/benchmarking/compute_gc_counts.pl jikesrvm-3.1.0-gcassertions/benchmarking/compute_gc_counts.pl
--- jikesrvm-3.1.0/benchmarking/compute_gc_counts.pl	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/benchmarking/compute_gc_counts.pl	2010-03-18 15:08:38.000000000 +0000
@@ -0,0 +1,36 @@
+#!/usr/bin/perl -w
+use strict;
+
+if (@ARGV != 1) {
+  print "Usage: script.pl input_file\n";
+  exit;
+}
+
+open(INFILE, "<", $ARGV[0]) or die "Cannot open file: $!";
+my $curr_config;
+my $curr_benchmark;
+my %results;
+while (<INFILE>) {
+  if (/^(Base|NoAssertions)\.(.+)$/) {
+    $curr_config = $1;
+    $curr_benchmark = $2;
+    if ($curr_benchmark =~ /_[\d]{3}_(\w+)/) {
+      $curr_benchmark = $1;
+    }
+  } elsif (/^gc count -- avg ([\d\.]+), stddev ([\d\.]+)$/) {
+    if ($curr_config eq "Base") {
+      $results{$curr_benchmark}[0] = $1;
+    } elsif ($curr_config eq "NoAssertions") {
+      $results{$curr_benchmark}[1] = $1;
+    } else {
+      print "Error processing line $_: no current config found\n";
+    }
+  } 
+}
+close INFILE;
+
+foreach my $benchmark (sort keys %results) {
+  my $percent_increase = 100 * ($results{$benchmark}[1] - $results{$benchmark}[0]) / $results{$benchmark}[0];
+  print "$benchmark $results{$benchmark}[0] $results{$benchmark}[1] $percent_increase\n";
+}
+
diff -ruN jikesrvm-3.1.0/benchmarking/find_min_heap_sizes.pl jikesrvm-3.1.0-gcassertions/benchmarking/find_min_heap_sizes.pl
--- jikesrvm-3.1.0/benchmarking/find_min_heap_sizes.pl	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/benchmarking/find_min_heap_sizes.pl	2010-03-18 15:08:38.000000000 +0000
@@ -0,0 +1,247 @@
+#!/usr/bin/perl -w
+use strict;
+use BmConfig;
+use Cwd;
+use TimedSystem;
+
+# This script determines the minimum heap size as a multiple of 4 MB for 
+# each benchmark in the SPEC JVM 98, Dacapo 2006, Dacapo 9.12 (2009 release),
+# and Pseudo JBB 2000 suites, for a given set of configurations of Jikes 
+# RVM.
+#
+# We run each benchmark for $iterations iterations because repeating a 
+# benchmark multiple times inside the same JVM instance can increase 
+# memory requirements. 
+#
+# We repeat each benchmark $invocations times because the results were 
+# unstable with only 1 iteration (even with 5 iterations).  We were seeing a 
+# lot of situations where a benchmark would run one time with a certain heap 
+# size but wouldn't run the next.
+#
+# We selected $iterations = 4 and $invocations = 10 to mimic our benchmarking
+# methodology.
+#
+# Usage: ./find_min_heap_sizes.pl [list of benchmarks]
+# Valid benchmark names are jvm98, dacapo2006, dacapo2009, and pjbb2000.
+# If no benchmarks are provided, runs all of them (SPECjvm98, pseudoJBB2000, 
+# Dacapo 2006, and Dacapo 2009).  Otherwise it runs only the ones in the 
+# list.
+#
+# Note that chart from dacapo2006 is a special case in two ways:
+# 1) It requires an X Server, so we start it with xvfb-run.
+# 2) If you run two invocations too close to one another it fails (probably
+#    because of xvfb).  So we sleep for 1 second between invocations.
+
+# benchmark run parameters
+my $iterations = 4;       # number of iterations per benchmark run
+my $invocations = 10;     # number of times to repeat each benchmark
+
+my $min_heap_size = 12;   # Jikes RVM will not boot with an 8 MB heap
+my $timeout = 20 * 60;    # benchmark timeout in seconds
+
+# success strings for each benchmark
+my $jvm98_success = "_998_end Finished";
+my $dacapo2006_success = "PASSED";
+my $dacapo2009_success = "PASSED";
+my $pjbb2000_success = "End MMTk Statistics";
+
+# failure string
+# We record a failure only if it is an OutOfMemoryError.  This is to deal
+# with instability of Jikes RVM itself.
+my $failure_string = "OutOfMemoryError";
+
+# Initial heap size for each benchmark -- we start our search from this
+# heap size.  Initialize this hash with values that should be close to the
+# actual minimum heap size for each benchmark.  This shouldn't affect
+# correctness but will make the search faster.
+my %benchmarks = (
+    jvm98 => {
+      _201_compress => 24,
+      _202_jess => 28,
+      _205_raytrace => 16,
+      _209_db => 24,
+      _213_javac => 36,
+      _222_mpegaudio => 16,
+      _227_mtrt => 16,
+      _228_jack => 32,
+    },
+    dacapo2006 => {
+      antlr => 32,
+      bloat => 68,
+      chart => 52,
+      eclipse => 116,
+      fop => 44,
+      hsqldb => 128,
+      jython => 48,
+      luindex => 56,
+      lusearch => 56,
+      pmd => 56,
+      xalan => 56,
+    },
+    dacapo2009 => {
+      avrora => 100,
+      batik => 100,
+      eclipse => 100,
+      fop => 100,
+      h2 => 100,
+      jython => 100,
+      luindex => 100,
+      lusearch => 100,
+      pmd => 100,
+      sunflow => 100,
+      tomcat => 100,
+      tradebeans => 100,
+      tradesoap => 100,
+      xalan => 100,
+    },
+    pjbb2000 => {
+      pjbb2000 => 64,
+    },
+);
+
+# benchmark setup
+my @bmgroups;
+if (@ARGV > 0) {
+  # check to make sure arguments are all legitimate benchmarks
+  foreach my $bmgroup (@ARGV) {
+    if (not exists $benchmarks{$bmgroup}) {
+      die "Unsupported benchmark: $bmgroup";
+    }
+  }
+  @bmgroups = @ARGV;
+} else {
+  @bmgroups = ("jvm98", "dacapo2006", "dacapo2009", "pjbb2000");
+}
+
+# Provide configurations to test here.  The first string in each pair is the
+# Jikes RVM directory, the second is the configuration to use, and the third
+# is the command-line options to pass to Jikes RVM
+my %configurations = (
+  Base => [ "jikesrvm-3.1.0-unmodified", "FastAdaptiveMarkSweep", "" ],
+);
+
+# set up scratch directory
+my $scratch_dir = getcwd . "/scratch";
+mkdir($scratch_dir);
+
+foreach my $bmgroup (@bmgroups) {
+  my $heap_sizes = $benchmarks{$bmgroup};
+
+  my $success_string = "";
+
+  # chdir into benchmark directory
+  if ($bmgroup eq "jvm98") {
+    chdir($jvm98_dir) or die "Cannot chdir to $jvm98_dir: $!";
+    $success_string = $jvm98_success;
+  } elsif ($bmgroup eq "dacapo2006") {
+    chdir($dacapo2006_dir) or die "Cannot chdir to $dacapo2006_dir: $!";
+    $success_string = $dacapo2006_success;
+  } elsif ($bmgroup eq "dacapo2009") {
+    chdir($dacapo2009_dir) or die "Cannot chdir to $dacapo2009_dir: $!";
+    $success_string = $dacapo2009_success;
+  } elsif ($bmgroup eq "pjbb2000") {
+    chdir($pjbb2000_dir) or die "Cannot chdir to $pjbb2000_dir: $!";
+    $success_string = $pjbb2000_success;
+  } else {
+    die "Benchmark group $bmgroup not supported";
+  }
+
+  foreach my $config (sort keys %configurations) {
+    foreach my $benchmark (sort keys %$heap_sizes) {
+
+      # set heap size
+      my $heap_size = $heap_sizes->{$benchmark};
+      my $max_failed_heap_size = $min_heap_size - 4;
+      my $min_succeeded_heap_size = 1000;   # assume all programs work in 1 GB heap
+
+      while ($min_succeeded_heap_size - $max_failed_heap_size > 4) {
+        print "Running $benchmark with heap size $heap_size... ";
+        my $success = 1;
+        my $successes = 0;
+        while ($successes < $invocations) {
+
+          # generate command line
+          my $cmdline = gen_command_line($bmgroup, \%configurations, $config, $benchmark, $heap_size, $iterations);
+          $cmdline .= " > $scratch_dir/output.txt 2>&1";
+
+          # execute benchmark
+          timed_system $cmdline, $timeout;
+
+          # check result
+          open OUTPUT, "$scratch_dir/output.txt";
+          my $curr_success = 0;
+          my $curr_failure = 0;
+          while (<OUTPUT>) {
+            if (/$success_string/) {
+              $curr_success = 1;
+            }
+            if (/$failure_string/) {
+              $curr_failure = 1;
+            }
+          }
+          close OUTPUT;
+
+          # sleep for chart
+          if ($benchmark eq "chart") {
+            sleep(1);
+          }
+
+          # check for success and failure in same run
+          if ($curr_success && $curr_failure) {
+            die "both succeeded and failed?! quitting";
+          }
+
+          if ($curr_success) {
+            $successes++;
+          } else {
+
+            # save output file for failures
+            my $failed_filename;
+            my $count = 1;
+            while (1) {
+              $failed_filename = "$scratch_dir/$benchmark-failed.$count";
+              if (not -e $failed_filename) {
+                rename("$scratch_dir/output.txt", $failed_filename);
+                last;
+              }
+              $count++;
+            }
+
+            if ($curr_failure) { 
+              $success = 0;
+              last;
+            }
+          }
+        }
+
+        if ($success) {
+          ($heap_size < $min_succeeded_heap_size) or die "Assertion failure";
+          print "SUCCEEDED\n";
+          $min_succeeded_heap_size = $heap_size;
+          $heap_size = round_to_nearest($heap_size - ($heap_size - $max_failed_heap_size) / 2, 4);
+        } else {
+          ($heap_size > $max_failed_heap_size) or die "Assertion failure";
+          print "FAILED\n";
+          $max_failed_heap_size = $heap_size;
+          $heap_size = round_to_nearest($heap_size + ($min_succeeded_heap_size - $heap_size) / 2, 4);
+        }
+      }
+      $heap_sizes->{$benchmark} = $min_succeeded_heap_size;
+    }
+
+    print "Results for $config\n";
+    foreach my $benchmark (sort keys %$heap_sizes) {
+      print "$benchmark => $heap_sizes->{$benchmark}\n";
+    }
+  }
+
+  unlink "$scratch_dir/output.txt";
+}
+
+sub round_to_nearest {
+  my ($val, $nearest) = @_;
+
+  $val /= $nearest;
+  $val = int($val + 0.5);
+  return $val * $nearest;
+}
diff -ruN jikesrvm-3.1.0/benchmarking/prepare_assertions_data_normalized.pl jikesrvm-3.1.0-gcassertions/benchmarking/prepare_assertions_data_normalized.pl
--- jikesrvm-3.1.0/benchmarking/prepare_assertions_data_normalized.pl	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/benchmarking/prepare_assertions_data_normalized.pl	2010-03-18 15:08:38.000000000 +0000
@@ -0,0 +1,265 @@
+#!/usr/bin/perl -w
+use strict;
+
+# jgraph file output format -- we will output two jgraph files, one for total time and one
+# for gc time.  This file produces only the graphs for the Assertions 
+
+my $total_time_file = "fig3.j";
+my $gc_time_file = "fig4.j";
+
+my @benchmarks = qw(pseudojbb
+    db
+);
+
+if (@ARGV != 1) {
+  print "Usage: script.pl input_file\n";
+  exit;
+}
+
+open(INFILE, "<", $ARGV[0]) or die "Cannot open file: $!";
+my $curr_config;
+my $curr_benchmark;
+my %means;
+my %confidences;
+
+# format of the array for each benchmark:
+# 0: total time Base
+# 1: total time NoAssertions
+# 2: total time Assertions
+# 3: mutator time Base
+# 4: mutator time NoAssertions
+# 5: mutator time Assertions
+# 6: gc time Base
+# 7: gc time NoAssertions
+# 8: gc time Assertions
+# 9: scan Base
+# 10: scan NoAssertions
+# 11: scan Assertions
+while (<INFILE>) {
+  if (/^(Base|NoAssertions|Assertions)\.(.+)$/) {
+    $curr_config = $1;
+    $curr_benchmark = $2;
+    if ($curr_benchmark =~ /_[\d]{3}_(\w+)/) {
+      $curr_benchmark = $1;
+    }
+  } elsif (/^total time -- avg ([\d\.]+), stddev ([\d\.]+), confidence ([\d\.]+)$/) {
+    if ($curr_config eq "Base") {
+      $means{$curr_benchmark}[0] = $1;
+      $confidences{$curr_benchmark}[0] = $3;
+    } elsif ($curr_config eq "NoAssertions") {
+      $means{$curr_benchmark}[1] = $1;
+      $confidences{$curr_benchmark}[1] = $3;
+    } elsif ($curr_config eq "Assertions") {
+      $means{$curr_benchmark}[2] = $1;
+      $confidences{$curr_benchmark}[2] = $3;
+    } else {
+      print "Error processing line $_: no current config found\n";
+    }
+  } elsif (/^mutator time -- avg ([\d\.]+), stddev ([\d\.]+), confidence ([\d\.]+)$/) {
+    if ($curr_config eq "Base") {
+      $means{$curr_benchmark}[3] = $1;
+      $confidences{$curr_benchmark}[3] = $3;
+    } elsif ($curr_config eq "NoAssertions") {
+      $means{$curr_benchmark}[4] = $1;
+      $confidences{$curr_benchmark}[4] = $3;
+    } elsif ($curr_config eq "Assertions") {
+      $means{$curr_benchmark}[5] = $1;
+      $confidences{$curr_benchmark}[5] = $3;
+    } else {
+      print "Error processing line $_: no current config found\n";
+    }
+  } elsif (/^gc time -- avg ([\d\.]+), stddev ([\d\.]+), confidence ([\d\.]+)$/) {
+    if ($curr_config eq "Base") {
+      $means{$curr_benchmark}[6] = $1;
+      $confidences{$curr_benchmark}[6] = $3;
+    } elsif ($curr_config eq "NoAssertions") {
+      $means{$curr_benchmark}[7] = $1;
+      $confidences{$curr_benchmark}[7] = $3;
+    } elsif ($curr_config eq "Assertions") {
+      $means{$curr_benchmark}[8] = $1;
+      $confidences{$curr_benchmark}[8] = $3;
+    } else {
+      print "Error processing line $_: no current config found\n";
+    }
+  } elsif (/^scan -- avg ([\d\.]+), stddev ([\d\.]+), confidence ([\d\.]+)$/) {
+    if ($curr_config eq "Base") {
+      $means{$curr_benchmark}[9] = $1;
+      $confidences{$curr_benchmark}[9] = $3;
+    } elsif ($curr_config eq "NoAssertions") {
+      $means{$curr_benchmark}[10] = $1;
+      $confidences{$curr_benchmark}[10] = $3;
+    } elsif ($curr_config eq "Assertions") {
+      $means{$curr_benchmark}[11] = $1;
+      $confidences{$curr_benchmark}[11] = $3;
+    } else {
+      print "Error processing line $_: no current config found\n";
+    }
+  }
+}
+close INFILE;
+
+# calculate geomeans. format:
+# 0 - product of normalized total_time values
+# 1 - product of normalized mutator values
+# 2 - product of normalized gc values
+# 3 - count of things we multiplied
+my @slowdownsNoAssertions = (1, 1, 1, 1);
+my @slowdownsAssertions = (1, 1, 1, 1);
+foreach my $bm (@benchmarks) {
+  $slowdownsNoAssertions[0] *= $means{$bm}[1]/$means{$bm}[0];
+  $slowdownsNoAssertions[1] *= $means{$bm}[4]/$means{$bm}[3];
+  $slowdownsNoAssertions[2] *= $means{$bm}[7]/$means{$bm}[6];
+  $slowdownsNoAssertions[3]++;
+
+  $slowdownsAssertions[0] *= $means{$bm}[2]/$means{$bm}[0];
+  $slowdownsAssertions[1] *= $means{$bm}[5]/$means{$bm}[3];
+  $slowdownsAssertions[2] *= $means{$bm}[8]/$means{$bm}[6];
+  $slowdownsAssertions[3]++;
+}
+my $geomean_NoAssertions_time = $slowdownsNoAssertions[0]**(1/$slowdownsNoAssertions[3]);
+my $geomean_NoAssertions_mutator = $slowdownsNoAssertions[1]**(1/$slowdownsNoAssertions[3]);
+my $geomean_NoAssertions_gc = $slowdownsNoAssertions[2]**(1/$slowdownsNoAssertions[3]);
+
+my $geomean_Assertions_time = $slowdownsAssertions[0]**(1/$slowdownsAssertions[3]);
+my $geomean_Assertions_mutator = $slowdownsAssertions[1]**(1/$slowdownsAssertions[3]);
+my $geomean_Assertions_gc = $slowdownsAssertions[2]**(1/$slowdownsAssertions[3]);
+
+# generate jgraph files
+
+open(TOTALTIMEFILE, ">", $total_time_file) or die "Cannot open file $total_time_file: $!";
+open(GCTIMEFILE, ">", $gc_time_file) or die "Cannot open file $gc_time_file: $!";
+
+# header
+my $xmax = (scalar(@benchmarks) + 1) * 7 + 3;
+print TOTALTIMEFILE "newgraph\n\nborder\n\n";
+print TOTALTIMEFILE "xaxis\n min 0 max $xmax\n hash 0 mhash 0 no_auto_hash_labels\n size 1.8\n hash_labels fontsize 8 rotate -45 hjl vjb\n\n";
+print TOTALTIMEFILE "yaxis size 2\nyaxis min 0 max 150 grid_lines grid_gray 0.6\n\n";
+
+print GCTIMEFILE "newgraph\n\nborder\n\n";
+print GCTIMEFILE "xaxis\n min 0 max $xmax\n hash 0 mhash 0 no_auto_hash_labels\n size 1.8\n hash_labels fontsize 8 rotate -45 hjl vjb\n\n";
+print GCTIMEFILE "yaxis size 2\nyaxis min 0 max 200 grid_lines grid_gray 0.6\n\n";
+
+# names of benchmarks
+my $index = 4;
+print TOTALTIMEFILE "xaxis hash_labels fontsize 7\n";
+print GCTIMEFILE "xaxis hash_labels fontsize 7\n";
+foreach my $bm (@benchmarks) {
+  print TOTALTIMEFILE " hash_label at $index : $bm\n";
+  print GCTIMEFILE " hash_label at $index : $bm\n";
+  $index += 7;
+}
+$index += 2;
+print TOTALTIMEFILE " hash_label at $index : geomean\n\n";
+print GCTIMEFILE " hash_label at $index : geomean\n\n";
+
+# legend
+my $legend_x = $xmax + 2;
+print TOTALTIMEFILE "legend defaults x $legend_x y 100 hjl vjb\n\nyaxis label fontsize 10 : Normalized execution time\n\n";
+print GCTIMEFILE "legend defaults x $legend_x y 135 hjl vjb\n\nyaxis label fontsize 10 : Normalized GC time\n\n";
+
+# Base bars
+$index = 2;
+print TOTALTIMEFILE "newcurve marktype xbar marksize 1.7 gray 0.4 label : Base\n";
+print GCTIMEFILE "newcurve marktype xbar marksize 1.7 gray 0.4 label : Base\n";
+foreach my $bm (@benchmarks) {
+  print TOTALTIMEFILE " pts $index 100.0\n";
+  print GCTIMEFILE " pts $index 100.0\n";
+  $index += 7;
+}
+$index += 2;
+print TOTALTIMEFILE " pts $index 100.0\n\n";    # geomean
+print GCTIMEFILE " pts $index 100.0\n\n";    # geomean
+
+# Base error bars
+$index = 2;
+print TOTALTIMEFILE "newcurve marktype none\n";
+print GCTIMEFILE "newcurve marktype none\n";
+foreach my $bm (@benchmarks) {
+  my $confidence = 100*$confidences{$bm}[0]/$means{$bm}[0];
+  printf TOTALTIMEFILE " y_epts %s 100.0 %0.1f %0.1f\n", $index, 100.0-$confidence, 100.0+$confidence;
+  $confidence = 100*$confidences{$bm}[6]/$means{$bm}[6];
+  printf GCTIMEFILE " y_epts %s 100.0 %0.1f %0.1f\n", $index, 100.0-$confidence, 100.0+$confidence;
+  $index += 7;
+}
+print TOTALTIMEFILE "\n";
+print GCTIMEFILE "\n";
+
+# NoAssertions bars
+$index = 4;
+print TOTALTIMEFILE "newcurve marktype xbar marksize 1.7 gray 0.8 label : NoAssertions\n";
+print GCTIMEFILE "newcurve marktype xbar marksize 1.7 gray 0.8 label : NoAssertions\n";
+foreach my $bm (@benchmarks) {
+  printf TOTALTIMEFILE " pts %d %0.1f\n", $index, 100*$means{$bm}[1]/$means{$bm}[0];
+  printf GCTIMEFILE " pts %d %0.1f\n", $index, 100*$means{$bm}[7]/$means{$bm}[6];
+  $index += 7;
+}
+$index += 2;
+printf TOTALTIMEFILE " pts %d %0.1f\n\n", $index, 100*$geomean_NoAssertions_time;    # geomean
+printf GCTIMEFILE " pts %d %0.1f\n\n", $index, 100*$geomean_NoAssertions_gc;    # geomean
+
+# NoAssertions error bars
+$index = 4;
+print TOTALTIMEFILE "newcurve marktype none\n";
+print GCTIMEFILE "newcurve marktype none\n";
+foreach my $bm (@benchmarks) {
+  my $mean = 100*$means{$bm}[1]/$means{$bm}[0];
+  my $confidence = 100*$confidences{$bm}[1]/$means{$bm}[0];
+  printf TOTALTIMEFILE " y_epts %s %0.1f %0.1f %0.1f\n", $index, $mean, $mean-$confidence, $mean+$confidence;
+  $mean = 100*$means{$bm}[7]/$means{$bm}[6];
+  $confidence = 100*$confidences{$bm}[7]/$means{$bm}[6];
+  printf GCTIMEFILE " y_epts %s %0.1f %0.1f %0.1f\n", $index, $mean, $mean-$confidence, $mean+$confidence;
+  $index += 7;
+}
+print TOTALTIMEFILE "\n";
+print GCTIMEFILE "\n";
+
+# Assertions bars
+$index = 6;
+print TOTALTIMEFILE "newcurve marktype xbar marksize 1.7 gray 0.6 label : Assertions\n";
+print GCTIMEFILE "newcurve marktype xbar marksize 1.7 gray 0.6 label : Assertions\n";
+foreach my $bm (@benchmarks) {
+  printf TOTALTIMEFILE " pts %d %0.1f\n", $index, 100*$means{$bm}[2]/$means{$bm}[0];
+  printf GCTIMEFILE " pts %d %0.1f\n", $index, 100*$means{$bm}[8]/$means{$bm}[6];
+  $index += 7;
+}
+$index += 2;
+printf TOTALTIMEFILE " pts %d %0.1f\n\n", $index, 100*$geomean_Assertions_time;    # geomean
+printf GCTIMEFILE " pts %d %0.1f\n\n", $index, 100*$geomean_Assertions_gc;    # geomean
+
+# Assertions error bars
+$index = 6;
+print TOTALTIMEFILE "newcurve marktype none\n";
+print GCTIMEFILE "newcurve marktype none\n";
+foreach my $bm (@benchmarks) {
+  my $mean = 100*$means{$bm}[2]/$means{$bm}[0];
+  my $confidence = 100*$confidences{$bm}[2]/$means{$bm}[0];
+  printf TOTALTIMEFILE " y_epts %s %0.1f %0.1f %0.1f\n", $index, $mean, $mean-$confidence, $mean+$confidence;
+  $mean = 100*$means{$bm}[8]/$means{$bm}[6];
+  $confidence = 100*$confidences{$bm}[8]/$means{$bm}[6];
+  printf GCTIMEFILE " y_epts %s %0.1f %0.1f %0.1f\n", $index, $mean, $mean-$confidence, $mean+$confidence;
+  $index += 7;
+}
+print TOTALTIMEFILE "\n";
+print GCTIMEFILE "\n";
+
+
+close TOTALTIMEFILE;
+close GCTIMEFILE;
+
+print "geomean NoAssertions total time: $geomean_NoAssertions_time\n";
+print "geomean NoAssertions mutator time: $geomean_NoAssertions_mutator\n";
+print "geomean NoAssertions gc time: $geomean_NoAssertions_gc\n";
+
+print "geomean Assertions total time: $geomean_Assertions_time\n";
+print "geomean Assertions mutator time: $geomean_Assertions_mutator\n";
+print "geomean Assertions gc time: $geomean_Assertions_gc\n";
+
+printf "db - NoAssertions normalized to Base - total time: %0.2f\n", 100*$means{"db"}[1]/$means{"db"}[0];
+printf "db - NoAssertions normalized to Base - gc time: %0.2f\n", 100*$means{"db"}[7]/$means{"db"}[6];
+printf "db - Assertions normalized to Base - total time: %0.2f\n", 100*$means{"db"}[2]/$means{"db"}[0];
+printf "db - Assertions normalized to Base - gc time: %0.2f\n", 100*$means{"db"}[8]/$means{"db"}[6];
+
+printf "pseudojbb - NoAssertions normalized to Base - total time: %0.2f\n", 100*$means{"pseudojbb"}[1]/$means{"pseudojbb"}[0];
+printf "pseudojbb - NoAssertions normalized to Base - gc time: %0.2f\n", 100*$means{"pseudojbb"}[7]/$means{"pseudojbb"}[6];
+printf "pseudojbb - Assertions normalized to Base - total time: %0.2f\n", 100*$means{"pseudojbb"}[2]/$means{"pseudojbb"}[0];
+printf "pseudojbb - Assertions normalized to Base - gc time: %0.2f\n", 100*$means{"pseudojbb"}[8]/$means{"pseudojbb"}[6];
diff -ruN jikesrvm-3.1.0/benchmarking/prepare_data_normalized.pl jikesrvm-3.1.0-gcassertions/benchmarking/prepare_data_normalized.pl
--- jikesrvm-3.1.0/benchmarking/prepare_data_normalized.pl	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/benchmarking/prepare_data_normalized.pl	2010-03-18 15:08:38.000000000 +0000
@@ -0,0 +1,227 @@
+#!/usr/bin/perl -w
+use strict;
+
+# jgraph file output format -- we will output two jgraph files, one for total time and one
+# for gc time
+
+my $total_time_file = "fig1.j";
+my $gc_time_file = "fig2.j";
+
+my @benchmarks = qw(antlr
+    bloat
+    chart
+    eclipse
+    fop
+    hsqldb
+    jython
+    luindex
+    lusearch
+    pmd
+    xalan
+    pseudojbb
+    compress
+    jess
+    raytrace
+    db
+    javac
+    mpegaudio
+    mtrt
+    jack);
+
+if (@ARGV != 1) {
+  print "Usage: script.pl input_file\n";
+  exit;
+}
+
+open(INFILE, "<", $ARGV[0]) or die "Cannot open file: $!";
+my $curr_config;
+my $curr_benchmark;
+my %means;
+my %confidences;
+
+# format of the array for each benchmark:
+# 0: total time Base
+# 1: total time NoAssertions
+# 2: total time Assertions
+# 3: mutator time Base
+# 4: mutator time NoAssertions
+# 5: mutator time Assertions
+# 6: gc time Base
+# 7: gc time NoAssertions
+# 8: gc time Assertions
+# 9: scan Base
+# 10: scan NoAssertions
+# 11: scan Assertions
+while (<INFILE>) {
+  if (/^(Base|NoAssertions|Assertions)\.(.+)$/) {
+    $curr_config = $1;
+    $curr_benchmark = $2;
+    if ($curr_benchmark =~ /_[\d]{3}_(\w+)/) {
+      $curr_benchmark = $1;
+    }
+  } elsif (/^total time -- avg ([\d\.]+), stddev ([\d\.]+), confidence ([\d\.]+)$/) {
+    if ($curr_config eq "Base") {
+      $means{$curr_benchmark}[0] = $1;
+      $confidences{$curr_benchmark}[0] = $3;
+    } elsif ($curr_config eq "NoAssertions") {
+      $means{$curr_benchmark}[1] = $1;
+      $confidences{$curr_benchmark}[1] = $3;
+    } elsif ($curr_config eq "Assertions") {
+      $means{$curr_benchmark}[2] = $1;
+      $confidences{$curr_benchmark}[2] = $3;
+    } else {
+      print "Error processing line $_: no current config found\n";
+    }
+  } elsif (/^mutator time -- avg ([\d\.]+), stddev ([\d\.]+), confidence ([\d\.]+)$/) {
+    if ($curr_config eq "Base") {
+      $means{$curr_benchmark}[3] = $1;
+      $confidences{$curr_benchmark}[3] = $3;
+    } elsif ($curr_config eq "NoAssertions") {
+      $means{$curr_benchmark}[4] = $1;
+      $confidences{$curr_benchmark}[4] = $3;
+    } elsif ($curr_config eq "Assertions") {
+      $means{$curr_benchmark}[5] = $1;
+      $confidences{$curr_benchmark}[5] = $3;
+    } else {
+      print "Error processing line $_: no current config found\n";
+    }
+  } elsif (/^gc time -- avg ([\d\.]+), stddev ([\d\.]+), confidence ([\d\.]+)$/) {
+    if ($curr_config eq "Base") {
+      $means{$curr_benchmark}[6] = $1;
+      $confidences{$curr_benchmark}[6] = $3;
+    } elsif ($curr_config eq "NoAssertions") {
+      $means{$curr_benchmark}[7] = $1;
+      $confidences{$curr_benchmark}[7] = $3;
+    } elsif ($curr_config eq "Assertions") {
+      $means{$curr_benchmark}[8] = $1;
+      $confidences{$curr_benchmark}[8] = $3;
+    } else {
+      print "Error processing line $_: no current config found\n";
+    }
+  } elsif (/^scan -- avg ([\d\.]+), stddev ([\d\.]+), confidence ([\d\.]+)$/) {
+    if ($curr_config eq "Base") {
+      $means{$curr_benchmark}[9] = $1;
+      $confidences{$curr_benchmark}[9] = $3;
+    } elsif ($curr_config eq "NoAssertions") {
+      $means{$curr_benchmark}[10] = $1;
+      $confidences{$curr_benchmark}[10] = $3;
+    } elsif ($curr_config eq "Assertions") {
+      $means{$curr_benchmark}[11] = $1;
+      $confidences{$curr_benchmark}[11] = $3;
+    } else {
+      print "Error processing line $_: no current config found\n";
+    }
+  }
+}
+close INFILE;
+
+# calculate geomean of slowdowns. format:
+# 0 - product of NoAssertions.total slowdown factors
+# 1 - product of NoAssertions.mutator slowdown factors
+# 2 - product of NoAssertions.gc slowdown factors
+# 3 - count of things we multiplied
+my @slowdowns = (1, 1, 1, 1);
+foreach my $bm (@benchmarks) {
+  $slowdowns[0] *= $means{$bm}[1]/$means{$bm}[0];
+  $slowdowns[1] *= $means{$bm}[4]/$means{$bm}[3];
+  $slowdowns[2] *= $means{$bm}[7]/$means{$bm}[6];
+  $slowdowns[3]++;
+}
+my $geomean_time = $slowdowns[0]**(1/$slowdowns[3]);
+my $geomean_mutator = $slowdowns[1]**(1/$slowdowns[3]);
+my $geomean_gc = $slowdowns[2]**(1/$slowdowns[3]);
+
+# generate jgraph files
+
+open(TOTALTIMEFILE, ">", $total_time_file) or die "Cannot open file $total_time_file: $!";
+open(GCTIMEFILE, ">", $gc_time_file) or die "Cannot open file $gc_time_file: $!";
+
+# header
+my $xmax = (scalar(@benchmarks) + 1) * 5 + 3;
+print TOTALTIMEFILE "newgraph\n\nborder\n\n";
+print TOTALTIMEFILE "xaxis\n min 0 max $xmax\n hash 0 mhash 0 no_auto_hash_labels\n size 5.6\n hash_labels fontsize 8 rotate -45 hjl vjb\n\n";
+print TOTALTIMEFILE "yaxis size 2\nyaxis min 0 max 150 grid_lines grid_gray 0.6\n\n";
+
+print GCTIMEFILE "newgraph\n\nborder\n\n";
+print GCTIMEFILE "xaxis\n min 0 max $xmax\n hash 0 mhash 0 no_auto_hash_labels\n size 5.6\n hash_labels fontsize 8 rotate -45 hjl vjb\n\n";
+print GCTIMEFILE "yaxis size 2\nyaxis min 0 max 200 grid_lines grid_gray 0.6\n\n";
+
+# names of benchmarks
+my $index = 3;
+print TOTALTIMEFILE "xaxis hash_labels fontsize 7\n";
+print GCTIMEFILE "xaxis hash_labels fontsize 7\n";
+foreach my $bm (@benchmarks) {
+  print TOTALTIMEFILE " hash_label at $index : $bm\n";
+  print GCTIMEFILE " hash_label at $index : $bm\n";
+  $index += 5;
+}
+$index += 2;
+print TOTALTIMEFILE " hash_label at $index : geomean\n\n";
+print GCTIMEFILE " hash_label at $index : geomean\n\n";
+
+# legend
+print TOTALTIMEFILE "legend defaults x 110 y 100 hjl vjb\n\nyaxis label fontsize 10 : Normalized execution time\n\n";
+print GCTIMEFILE "legend defaults x 110 y 135 hjl vjb\n\nyaxis label fontsize 10 : Normalized GC time\n\n";
+
+# Base bars
+$index = 2;
+print TOTALTIMEFILE "newcurve marktype xbar marksize 1.7 gray 0.4 label : Base\n";
+print GCTIMEFILE "newcurve marktype xbar marksize 1.7 gray 0.4 label : Base\n";
+foreach my $bm (@benchmarks) {
+  print TOTALTIMEFILE " pts $index 100.0\n";
+  print GCTIMEFILE " pts $index 100.0\n";
+  $index += 5;
+}
+$index += 2;
+print TOTALTIMEFILE " pts $index 100.0\n\n";    # geomean
+print GCTIMEFILE " pts $index 100.0\n\n";    # geomean
+
+# Base error bars
+$index = 2;
+print TOTALTIMEFILE "newcurve marktype none\n";
+print GCTIMEFILE "newcurve marktype none\n";
+foreach my $bm (@benchmarks) {
+  my $confidence = 100*$confidences{$bm}[0]/$means{$bm}[0];
+  printf TOTALTIMEFILE " y_epts %s 100.0 %0.1f %0.1f\n", $index, 100.0-$confidence, 100.0+$confidence;
+  $confidence = 100*$confidences{$bm}[6]/$means{$bm}[6];
+  printf GCTIMEFILE " y_epts %s 100.0 %0.1f %0.1f\n", $index, 100.0-$confidence, 100.0+$confidence;
+  $index += 5;
+}
+print TOTALTIMEFILE "\n";
+print GCTIMEFILE "\n";
+
+# NoAssertions bars
+$index = 4;
+print TOTALTIMEFILE "newcurve marktype xbar marksize 1.7 gray 0.8 label : NoAssertions\n\n";
+print GCTIMEFILE "newcurve marktype xbar marksize 1.7 gray 0.8 label : NoAssertions\n\n";
+foreach my $bm (@benchmarks) {
+  printf TOTALTIMEFILE " pts %d %0.1f\n", $index, 100*$means{$bm}[1]/$means{$bm}[0];
+  printf GCTIMEFILE " pts %d %0.1f\n", $index, 100*$means{$bm}[7]/$means{$bm}[6];
+  $index += 5;
+}
+$index += 2;
+printf TOTALTIMEFILE " pts %d %0.1f\n\n", $index, 100*$geomean_time;    # geomean
+printf GCTIMEFILE " pts %d %0.1f\n\n", $index, 100*$geomean_gc;    # geomean
+
+# NoAssertions error bars
+$index = 4;
+print TOTALTIMEFILE "newcurve marktype none\n";
+print GCTIMEFILE "newcurve marktype none\n";
+foreach my $bm (@benchmarks) {
+  my $mean = 100*$means{$bm}[1]/$means{$bm}[0];
+  my $confidence = 100*$confidences{$bm}[1]/$means{$bm}[0];
+  printf TOTALTIMEFILE " y_epts %s %0.1f %0.1f %0.1f\n", $index, $mean, $mean-$confidence, $mean+$confidence;
+  $mean = 100*$means{$bm}[7]/$means{$bm}[6];
+  $confidence = 100*$confidences{$bm}[7]/$means{$bm}[6];
+  printf GCTIMEFILE " y_epts %s %0.1f %0.1f %0.1f\n", $index, $mean, $mean-$confidence, $mean+$confidence;
+  $index += 5;
+}
+print TOTALTIMEFILE "\n";
+print GCTIMEFILE "\n";
+
+close TOTALTIMEFILE;
+close GCTIMEFILE;
+
+print "geomean total time: $geomean_time\n";
+print "geomean mutator time: $geomean_mutator\n";
+print "geomean gc time: $geomean_gc\n";
diff -ruN jikesrvm-3.1.0/benchmarking/run_benchmarks.pl jikesrvm-3.1.0-gcassertions/benchmarking/run_benchmarks.pl
--- jikesrvm-3.1.0/benchmarking/run_benchmarks.pl	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/benchmarking/run_benchmarks.pl	2010-03-18 15:08:38.000000000 +0000
@@ -0,0 +1,154 @@
+#!/usr/bin/perl -w
+use strict;
+use Cwd;
+use File::Path;
+use BmConfig;
+
+# Benchmark setup for the SPECjvm98, pseudojbb 2000, dacapo 2006, and 
+# dacapo 2009 benchmarks.  We will run each benchmark $iterations times, 
+# take the last result, repeat this $invocations times, and compute the 
+# mean, median, and std deviation of the $invocations final results.
+#
+# This script may be run from any directory and will leave results in the 
+# current working directory under "results."
+#
+# We selected $iterations = 4 and $invocations = 20 based on a recommendation
+# from Steve Blackburn via email 3/19/2009.
+#
+# Usage: ./run_benchmarks.pl [list of benchmarks]
+# Valid benchmark names are jvm98, dacapo2006, dacapo2009, and pjbb2000.
+# If no benchmarks are provided, runs all of them (SPECjvm98, pseudoJBB2000, 
+# Dacapo 2006, and Dacapo 2009).  Otherwise it runs only the ones in the 
+# list.
+
+# benchmark run parameters
+my $iterations = 4;       # number of iterations per benchmark run, timing only the last one
+my $invocations = 20;     # number of times to repeat each benchmark
+my $heap_multiple = 2;    # multiple of the minimum heap size to test
+
+# minimum heap size for each benchmark
+# Found experimentally by EEA 3/2010 for configuration
+# FastAdaptiveMarkSweep with Jikes RVM 3.1.0
+my %benchmarks = (
+    jvm98 => {
+      _201_compress => 20,
+      _202_jess => 24,
+      _205_raytrace => 12,
+      _209_db => 20,
+      _213_javac => 28,
+      _222_mpegaudio => 12,
+      _227_mtrt => 12,
+      _228_jack => 28,
+    },
+    dacapo2006 => {
+      antlr => 28,
+      bloat => 52,
+      chart => 52,
+      eclipse => 112,
+      fop => 44,
+      hsqldb => 120,
+      jython => 44,
+      luindex => 28,
+      lusearch => 40,
+      pmd => 52,
+      xalan => 52,
+    },
+    # Jikes RVM 3.1.0 FastAdaptiveMarkSweep fails many of the dacapo2009 benchmarks
+    dacapo2009 => {
+      avrora => 32,
+      # batik => ??,
+      # eclipse => ??,
+      # fop => ??,
+      # h2 => ??,
+      # jython => ??,
+      luindex => 28,
+      lusearch => 32,
+      # pmd => ??,
+      sunflow => 28,
+      # tomcat => ??,
+      # tradebeans => ??,
+      # tradesoap => ??,
+      xalan => 36,
+    },
+    pjbb2000 => {
+      pjbb2000 => 60,
+    },
+);
+
+# benchmark setup
+my @bmgroups;
+if (@ARGV > 0) {
+  # check to make sure arguments are all legitimate benchmarks
+  foreach my $bmgroup (@ARGV) {
+    if (not exists $benchmarks{$bmgroup}) {
+      die "Unsupported benchmark: $bmgroup";
+    }
+  }
+  @bmgroups = @ARGV;
+} else {
+  @bmgroups = ("jvm98", "dacapo2006", "dacapo2009", "pjbb2000");
+}
+
+# configurations include the directory that contains this version of jikesrvm
+# and the name of the configuration to use
+my %configurations = (
+#  Production => ["jikesrvm-3.1.0-unmodified", "production"],
+  Base => ["jikesrvm-3.1.0-unmodified", "FastAdaptiveMarkSweep", "" ],
+#  NoAssertions => ["jikesrvm-3.1.0", "FastAdaptiveGCAssertions"],
+);
+
+# create results directory
+my $cwd = getcwd;
+my $result_dir = "$cwd/results";
+if (not -d $result_dir) {
+  mkdir($result_dir) or die "Cannot mkdir $result_dir: $!";
+}
+
+foreach my $bmgroup (@bmgroups) {
+  my $minimum_heap_sizes = $benchmarks{$bmgroup};
+
+  # chdir into benchmark directory
+  if ($bmgroup eq "jvm98") {
+    chdir($jvm98_dir) or die "Cannot chdir to $jvm98_dir: $!";
+  } elsif ($bmgroup eq "dacapo2006") {
+    chdir($dacapo2006_dir) or die "Cannot chdir to $dacapo2006_dir: $!";
+  } elsif ($bmgroup eq "dacapo2009") {
+    chdir($dacapo2009_dir) or die "Cannot chdir to $dacapo2009_dir: $!";
+  } elsif ($bmgroup eq "pjbb2000") {
+    chdir($pjbb2000_dir) or die "Cannot chdir to $pjbb2000_dir: $!";
+  } else {
+    die "Benchmark group $bmgroup not supported";
+  }
+
+  foreach my $config (sort keys %configurations) {
+    foreach my $benchmark (sort keys %$minimum_heap_sizes) {
+
+      # set heap size 
+      my $heap_size = $$minimum_heap_sizes{$benchmark} * $heap_multiple;
+
+      for my $i (1 .. $invocations) {
+        my $outfile = "$config.$bmgroup.$benchmark.$i";
+        print "Running $outfile with heap size $heap_size...\n";
+        my $cmdline = gen_command_line($bmgroup, \%configurations, $config, $benchmark, $heap_size, $iterations);
+        $cmdline .= " > $result_dir/$outfile 2>&1";
+
+        my $failure_count = 0;
+        while (1) {
+          my $result = system($cmdline);
+          if ($result == 0) {
+            last;
+          }
+          $failure_count++;
+          if ($failure_count >= 10) {
+            print "$outfile failed $failure_count times, giving up\n";
+            last;
+          } else {
+            print "$outfile failed, retrying\n";
+          }
+        }
+      }
+    }
+  }
+
+}
+  
diff -ruN jikesrvm-3.1.0/build/configs/BaseBaseGCAssertions.properties jikesrvm-3.1.0-gcassertions/build/configs/BaseBaseGCAssertions.properties
--- jikesrvm-3.1.0/build/configs/BaseBaseGCAssertions.properties	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/build/configs/BaseBaseGCAssertions.properties	2009-08-25 17:58:51.000000000 +0000
@@ -0,0 +1,13 @@
+#
+#  This file is part of the Jikes RVM project (http://jikesrvm.org).
+#
+#  This file is licensed to You under the Common Public License (CPL);
+#  You may not use this file except in compliance with the License. You
+#  may obtain a copy of the License at
+#
+#      http://www.opensource.org/licenses/cpl1.0.php
+#
+#  See the COPYRIGHT.txt file distributed with this work for information
+#  regarding copyright ownership.
+#
+config.mmtk.plan=org.mmtk.plan.marksweep.gcassertions.GCAssertions
diff -ruN jikesrvm-3.1.0/build/configs/FastAdaptiveGCAssertions.properties jikesrvm-3.1.0-gcassertions/build/configs/FastAdaptiveGCAssertions.properties
--- jikesrvm-3.1.0/build/configs/FastAdaptiveGCAssertions.properties	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/build/configs/FastAdaptiveGCAssertions.properties	2009-08-25 17:58:51.000000000 +0000
@@ -0,0 +1,19 @@
+#
+#  This file is part of the Jikes RVM project (http://jikesrvm.org).
+#
+#  This file is licensed to You under the Common Public License (CPL);
+#  You may not use this file except in compliance with the License. You
+#  may obtain a copy of the License at
+#
+#      http://www.opensource.org/licenses/cpl1.0.php
+#
+#  See the COPYRIGHT.txt file distributed with this work for information
+#  regarding copyright ownership.
+#
+config.mmtk.plan=org.mmtk.plan.marksweep.gcassertions.GCAssertions
+config.include.aos=true
+config.assertions=none
+config.default-heapsize.initial=50
+config.runtime.compiler=opt
+config.bootimage.compiler=opt
+config.bootimage.compiler.args=-X:bc:O2
diff -ruN jikesrvm-3.1.0/build/configs/FullAdaptiveGCAssertions.properties jikesrvm-3.1.0-gcassertions/build/configs/FullAdaptiveGCAssertions.properties
--- jikesrvm-3.1.0/build/configs/FullAdaptiveGCAssertions.properties	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/build/configs/FullAdaptiveGCAssertions.properties	2009-08-25 17:58:51.000000000 +0000
@@ -0,0 +1,18 @@
+#
+#  This file is part of the Jikes RVM project (http://jikesrvm.org).
+#
+#  This file is licensed to You under the Common Public License (CPL);
+#  You may not use this file except in compliance with the License. You
+#  may obtain a copy of the License at
+#
+#      http://www.opensource.org/licenses/cpl1.0.php
+#
+#  See the COPYRIGHT.txt file distributed with this work for information
+#  regarding copyright ownership.
+#
+config.mmtk.plan=org.mmtk.plan.marksweep.gcassertions.GCAssertions
+config.include.aos=true
+config.default-heapsize.initial=50
+config.runtime.compiler=opt
+config.bootimage.compiler=opt
+config.bootimage.compiler.args=-X:bc:O2
diff -ruN jikesrvm-3.1.0/common/vmmagic/src/org/vmmagic/StaticOptTable.java jikesrvm-3.1.0-gcassertions/common/vmmagic/src/org/vmmagic/StaticOptTable.java
--- jikesrvm-3.1.0/common/vmmagic/src/org/vmmagic/StaticOptTable.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/common/vmmagic/src/org/vmmagic/StaticOptTable.java	2010-01-26 18:33:00.000000000 +0000
@@ -0,0 +1,27 @@
+package org.vmmagic;
+
+import org.vmmagic.unboxed.Address;
+
+public class StaticOptTable
+{
+
+  /* [CR]
+   * Magic method table operations
+   */
+
+  /** Opt-compile method and return a handle to it for later use. */
+  public static int registerStaticMethodHook(Class<?> c, int static_method_index) {
+    return -1;
+  }
+
+  public static Address lookupStaticMethodHook(int hook) {
+    return null;
+  }
+
+  public static void flushStaticMethodHooks() {
+  }
+
+  public static boolean invokeStaticMethod(Object param1, Object[] param2, Address address) {
+    return false;
+  }
+}
\ No newline at end of file
diff -ruN jikesrvm-3.1.0/common/vmmagic/src/org/vmmagic/pragma/SkipBytecodeVerifier.java jikesrvm-3.1.0-gcassertions/common/vmmagic/src/org/vmmagic/pragma/SkipBytecodeVerifier.java
--- jikesrvm-3.1.0/common/vmmagic/src/org/vmmagic/pragma/SkipBytecodeVerifier.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/common/vmmagic/src/org/vmmagic/pragma/SkipBytecodeVerifier.java	2010-02-03 16:28:55.000000000 +0000
@@ -0,0 +1,33 @@
+/*
+ *  This file is part of the Jikes RVM project (http://jikesrvm.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License. You
+ *  may obtain a copy of the License at
+ *
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  See the COPYRIGHT.txt file distributed with this work for information
+ *  regarding copyright ownership.
+ */
+package org.vmmagic.pragma;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.ElementType;
+import org.vmmagic.Pragma;
+
+/**
+ * This annotation instructs Jikes to not bytecode-verify a given
+ * method.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.TYPE, ElementType.METHOD})
+@Pragma
+public @interface SkipBytecodeVerifier {
+  /**
+   * @return Explanation of why code needs to be uninterruptible
+   */
+  String value() default "";
+}
diff -ruN jikesrvm-3.1.0/common/vmmagic/src/org/vmmagic/unboxed/Address.java jikesrvm-3.1.0-gcassertions/common/vmmagic/src/org/vmmagic/unboxed/Address.java
--- jikesrvm-3.1.0/common/vmmagic/src/org/vmmagic/unboxed/Address.java	2009-04-24 15:17:46.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/common/vmmagic/src/org/vmmagic/unboxed/Address.java	2010-01-25 20:26:18.000000000 +0000
@@ -948,5 +948,4 @@
   public boolean attempt(Address old, Address value, Offset offset) {
     return false;
   }
-
 }
diff -ruN jikesrvm-3.1.0/compute-bench-summary.sh jikesrvm-3.1.0-gcassertions/compute-bench-summary.sh
--- jikesrvm-3.1.0/compute-bench-summary.sh	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/compute-bench-summary.sh	2010-02-23 12:50:35.000000000 +0000
@@ -0,0 +1,12 @@
+#! /bin/bash
+
+if [ x$2 == x ]; then
+	echo "Usage: $0 <bench1> <bench2>"
+	echo "for example, $0 ms gca"	
+	exit 1
+fi
+
+AVERAGE=`dirname $0`
+AVERAGE="$AVERAGE"/average.awk
+
+printf "%-20s%-60s%-60s%-60s\n" benchmark gc\# wallclock gc-time ; for n in avrora luindex lusearch pmd sunflow xalan; do printf "%-20s" $n;  (for k in $1 $2; do for i in 1 2 3; do cat $n.$k.* | awk '/^GC/ {nextprint = 2} { if (nextprint-- == 1) {print $'$i'} }' | ${AVERAGE} ; done; done) | awk '/mean/ { m[++n] = $2} /standar/ { v[n] = $2 } END { for (i = 0; i < 3; i++) { ms = i + 1; gca = i + 4; printf "%-60s", sprintf("%.3f (%.3f [%.3f]; %.3f [%.3f])", m[gca]/m[ms], m[gca], v[gca], m[ms], v[ms])}; printf "\n" }'; done
Binary files jikesrvm-3.1.0/dacapo-9.12-bach.jar and jikesrvm-3.1.0-gcassertions/dacapo-9.12-bach.jar differ
diff -ruN jikesrvm-3.1.0/docs/gcassertions/compilation-scheme.tex jikesrvm-3.1.0-gcassertions/docs/gcassertions/compilation-scheme.tex
--- jikesrvm-3.1.0/docs/gcassertions/compilation-scheme.tex	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/docs/gcassertions/compilation-scheme.tex	2010-02-19 15:33:25.000000000 +0000
@@ -0,0 +1,246 @@
+\documentclass{report}
+\usepackage{listings}
+
+\newcommand{\Prod}{::=}
+\newcommand{\VB}{\ |\ }
+\newcommand{\tuple}[1]{\ensuremath{\langle #1 \rangle}}
+\newcommand{\reachOp}{\ensuremath{\mathbf{R}}}
+\newcommand{\reach}[1]{\ensuremath{\reachOp_{#1}}}
+\newcommand{\disjointOp}{\ensuremath{\mathbf{X}}}
+\newcommand{\disjoint}[2]{\ensuremath{{\disjointOp_{#1 + #2}}}}
+\newcommand{\NT}[1]{\textsf{#1}}
+
+\newcommand{\TTexclude}{\textsf{exclude-node}}
+\newcommand{\TTinclude}{\textsf{include-node}}
+\newcommand{\TTtid}{\textsf{mark-traversal-id}}
+\newcommand{\TTset}{\textsf{set-predicates}}
+\newcommand{\TTtrace}{\textsf{trace}}
+\newcommand{\roots}{\ensuremath{\diamond}}
+
+\begin{document}
+
+\section{Heap invariant logic language}
+
+\begin{verbatim}
+Assertion ::= <QExpr> | <BoolExpr> | <Assertion> '||' <Assertion>
+            | <Assertion> '&&' <Assertion> | '!' <Assertion>
+
+Quant ::= 'forall' | 'exists'
+
+QExpr ::= <Quant> <Type> <QName> '.' <BoolExpr>
+
+BinOp ::= '==' | '!='
+
+BoolExpr ::= <Expr> <BinOp> <Expr> | <Expr> 'instanceof' <Type>
+           | <BoolExpr> '&&' <BoolExpr> | <BoolExpr> '||' <BoolExpr>
+           | '!' <BoolExpr>
+           | 'reach' '(' <ReachSpecSeq> ')' '[' <QName> ']'
+           | 'disjoint' '(' <NodeSet> ',' <NodeSet> ')'
+
+ReachSpecSeq ::= <ReachSpec> | <ReachSpecSeq> ',' <ReachSpec>
+
+ReachSpec ::= <ReachSource> | <ReachSource> '/' <NodeSet>
+
+ReachSource ::= 'root' | <NodeSet>
+
+NodeSet ::= '{' <Name> */ ',' '}' | <Name>
+
+Expr ::= <Name> | <QName> | <Expr> '.' <Name> | <int> | 'null'
+\end{verbatim}
+
+In the following, I will typeset the above `more nicely', using LaTeX:
+\reachOp{} instead of \texttt{reach}, and \disjointOp{} instead of
+\texttt{disjoint}.
+
+\section{Trace and test language}
+
+The trace-and-test language implements heap invariant logic on the
+garbage collector side.  A trace-and-test program instructs the
+garbage collector what to mark recursively, what to test for, and what
+individual objects to expressly exclude or include in the traversal.
+
+Each trace-and-test program runs in the context of a \emph{predicate
+  family}.  A predicate family is an indexed family of predicates
+(tests that apply on one object at a time) together with information
+of whether the predicate family is existential or universal.
+Predicate families correspond to \texttt{QExpr}s in the heap invariant
+language.
+
+The sweep algorithm applies one predicate from each family to each
+heap object it encounters (modulo optimisations).
+
+Below are the instructions for our trace-and-test language:
+
+\begin{itemize}
+  \item $\TTexclude(o)$: Exclude object $o$ from traversal.  This
+    operation marks the object $o$ as `live,' meaning that
+    they will be skipped during tracing.
+  \item $\TTinclude(o)$: Mark object $o$ as `unknown' (grey), meaning
+    that $o$ and its children will be traced the next time they are
+    encountered.
+  \item $\TTtid(x)$: Increase the traversal ID.  Each trace colours
+    the objects it encounters with a particular traversal ID.  If a
+    sweep encounters a live object with a traversal ID different from
+    its own, it will flag $x$ as \textsf{false}.
+  \item $\TTset(k_1, \ldots, k_n)$: Set the traversal predicates.
+    This operation sets the particular predicate to test for each
+    predicate family.
+  \item $\TTtrace(o)$: Trace the heap, starting at object $o$.  $o$ may
+    be the special node \roots, meaning all objects in the root set.
+\end{itemize}
+
+
+The default program is `$\TTtrace(\roots)$'.
+
+A trace-and-test program is sound if (a) it includes a
+$\TTtrace(\roots)$ and (b) for all $\TTexclude(o)$, there later is a
+corresponding $\TTinclude(o)$ followed by $\TTtrace(o)$.
+
+\subsection{Compilation}
+
+To compile an assertion $A$ in heap invariant logic into the
+trace-and-test language, we first label
+each top-level \NT{QExpr} or \NT{BoolExpr}
+as $i_k$ for some unique $k$. 
+
+Let $A'$ assertion $A$ with $t_k$ replaced by $i_k$ such that
+\[
+ A'[i_{\overline{k}} \backslash t_{\overline{k}}] = A.
+\]
+Observe that each $t_k$ contains at most one quantifier, and if $t_k$
+contains one or more `\reachOp{}' predicates, the `reach' must be over that
+quantifier's variable.  `\reachOp{}' cannot appear outside of such
+$t_k$.  We can thus partition our tests $t_k$ into the following:
+
+\begin{enumerate}
+\item boolean expressions without reachability/disjointedness predicates
+\item disjointness predicates \disjointOp (possibly negated)
+\item quantified $t_k$
+\end{enumerate}
+
+The first we can evaluate trivially.  Disjointedness tests we handle
+in separation, by ensuring traversal non-overlap.
+This leaves quantified $t_k$ of the form
+
+\[
+  Q x. P_k(x)
+\]
+
+where $Q \in \{ \exists, \forall \}$.
+
+$P_k(x)$ is a predicate that may contain reachability tests based on
+$x$.  $P_k$ may also contain $\disjointOp$ tests; we defer the
+discussion of how we handle this case to
+Section~\ref{sec:embedded-disjointness}.
+
+Note that $P_k$ may contain different `reach' tests, as in $t_1$ below:
+
+\[
+  t_1 \equiv  \forall x. (\reach{a}(x) \wedge x.\textsf{v} = 0) \vee (\reach{b}(x) \wedge x.\textsf{v} = 1)
+\]
+
+  This construction is perfectly legitimate as long as we know that
+`$a$' and `$b$' do not overlap (not knowing this is a static error.)
+
+Each quantified predicate
+$Q x. P_k(x)$
+  we use an object that keeps track of whether P(x) was ever
+satisfied or not satisfied.  However, the concrete test that we have
+to run varies by traversal.  For example, in $t_1$ we expect different
+values for $x.\textsf{v}$ depending on which traversal we encountered `\textsf{x}' in.
+For each test $t_k$, we formalise this through a \emph{context predicate}
+
+\[
+  T_k(r)(x) \equiv P_k(x)[\reach{r}(x) \backslash \textsf{true}][\reach{-}(x) \backslash \textsf{false}]
+\]
+
+where $r \in R$ is one of the subscripts for $reachOp$ that occur in
+the program.
+
+We use the special form $T_k(\star)(x)$ to mean `replace all reachability
+predicates by false' (i.e., `$\star$' is fresh).
+
+  Note that each predicate may have any number of tests associated
+with it.  For example,
+
+\begin{eqnarray*}
+  T_1(a)(x) &=& x.\textsf{v} \textsf{==} 0 \\
+  T_1(b)(x) &=& x.\textsf{v} \textsf{==} 1 \\
+  T_1(\star)(x) &=& \textsf{false}
+\end{eqnarray*}
+
+For each traversal, these context predicates capture our proof
+obligation.  Note that none of the tests contains a reachability
+predicate.
+  Since the set of parameters for $r$ is finite, we can then
+reify each of these tests into a predicate of the form
+
+\begin{lstlisting}[language=Java]
+  final static boolean
+  test_k_r(Type x, Object[] environment)
+\end{lstlisting}
+
+Note that any result that is trivially `\textsf{true}' or
+`\textsf{false}' cannot contribute to a universal test succeeding or
+an existential test failing (respectively), so as a performance
+optimisation we can omit these tests.  Some of the other tests may
+have identical bodies, so we apply global value numbering to ensure
+that we do not needlessly duplicate.
+
+\subsection{Traversing the heap}
+
+To emit trace-and-test code, we choose any order $r_1, \ldots, r_n$
+over the elements of the set $R$ of indices for $\reachOp$ predicates
+that occur in the program.  Observe that we require each of these to
+be disjoint, so the order does not matter.
+
+We thus first emit a $\TTtid(x)$ for a fresh $x$; this $x$ represents
+the fact that we did not overlap any of the previous traversals.  In
+the end, we can use the collection of all $x$ to assert our exclusion
+properties.  In the end, the conjunction of all such $x$ guarantees
+that our $\disjointOp$ predicates (occuring positively) hold.
+
+Considering again our $r_i$, we observe that each has the form
+\[
+r_i = S_0 / I_0, \ldots, S_n / I_n
+\]
+where each $S_i$ is a root set, and each $I_i$ is an ignore set.
+$S_i$ may be $\roots$, meaning that we must trace from the root set.
+
+We begin the traversal with $\TTset(r_i)$, thereby informing each
+predicate family $j$ about the particular traversal pass we are taking and
+asking them to test $T_j(r_i)$, i.e., ensuring that for each predicate
+call, $\reach{r_i}$ is \textsf{true} and $\reach{r_l}$ with $l \ne i$
+is \textsf{false}.
+
+Now, for each pair $S_j / I_j$ in ascending order, we first
+$\TTexclude$ all elements of $I_j$ and then $\TTtrace$
+all elements of $S_j$, in order.  If one of our ignore sets was
+nonempty, this may leave part of the objects reachable from $\bigcup_j
+S_j$ unreached.  We thus continue by $\TTinclude$ and $\TTtrace$ on
+all objects in $\bigcup_j I_j$.
+
+In the end, if we have not already done so, we $\TTtrace(\roots)$ to
+ensure that the garbage collector fulfills its usual purpose, too.
+
+\subsection{Epilogue}
+
+Once the heap traversal is complete, we can fail any existential
+predicate families that have been unable to observe any witness.  We
+now have valuations for all $t_i$ (collected through our test families
+$T_i$) and can evaluate the toplevel assertion.
+
+\subsection{Embedded disjointness tests}\label{sec:embedded-disjointness}
+
+Hmm.  We probably shouldn't allow $\disjointOp$ to occur in
+\texttt{QExpr}.  So this won't be necessary.  (It is possible to `pull
+them out' at least in some cases, though.)
+
+\subsection{Run-time support}
+
+All that we need for run-time support are mechanisms that track the
+status of our predicate families (satisfied, unknown, unsatisfiable)
+and indicators on each object on the heap to indicate the traversal
+ID, to detect overlap.
+
+\end{document}
diff -ruN jikesrvm-3.1.0/gtest/Node.java jikesrvm-3.1.0-gcassertions/gtest/Node.java
--- jikesrvm-3.1.0/gtest/Node.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/gtest/Node.java	2010-01-28 20:17:49.000000000 +0000
@@ -0,0 +1,23 @@
+package gtest;
+
+public class Node
+{
+	public Node next;
+	public Node prev;
+	public int value = 0;
+
+	public
+	Node(final Node _next, final Node _prev)
+	{
+		this.next = _next;
+		this.prev = _prev;
+	}
+
+	public
+	Node(final Node _next, final Node _prev, final int _value)
+	{
+		this.next = _next;
+		this.prev = _prev;
+		this.value = _value;
+	}
+}
diff -ruN jikesrvm-3.1.0/gtest/TestHarness.java jikesrvm-3.1.0-gcassertions/gtest/TestHarness.java
--- jikesrvm-3.1.0/gtest/TestHarness.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/gtest/TestHarness.java	2010-01-29 16:56:04.000000000 +0000
@@ -0,0 +1,57 @@
+/*
+ * For some reason JUnit isn't co-operating.  It's faster to write my own
+ * test harness than to debug this, so here we go.
+ */
+
+package gtest;
+
+import java.lang.reflect.Method;
+public class TestHarness
+{
+	public static void main(String[] _) throws Exception
+	{
+		int tests = 0;
+		int successful = 0;
+
+		Class self = Class.forName("gtest.Tests");
+		Object o = self.newInstance();
+		Method[] methods = self.getMethods();
+		for (Method m : methods)
+			if (m.getName().startsWith("test")) {
+				boolean failed = false;
+
+				++tests;
+				System.out.print(m.getName() + " : ");
+				try {
+					m.invoke(o);
+				} catch (Exception e) {
+					System.out.println("\u001b[1;31mFAILED\u001b[0m");
+					e.printStackTrace();
+					failed = true;
+				}
+
+				if (!failed) {
+					System.out.println("\u001b[1;32mOK\u001b[0m");
+					++successful;
+				}
+			}
+		System.out.println("\nSummary: " + successful + " / " + tests + " succeeded");
+	}
+
+	public static void
+	assertTrue(boolean b)
+	{
+		if (!b)
+			throw new AssertionFailedException();
+	}
+
+
+	public static void
+	assertFalse(boolean b)
+	{
+		if (b)
+			throw new AssertionFailedException();
+	}
+
+	public static final class AssertionFailedException extends RuntimeException {}
+}
\ No newline at end of file
diff -ruN jikesrvm-3.1.0/gtest/Tests.java jikesrvm-3.1.0-gcassertions/gtest/Tests.java
--- jikesrvm-3.1.0/gtest/Tests.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/gtest/Tests.java	2010-03-23 00:48:12.000000000 +0000
@@ -0,0 +1,651 @@
+package gtest;
+
+import org.mmtk.plan.marksweep.gcassertions.spec.*;
+import org.vmmagic.pragma.Uninterruptible;
+import org.mmtk.utility.Log;
+
+public class Tests extends TestHarness
+{
+	/* ============================================================ */
+	/* Reachability tests */
+
+	/* ---------------------------------------- */
+	// Reachability: universal (inside)
+
+	public static int c00 = 0;
+	public static int c01 = 0;
+	public static int c02 = 0;
+	public static int c03 = 0;
+	public static int c04 = 0;
+	public static int c05 = 0;
+
+	public static final void
+	resetCounters()
+	{
+		c00 = c01 = c02 = c03 = c04 = c05 = 0;
+	}
+
+	@Uninterruptible
+	public static final class TestClass {
+		
+		public static final boolean
+		_magic00_is_in_env(Object o, Object[] env)
+		{
+			++c00;
+			for (Object o2 : env)
+				if (o2 == o)
+					return true;
+			return false;
+		}
+
+		public static final boolean
+		_magic01_is_not_in_env(Object o, Object[] env)
+		{
+			++c01;
+			for (Object o2 : env)
+				if (o2 == o)
+					return false;
+			return true;
+		}
+
+		public static final boolean
+		_magic02_is_node(Object o, Object[] env)
+		{
+			++c02;
+			return o instanceof Node;
+		}
+
+		public static final boolean
+		_magic03_is_not_node(Object o, Object[] env)
+		{
+			++c03;
+			return !(o instanceof Node);
+		}
+
+		public static final boolean
+		_magic04_is_one(Object o, Object[] env)
+		{
+			++c04;
+			return (o instanceof Node
+				&& ((Node) o).value == 1);
+		}
+
+		public static final boolean
+		_magic05_is_not_one(Object o, Object[] env)
+		{
+			++c05;
+			return (o instanceof Node
+				&& ((Node) o).value != 1);
+		}
+
+	}
+
+	final int TEST_IS_IN_ENV	= 0;
+	final int TEST_IS_NOT_IN_ENV	= 1;
+	final int TEST_IS_NODE		= 2;
+	final int TEST_IS_NOT_NODE	= 3;
+	final int TEST_IS_1		= 4;
+	final int TEST_IS_NOT_1		= 5;
+
+	public void
+	testBug0()
+	{
+		// Specification:
+		//   X_a+b && !X_{a,b}+c
+		resetCounters();
+
+		Node a = new Node(null, null);
+		// a -> * -> *
+
+		final PredicateFamily all_are_covered =
+			new PredicateFamily(TestClass.class,
+					    // Universal predicate family requires negated predicate
+					    new int[] { PredicateFamily.IGNORE_TEST, TEST_IS_NODE },
+					    new Object[] { },
+					    PredicateFamily.UNIVERSAL);
+
+		Assertion asr = new Assertion(new PredicateFamily[] { all_are_covered },
+					    new Step[] {
+						    null, // required format, cf constructor
+						    // -- regular code
+						    new SetTraversalPredicatesStep(new int[] {0}),
+						    new ExcludeNodesStep(new Object[] {}),
+						    new TraversalStep(new Object[] { a }),
+						    new SetTraversalPredicatesStep(new int[] {1}),
+						    new TraversalStep(),
+						    // -- end of regular code
+						    null, // required format, cf constructor
+						    null,  // required format, cf constructor
+						    null  // required format, cf constructor
+					    });
+		Assertion.doAssert(asr);
+		assertTrue(all_are_covered.value());
+	}
+
+
+	public void
+	testUniversalReachability()
+	{
+		// Specification:
+		//   forall x. R_c(x) => x instanceof Node
+
+		resetCounters();
+		Node a = new Node(null, null);
+		Node b = new Node(null, a);
+		Node c = new Node(null, b);
+		// c -> b -> a
+
+
+		final PredicateFamily all_reachable_are_nodes = 
+			new PredicateFamily(TestClass.class,
+					    // universal tests are negated
+					    new int[] { TEST_IS_NOT_NODE, PredicateFamily.IGNORE_TEST },
+					    null, // no object
+					    PredicateFamily.UNIVERSAL);
+
+		Assertion.doAssert(new Assertion(new PredicateFamily[] {
+					all_reachable_are_nodes
+				},
+				new Step[] {
+					null, // required format, cf constructor
+					// -- regular code
+					new SetTraversalPredicatesStep(new int[] { 0 }), // only one predicate, and we're setting it to TEST_IS_NONE
+					new TraversalStep(new Object[] { c }), // collect from c
+					new SetTraversalPredicatesStep(new int[] { 1 }), // we're setting it to IGNORE_TEST now
+					new TraversalStep(), // collect from the root set
+					// -- end of regular code
+					null, // required format, cf constructor
+					null, // required format, cf constructor
+					null  // required format, cf constructor
+				}));
+
+		assertTrue(all_reachable_are_nodes.value());
+		assertTrue(c03 == 3); // we should have encountered precisely a, b, c
+	}
+
+	public void
+	testExistentialReachability()
+	{
+		// Specification:
+		//   (exists x. !R_b(x) => x == c) && (forall y. R_b(y) => (y == a || y == b))
+
+		resetCounters();
+		Node a = new Node(null, null);
+		Node b = new Node(null, a);
+		Node c = new Node(null, b);
+		// c -> b -> a
+
+		final PredicateFamily c_is_outside =
+			new PredicateFamily(TestClass.class,
+					    new int[] { TEST_IS_IN_ENV, PredicateFamily.IGNORE_TEST },
+					    new Object[] { c },
+					    PredicateFamily.EXISTENTIAL);
+
+		final PredicateFamily inside_is_a_b = 
+			new PredicateFamily(TestClass.class,
+					    // universal tests are negated
+					    new int[] { TEST_IS_NOT_IN_ENV, PredicateFamily.IGNORE_TEST },
+					    new Object[] { a, b },
+					    PredicateFamily.UNIVERSAL);
+
+		Assertion.doAssert(new Assertion(new PredicateFamily[] {
+					c_is_outside,
+					inside_is_a_b
+				},
+				new Step[] {
+					null, // required format, cf constructor
+					// -- regular code
+					new SetTraversalPredicatesStep(new int[] { 1, 0 }), // c_is_outside: IGNORE, inside_is_a_b: TEST_IS_NODE
+					new TraversalStep(new Object[] { b }),
+					new SetTraversalPredicatesStep(new int[] { 0, 1 }),
+					new TraversalStep(), // collect from the root set
+					// -- end of regular code
+					null, // required format, cf constructor
+					null, // required format, cf constructor
+					null  // required format, cf constructor
+				}));
+
+		assertTrue(c_is_outside.value());
+		assertTrue(inside_is_a_b.value());
+		assertTrue(c01 == 2); // we should have encountered precisely a and b
+	}
+
+
+	public void
+	testNegatedExistentialReachability()
+	{ // we now expect b to be outside the traversal, but since we start with b, that is impossible.
+
+		// Specification:
+		//   !(exists x. R_b(x) => x == a)
+
+		resetCounters();
+		Node a = new Node(null, null);
+		Node b = new Node(null, a);
+		Node c = new Node(null, b);
+		// c -> b -> a
+
+		final PredicateFamily a_is_outside =
+			new PredicateFamily(TestClass.class,
+					    new int[] { TEST_IS_IN_ENV, PredicateFamily.IGNORE_TEST },
+					    new Object[] { a },
+					    PredicateFamily.EXISTENTIAL);
+
+		Assertion.doAssert(new Assertion(new PredicateFamily[] {
+					a_is_outside,
+				},
+				new Step[] {
+					null, // required format, cf constructor
+					// -- regular code
+					new SetTraversalPredicatesStep(new int[] { 1 }), // ignore the inside
+					new TraversalStep(new Object[] { b }),
+					new SetTraversalPredicatesStep(new int[] { 0 }), // search for `b' outside
+					new TraversalStep(), // collect from the root set
+					// -- end of regular code
+					null, // required format, cf constructor
+					null, // required format, cf constructor
+					null  // required format, cf constructor
+				}));
+
+		assertFalse(a_is_outside.value());
+	}
+
+	public void
+	testNegativeUniversalReachability0()
+	{
+		// Specification:
+		//   !(forall x. !R_b(x) => x == c)
+
+		resetCounters();
+		Node a = new Node(null, null);
+		Node b = new Node(null, a);
+		Node c = new Node(null, b);
+		// c -> b -> a
+
+		final PredicateFamily c_is_everywhere_outside =
+			new PredicateFamily(TestClass.class,
+					    // Universal predicate family requires negated predicate
+					    new int[] { TEST_IS_NOT_IN_ENV, PredicateFamily.IGNORE_TEST },
+					    new Object[] { c },
+					    PredicateFamily.UNIVERSAL);
+
+		Assertion.doAssert(new Assertion(new PredicateFamily[] {
+					c_is_everywhere_outside,
+				},
+				new Step[] {
+					null, // required format, cf constructor
+					// -- regular code
+					new SetTraversalPredicatesStep(new int[] { 1 }), // ignore the inside
+					new TraversalStep(new Object[] { b }),
+					new SetTraversalPredicatesStep(new int[] { 0 }), // search for `c' outside
+					new TraversalStep(), // collect from the root set
+					// -- end of regular code
+					null, // required format, cf constructor
+					null, // required format, cf constructor
+					null  // required format, cf constructor
+				}));
+
+		assertFalse(c_is_everywhere_outside.value());
+	}
+
+
+	public void
+	testNegativeUniversalReachability1()
+	{
+		// Specification:
+		//   !(forall x. R_b(x) => (x == c || x == a))
+
+		resetCounters();
+		Node a = new Node(null, null);
+		Node b = new Node(null, a);
+		Node c = new Node(null, b);
+		// c -> b -> a
+
+		final PredicateFamily c_is_everywhere_outside =
+			new PredicateFamily(TestClass.class,
+					    // Universal predicate family requires negated predicate
+					    new int[] { TEST_IS_NOT_IN_ENV, PredicateFamily.IGNORE_TEST },
+					    new Object[] { c, a },
+					    PredicateFamily.UNIVERSAL);
+
+		Assertion.doAssert(new Assertion(new PredicateFamily[] {
+					c_is_everywhere_outside,
+				},
+				new Step[] {
+					null, // required format, cf constructor
+					// -- regular code
+					new SetTraversalPredicatesStep(new int[] { 0 }), // check the inside
+					new TraversalStep(new Object[] { b }),
+					new SetTraversalPredicatesStep(new int[] { 1 }), // ignore the outside
+					new TraversalStep(), // collect from the root set
+					// -- end of regular code
+					null, // required format, cf constructor
+					null, // required format, cf constructor
+					null  // required format, cf constructor
+				}));
+
+		assertFalse(c_is_everywhere_outside.value());
+	}
+
+
+	/* ============================================================ */
+	/* Dominance tests */
+
+
+	public void
+	testDominance()
+	{
+		// Specification:
+		//   forall x. !R_/c(x) => x.value == 1
+		resetCounters();
+		Node a = new Node(null, null, 0);
+		Node b = new Node(null, a, 1);
+		Node c = new Node(null, b, 1);
+		Node d = new Node(null, a, 0);
+		// c -> b -> a
+		//      d -> a
+		a = null;
+		b = null;
+
+		final PredicateFamily all_in_area_are_1 =
+			new PredicateFamily(TestClass.class,
+					    // Universal predicate family requires negated predicate
+					    new int[] { TEST_IS_NOT_1, PredicateFamily.IGNORE_TEST },
+					    new Object[] { },
+					    PredicateFamily.UNIVERSAL);
+
+		Assertion.doAssert(new Assertion(new PredicateFamily[] {
+					all_in_area_are_1
+				},
+				new Step[] {
+					null, // required format, cf constructor
+					// -- regular code
+					new ExcludeNodesStep(new Object[] { c }),
+					new SetTraversalPredicatesStep(new int[] { 1 }), // ignore the outside
+					new TraversalStep(), // collect from the root set
+					new IncludeNodesStep(new Object[] { c }),
+					new SetTraversalPredicatesStep(new int[] { 0 }), // check the inside
+					new TraversalStep(new Object[] { c }),
+					// -- end of regular code
+					null, // required format, cf constructor
+					null, // required format, cf constructor
+					null  // required format, cf constructor
+				}));
+
+		assertTrue(all_in_area_are_1.value());
+		assertTrue(c05 == 2); // only b and c should have been counted
+	}
+
+
+	public void
+	testNegativeDominance()
+	{ // a is actually shared:  reachable, but not dominated.
+
+		// Specification:
+		//   !(exists x. !R_/c(x) => x.value == 1)
+		resetCounters();
+		Node a = new Node(null, null, 1);
+		Node b = new Node(null, a, 0); // ONLY a is tagged with `1'
+		Node c = new Node(null, b, 0);
+		Node d = new Node(null, a, 0);
+		// c -> b -> a
+		//      d -> a
+		a = null;
+		b = null;
+
+		final PredicateFamily one_in_area_is_1 =
+			new PredicateFamily(TestClass.class,
+					    // Universal predicate family requires negated predicate
+					    new int[] { TEST_IS_1, PredicateFamily.IGNORE_TEST },
+					    new Object[] { },
+					    PredicateFamily.EXISTENTIAL);
+
+		Assertion.doAssert(new Assertion(new PredicateFamily[] {
+					one_in_area_is_1
+				},
+				new Step[] {
+					null, // required format, cf constructor
+					// -- regular code
+					new ExcludeNodesStep(new Object[] { c }),
+					new SetTraversalPredicatesStep(new int[] { 1 }), // ignore the outside
+					new TraversalStep(), // collect from the root set
+					new IncludeNodesStep(new Object[] { c }),
+					new SetTraversalPredicatesStep(new int[] { 0 }), // check the inside
+					new TraversalStep(new Object[] { c }),
+					// -- end of regular code
+					null, // required format, cf constructor
+					null,  // required format, cf constructor
+					null  // required format, cf constructor
+				}));
+
+		assertFalse(one_in_area_is_1.value());
+	}
+
+
+
+	/* ============================================================ */
+	/* Overlap tests */
+
+	/* ---------------------------------------- */
+	// Positive overlap
+
+	public void
+	testNegativeExclude()
+	{
+		// Specification:
+		//   !X_c+e
+		resetCounters();
+
+		Node a = new Node(null, null);
+		Node b = new Node(null, a);
+		Node c = new Node(null, b);
+		Node d = new Node(null, a);
+		Node e = new Node(null, d);
+		// c -> b -> a
+		// e -> d -> a
+
+		Assertion asr = new Assertion(new PredicateFamily[] {},
+					      new Step[] {
+						      null, // required format, cf constructor
+						      // -- regular code
+						      new SetTraversalIdStep(0),
+						      new TraversalStep(new Object[] { c }),
+						      new SetTraversalIdStep(1),
+						      new TraversalStep(new Object[] { e }),
+						      new SetTraversalIdStep(2),
+						      new TraversalStep(),
+						      new SetTraversalIdStep(3),
+						      // -- end of regular code
+						      null, // required format, cf constructor
+						      null,  // required format, cf constructor
+						      null  // required format, cf constructor
+					      });
+		Assertion.doAssert(asr);
+		assertTrue(asr.traversalOverlapped(1));
+		assertTrue(asr.traversalOverlapped(2));
+	}
+
+	public void
+	testPositiveExclude()
+	{
+		// Specification:
+		//   X_c+e
+		resetCounters();
+
+		Node a = new Node(null, null);
+		Node b = new Node(null, a);
+		Node c = new Node(null, b);
+		Node d = new Node(null, new Node(null, null));
+		Node e = new Node(null, d);
+		// c -> b -> a
+		// e -> d -> fresh
+
+		Assertion asr = new Assertion(new PredicateFamily[] {},
+					    new Step[] {
+						    null, // required format, cf constructor
+						    // -- regular code
+						    new SetTraversalIdStep(0),
+						    new TraversalStep(new Object[] { c }),
+						    new SetTraversalIdStep(1),
+						    new TraversalStep(new Object[] { e }),
+						    new SetTraversalIdStep(2),
+						    new TraversalStep(),
+						    new SetTraversalIdStep(3),
+						    // -- end of regular code
+						    null, // required format, cf constructor
+						    null,  // required format, cf constructor
+						    null  // required format, cf constructor
+					    });
+		Assertion.doAssert(asr);
+		assertFalse(asr.traversalOverlapped(1));
+		assertTrue(asr.traversalOverlapped(2));
+	}
+
+
+	// --------------------------------------------------------------------------------
+
+	public void
+	testMultiExclude()
+	{
+		// Specification:
+		//   X_a+b+c
+		resetCounters();
+
+		Node a = new Node(null, new Node(null, new Node(null, null)));
+		Node b = new Node(null, new Node(null, new Node(null, null)));
+		Node c = new Node(null, new Node(null, new Node(null, null)));
+		// a -> * -> *
+		// b -> * -> *
+		// c -> * -> *
+
+		Assertion asr = new Assertion(new PredicateFamily[] {},
+					    new Step[] {
+						    null, // required format, cf constructor
+						    // -- regular code
+						    new SetTraversalIdStep(0),
+						    new TraversalStep(new Object[] { a }),
+						    new SetTraversalIdStep(1),
+						    new TraversalStep(new Object[] { b }),
+						    new SetTraversalIdStep(2),
+						    new TraversalStep(new Object[] { c }),
+						    new SetTraversalIdStep(3),
+						    new TraversalStep(),
+						    new SetTraversalIdStep(4),
+						    // -- end of regular code
+						    null, // required format, cf constructor
+						    null,  // required format, cf constructor
+						    null  // required format, cf constructor
+					    });
+		Assertion.doAssert(asr);
+		assertFalse(asr.traversalOverlapped(1));
+		assertFalse(asr.traversalOverlapped(2));
+		assertTrue(asr.traversalOverlapped(3));
+	}
+
+
+	public void
+	testPartExclude()
+	{
+		// Specification:
+		//   X_a+b && !X_{a,b}+c
+		resetCounters();
+
+		Node k = new Node(null, null);
+		Node a = new Node(null, new Node(null, new Node(null, null)));
+		Node b = new Node(null, new Node(null, new Node(null, k)));
+		Node c = new Node(null, new Node(null, new Node(k, null)));
+		// a -> * -> *
+		// b -> * -> * -> k
+		// c -> * -> * -> k
+
+		Assertion asr = new Assertion(new PredicateFamily[] {},
+					    new Step[] {
+						    null, // required format, cf constructor
+						    // -- regular code
+						    new SetTraversalIdStep(0),
+						    new TraversalStep(new Object[] { a }),
+						    new SetTraversalIdStep(1),
+						    new TraversalStep(new Object[] { b }),
+						    new SetTraversalIdStep(2),
+						    new TraversalStep(new Object[] { c }),
+						    new SetTraversalIdStep(3),
+						    new TraversalStep(),
+						    new SetTraversalIdStep(4),
+						    // -- end of regular code
+						    null, // required format, cf constructor
+						    null,  // required format, cf constructor
+						    null  // required format, cf constructor
+					    });
+		Assertion.doAssert(asr);
+		assertFalse(asr.traversalOverlapped(1));
+		assertTrue(asr.traversalOverlapped(2));
+		assertTrue(asr.traversalOverlapped(3));
+	}
+
+	public void
+	testDisjointnessOfExcludedNodes()
+	{
+		// Specification:
+		//   X_a+b && !X_{a,b}+c
+		resetCounters();
+
+		Node a = constructA();
+		// a -> * -> *
+
+		Assertion asr = new Assertion(new PredicateFamily[] {},
+					    new Step[] {
+						    null, // required format, cf constructor
+						    // -- regular code
+						    new SetTraversalIdStep(1),
+						    new TraversalStep(new Object[] { a }),
+						    new SetTraversalIdStep(2),
+						    new ExcludeNodesStep(new Object[] { a }),
+						    new TraversalStep(),
+						    new IncludeNodesStep(new Object[] { a }),
+						    new SetTraversalIdStep(0),
+						    // -- end of regular code
+						    null, // required format, cf constructor
+						    null,  // required format, cf constructor
+						    null  // required format, cf constructor
+					    });
+		Assertion.doAssert(asr);
+		assertFalse(asr.traversalOverlapped(1));
+		assertFalse(asr.traversalOverlapped(2));
+		assertFalse(asr.traversalOverlapped(3));
+	}
+	public static Node constructA()
+	{
+		return new Node(null, new Node(null, new Node(null, null)));
+	}
+
+	public void
+	testStress0()
+	{
+		for (int i = 0; i < 63; i++)
+			testUniversalReachability();
+	}
+
+
+	public void
+	testStress1()
+	{
+		for (int i = 0; i < 63; i++)
+			testDominance();
+	}
+
+
+	public void
+	testStress2()
+	{
+		for (int i = 0; i < 63; i++)
+			testNegativeExclude();
+	}
+
+
+	public void
+	testStress3()
+	{
+		for (int i = 0; i < 63; i++)
+			testPartExclude();
+	}
+
+}
diff -ruN jikesrvm-3.1.0/gtest/bytecode-hack/sound/C.java jikesrvm-3.1.0-gcassertions/gtest/bytecode-hack/sound/C.java
--- jikesrvm-3.1.0/gtest/bytecode-hack/sound/C.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/gtest/bytecode-hack/sound/C.java	2010-02-03 16:32:33.000000000 +0000
@@ -0,0 +1,8 @@
+public class C
+{
+	// visibility of this changes in the unsound case
+	public static void f()
+	{
+		System.out.println("Foo!");
+	}
+}
\ No newline at end of file
diff -ruN jikesrvm-3.1.0/gtest/bytecode-hack/sound/Test.java jikesrvm-3.1.0-gcassertions/gtest/bytecode-hack/sound/Test.java
--- jikesrvm-3.1.0/gtest/bytecode-hack/sound/Test.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/gtest/bytecode-hack/sound/Test.java	2010-02-03 16:34:50.000000000 +0000
@@ -0,0 +1,11 @@
+import org.vmmagic.pragma.SkipBytecodeVerifier;
+
+public class Test
+{
+	
+	@SkipBytecodeVerifier
+	public static void main(String[] _)
+	{
+		C.f();
+	}
+}
\ No newline at end of file
diff -ruN jikesrvm-3.1.0/gtest/bytecode-hack/unsound/C.java jikesrvm-3.1.0-gcassertions/gtest/bytecode-hack/unsound/C.java
--- jikesrvm-3.1.0/gtest/bytecode-hack/unsound/C.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/gtest/bytecode-hack/unsound/C.java	2010-02-03 18:03:16.000000000 +0000
@@ -0,0 +1,7 @@
+public class C
+{
+	private static void f()
+	{
+		System.out.println("Unsound Foo!");
+	}
+}
\ No newline at end of file
diff -ruN jikesrvm-3.1.0/gtest/test-trace.awk jikesrvm-3.1.0-gcassertions/gtest/test-trace.awk
--- jikesrvm-3.1.0/gtest/test-trace.awk	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/gtest/test-trace.awk	2010-01-23 00:20:02.000000000 +0000
@@ -0,0 +1,34 @@
+#! /usr/bin/awk -f
+
+function print_tcount()
+{
+    printf "  Added: %d + %d root\n", tcount, trootcount;
+    tcount = 0;
+    trootcount = 0;
+}
+
+/collectionPhase/ {
+    print_tcount();
+    phase = $2 $3 "(" ++phase_counter ")";
+    print;
+}
+
+/@@tracing/ {
+    tcount++;
+    obj = $2;
+    if (traceset[$2])
+	printf "!! Re-encountered object %s from %s in %s\n", obj, traceset[$2], phase;
+    traceset[obj] = phase;
+}
+
+/@@root/ {
+    trootcount++;
+    obj = $2;
+    if (traceset[$2])
+	printf "!! Re-encountered root %s from %s in %s\n", obj, traceset[$2], phase;
+    traceset[obj] = phase;
+}
+
+END {
+    print_tcount();
+}
\ No newline at end of file
diff -ruN jikesrvm-3.1.0/rvm/src/org/jikesrvm/OptTableMagic.java jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/OptTableMagic.java
--- jikesrvm-3.1.0/rvm/src/org/jikesrvm/OptTableMagic.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/OptTableMagic.java	2010-01-29 17:23:58.000000000 +0000
@@ -0,0 +1,68 @@
+package org.jikesrvm;
+
+import org.vmmagic.pragma.*;
+import org.vmmagic.unboxed.*;
+import org.jikesrvm.compilers.common.CompiledMethod;
+
+import org.jikesrvm.classloader.RVMClass;
+import org.jikesrvm.classloader.RVMMethod;
+
+/**
+ * A magic table 
+ */
+public class OptTableMagic
+{
+  private static AddressArray address_table = AddressArray.create(1 /* initial table size */);
+  private static int addresses_allocated = 0;
+
+
+  public static final int
+  registerStaticMethodHook(Class c, int index)
+  {
+    if (addresses_allocated >= address_table.length()) {
+      AddressArray new_table = AddressArray.create(address_table.length() * 2);
+
+      // I don't trust arraycopy to do this right... besides, this is very rare.
+      for (int i = 0; i < address_table.length(); i++)
+	new_table.set(i, address_table.get(i));
+
+      address_table = new_table;
+    }
+
+    final RVMClass type = (RVMClass)JikesRVMSupport.getTypeForClass(c);
+    final RVMMethod method = type.getStaticMethods()[index];
+
+    method.compile();
+    CompiledMethod cm = method.getCurrentCompiledMethod();
+    while (cm == null) {
+      method.compile();
+      cm = method.getCurrentCompiledMethod();
+    }
+
+    Address a = ObjectReference.fromObject(cm.getEntryCodeArray()).toAddress();
+
+    address_table.set(addresses_allocated, a);
+//     System.err.println("OptTableMagic: " + method + " -> " + addresses_allocated);
+    return addresses_allocated++;
+  }
+
+  public static final void
+  debugOffset(Object _, Object[] __, Address a)
+  {
+    System.err.println("DO = " + a.toInt());
+  }
+
+  public static final Address
+  lookupStaticMethodHook(int index)
+  {
+    if (index < 0 || index >= addresses_allocated)
+      System.err.println("OptTableMagic.lookupStaticMethodHook(" + index + "): invalid index\n");
+    return address_table.get(index);
+  }
+
+  public static final void
+  flushStaticMethodHooks()
+  {
+    addresses_allocated = 0;
+  }
+}
\ No newline at end of file
diff -ruN jikesrvm-3.1.0/rvm/src/org/jikesrvm/classloader/Atom.java jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/classloader/Atom.java
--- jikesrvm-3.1.0/rvm/src/org/jikesrvm/classloader/Atom.java	2009-04-24 16:11:25.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/classloader/Atom.java	2010-02-07 14:35:27.000000000 +0000
@@ -275,7 +275,7 @@
     } else {
       if (VM.runningVM) {
         Object result = Statics.getSlotContentsAsObject(Offset.fromIntSignExtend((Integer)unicodeStringOrJTOCoffset));
-        return (String)result;
+	return (String)result;
       } else {
         try {
           return UTF8Convert.fromUTF8(val).intern();
diff -ruN jikesrvm-3.1.0/rvm/src/org/jikesrvm/classloader/DynamicTypeCheck.java jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/classloader/DynamicTypeCheck.java
--- jikesrvm-3.1.0/rvm/src/org/jikesrvm/classloader/DynamicTypeCheck.java	2009-04-24 16:11:25.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/classloader/DynamicTypeCheck.java	2010-02-08 15:25:09.000000000 +0000
@@ -214,6 +214,7 @@
    * @return <code>true</code> if the object is an instance of LHSClass
    *         or <code>false</code> if it is not
    */
+  @Uninterruptible
   public static boolean instanceOfNonArray(RVMClass LHSclass, TIB rhsTIB) {
     if (LHSclass.isInterface()) {
       return instanceOfInterface(LHSclass, rhsTIB);
@@ -253,10 +254,11 @@
    * @return <code>true</code> if the object is an instance of LHSClass
    *         or <code>false</code> if it is not
    */
+  @Uninterruptible
   public static boolean instanceOfInterface(RVMClass LHSclass, TIB rhsTIB) {
     int[] doesImplement = rhsTIB.getDoesImplement();
-    int idx = LHSclass.getDoesImplementIndex();
-    int mask = LHSclass.getDoesImplementBitMask();
+    int idx = LHSclass.uninterruptibleGetDoesImplementIndex();
+    int mask = LHSclass.uninterruptibleGetDoesImplementBitMask();
     return idx < doesImplement.length && ((doesImplement[idx] & mask) != 0);
   }
 
@@ -270,6 +272,7 @@
    *         RHSType into a variable of type LSType
    *         or <code>false</code> if we cannot.
    */
+  @Uninterruptible
   public static boolean instanceOfResolved(RVMType LHSType, RVMType RHSType) {
     int LHSDimension = LHSType.getDimensionality();
     int RHSDimension = RHSType.getDimensionality();
diff -ruN jikesrvm-3.1.0/rvm/src/org/jikesrvm/classloader/RVMClass.java jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/classloader/RVMClass.java
--- jikesrvm-3.1.0/rvm/src/org/jikesrvm/classloader/RVMClass.java	2009-05-07 12:54:35.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/classloader/RVMClass.java	2010-02-08 15:25:09.000000000 +0000
@@ -132,7 +132,7 @@
 
   /** The desired alignment for instances of this type. */
   private int alignment;
-
+  
   /**
    * A field layout helper - used to keep context regarding field layouts.
    * Managed by the field layout objects in the ObjectModel.
@@ -1749,6 +1749,7 @@
     if (interfaceId == -1) {
       assignInterfaceId();
     }
+    if (VM.VerifyAssertions) VM._assert(this.interfaceId != -1);
     return interfaceId;
   }
 
@@ -1760,6 +1761,27 @@
     return 1 << (getInterfaceId() & 31);
   }
 
+  // Alternative versions of the three most recent methods for the uninterruptible case (requires interfaces to have been loaded)
+  @Uninterruptible
+  public int uninterruptibleGetInterfaceId() {
+//     if (interfaceId == -1) {
+//       assignInterfaceId();
+//     }
+    if (VM.VerifyAssertions) VM._assert(this.interfaceId != -1);
+    return interfaceId;
+  }
+
+  @Uninterruptible
+  public int uninterruptibleGetDoesImplementIndex() {
+    return uninterruptibleGetInterfaceId() >>> 5;
+  }
+
+  @Uninterruptible
+  public int uninterruptibleGetDoesImplementBitMask() {
+    return 1 << (uninterruptibleGetInterfaceId() & 31);
+  }
+
+  @Uninterruptible
   public static RVMClass getInterface(int id) {
     return interfaces[id];
   }
diff -ruN jikesrvm-3.1.0/rvm/src/org/jikesrvm/classloader/TypeReference.java jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/classloader/TypeReference.java
--- jikesrvm-3.1.0/rvm/src/org/jikesrvm/classloader/TypeReference.java	2009-04-24 16:11:25.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/classloader/TypeReference.java	2010-01-25 21:15:45.000000000 +0000
@@ -117,6 +117,7 @@
   public static final TypeReference ExtentArray = findOrCreate(org.vmmagic.unboxed.ExtentArray.class);
   public static final TypeReference CodeArray = findOrCreate(org.jikesrvm.ArchitectureSpecific.CodeArray.class);
   public static final TypeReference Magic = findOrCreate(org.jikesrvm.runtime.Magic.class);
+  public static final TypeReference StaticOptTable = findOrCreate(org.vmmagic.StaticOptTable.class);
   public static final TypeReference SysCall = findOrCreate(org.vmmagic.pragma.SysCallNative.class);
   public static final TypeReference TIB = findOrCreate(org.jikesrvm.objectmodel.TIB.class);
   public static final TypeReference ITableArray = findOrCreate(org.jikesrvm.objectmodel.ITableArray.class);
@@ -554,7 +555,7 @@
    */
   @Uninterruptible
   public boolean isMagicType() {
-    return this == Magic || isUnboxedType() || isUnboxedArrayType() || this == ObjectReference || isRuntimeTable();
+    return this == Magic || isUnboxedType() || isUnboxedArrayType() || this == ObjectReference || isRuntimeTable() || this == StaticOptTable;
   }
 
   /**
diff -ruN jikesrvm-3.1.0/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineMagic.java jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineMagic.java
--- jikesrvm-3.1.0/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineMagic.java	2009-05-20 04:31:10.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineMagic.java	2010-01-27 14:34:58.000000000 +0000
@@ -1651,6 +1651,73 @@
   }
 
   /**
+   * Register method with the OptTableMagic
+   */
+  private static final class RegisterOptTableMagic extends MagicGenerator {
+    @Override
+    void generateMagic(Assembler asm, MethodReference m, RVMMethod cm, Offset sd) {
+      Offset offset = ArchEntrypoints.registerStaticMethodHook.getOffset();
+      BaselineCompilerImpl.genParameterRegisterLoad(asm, 2); // pass 2 parameter words
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(offset));
+      asm.emitPUSH_Reg(T0);
+    }
+  }
+  static {
+    MagicGenerator g = new RegisterOptTableMagic();
+    generators.put(getMethodReference(org.vmmagic.StaticOptTable.class, MagicNames.registerStaticMethodHook, Class.class, int.class, int.class), g);
+  }
+
+  /**
+   * Lookup method offset from the OptTableMagic
+   */
+  private static final class LookupOptTableMagic extends MagicGenerator {
+    @Override
+    void generateMagic(Assembler asm, MethodReference m, RVMMethod cm, Offset sd) {
+      Offset offset = ArchEntrypoints.lookupStaticMethodHook.getOffset();
+      BaselineCompilerImpl.genParameterRegisterLoad(asm, 1); // pass 1 parameter word
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(offset));
+      asm.emitPUSH_Reg(T0);
+    }
+  }
+  static {
+    MagicGenerator g = new LookupOptTableMagic();
+    generators.put(getMethodReference(org.vmmagic.StaticOptTable.class, MagicNames.lookupStaticMethodHook, int.class, Address.class), g);
+  }
+
+  /**
+   * Flush OptTableMagic
+   */
+  private static final class FlushOptTableMagic extends MagicGenerator {
+    @Override
+    void generateMagic(Assembler asm, MethodReference m, RVMMethod cm, Offset sd) {
+      Offset offset = ArchEntrypoints.flushStaticMethodHooks.getOffset();
+      asm.emitCALL_Abs(Magic.getTocPointer().plus(offset));
+    }
+  }
+  static {
+    MagicGenerator g = new FlushOptTableMagic();
+    generators.put(getMethodReference(org.vmmagic.StaticOptTable.class, MagicNames.flushStaticMethodHooks, void.class), g);
+  }
+
+  /**
+   * Call method at offset
+   */
+  private static final class CallAtOffsetMagic extends MagicGenerator {
+    @Override
+    void generateMagic(Assembler asm, MethodReference m, RVMMethod cm, Offset sd) {
+      GPR jump_target_register = VM.BuildFor32Addr ? S0 : T0;
+      asm.emitPOP_Reg(jump_target_register);
+      BaselineCompilerImpl.genParameterRegisterLoad(asm, 2); // pass the other two parameter words
+      asm.emitCALL_Reg(jump_target_register);
+      asm.emitPUSH_Reg(T0);
+    }
+  }
+  static {
+    MagicGenerator g = new CallAtOffsetMagic();
+    generators.put(getMethodReference(org.vmmagic.StaticOptTable.class, MagicNames.invokeStaticMethod, Object.class, Object[].class, Address.class, boolean.class), g);
+  }
+
+  /**
    * Invoke an entry point taking values off of the stack
    */
   private static final class InvokeEntryPoint extends MagicGenerator {
diff -ruN jikesrvm-3.1.0/rvm/src/org/jikesrvm/compilers/opt/bc2ir/GenerateMagic.java jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/compilers/opt/bc2ir/GenerateMagic.java
--- jikesrvm-3.1.0/rvm/src/org/jikesrvm/compilers/opt/bc2ir/GenerateMagic.java	2009-04-24 15:50:38.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/compilers/opt/bc2ir/GenerateMagic.java	2010-01-26 19:47:25.000000000 +0000
@@ -71,6 +71,7 @@
 import org.jikesrvm.ArchitectureSpecificOpt.GenerateMachineSpecificMagic;
 import org.jikesrvm.classloader.Atom;
 import org.jikesrvm.classloader.RVMField;
+import org.jikesrvm.classloader.RVMMethod;
 import org.jikesrvm.classloader.MemberReference;
 import org.jikesrvm.classloader.MethodReference;
 import org.jikesrvm.classloader.TypeReference;
@@ -605,6 +606,42 @@
     } else if (methodName == MagicNames.invokeClassInitializer) {
       Instruction s = Call.create0(CALL, null, bc2ir.popRef(), null);
       bc2ir.appendInstruction(s);
+    } else if (methodName == MagicNames.registerStaticMethodHook) {
+      Operand b = bc2ir.popRef();
+      Operand a = bc2ir.popRef();
+      RegisterOperand res = gc.temps.makeTempInt();
+      bc2ir.push(res.copyD2U());
+
+      RVMMethod target = ArchEntrypoints.registerStaticMethodHook;
+      MethodOperand met = MethodOperand.STATIC(target);
+      Instruction s =
+	Call.create2(CALL, res, new AddressConstantOperand(target.getOffset()), met, a, b);
+      bc2ir.appendInstruction(s);
+    } else if (methodName == MagicNames.lookupStaticMethodHook) {
+      Operand a = bc2ir.popRef();
+      RegisterOperand res = gc.temps.makeTempOffset();
+      bc2ir.push(res.copyD2U());
+
+      RVMMethod target = ArchEntrypoints.lookupStaticMethodHook;
+      MethodOperand met = MethodOperand.STATIC(target);
+      Instruction s =
+	Call.create1(CALL, res, new AddressConstantOperand(target.getOffset()), met, a);
+      bc2ir.appendInstruction(s);
+    } else if (methodName == MagicNames.flushStaticMethodHooks) {
+      RVMMethod target = ArchEntrypoints.flushStaticMethodHooks;
+      MethodOperand met = MethodOperand.STATIC(target);
+      Instruction s =
+	Call.create0(CALL, null, new AddressConstantOperand(target.getOffset()), met);
+      bc2ir.appendInstruction(s);
+    } else if (methodName == MagicNames.invokeStaticMethod) {
+      Operand target = bc2ir.popRef();
+      Operand env = bc2ir.popRef();
+      Operand object = bc2ir.popRef();
+      RegisterOperand res = gc.temps.makeTempBoolean();
+      bc2ir.push(res.copyD2U());
+      Instruction s =
+	Call.create2(CALL, res, target, null /* fixme */, object, env);
+      bc2ir.appendInstruction(s);
     } else if ((methodName == MagicNames.invokeMethodReturningObject) ||
                (methodName == MagicNames.invokeMethodReturningVoid) ||
                (methodName == MagicNames.invokeMethodReturningLong) ||
diff -ruN jikesrvm-3.1.0/rvm/src/org/jikesrvm/runtime/ArchEntrypoints.java jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/runtime/ArchEntrypoints.java
--- jikesrvm-3.1.0/rvm/src/org/jikesrvm/runtime/ArchEntrypoints.java	2009-04-24 16:17:42.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/runtime/ArchEntrypoints.java	2010-01-26 18:23:40.000000000 +0000
@@ -12,6 +12,7 @@
  */
 package org.jikesrvm.runtime;
 
+import org.jikesrvm.OptTableMagic;
 import org.jikesrvm.VM;
 import org.jikesrvm.classloader.RVMField;
 import org.jikesrvm.classloader.NormalMethod;
@@ -64,4 +65,14 @@
       (VM.BuildForIA32) ? EntrypointHelper.getField("Lorg/jikesrvm/scheduler/RVMThread;", "hiddenSignatureId", "I") : null;
   RVMField arrayIndexTrapParamField =
       (VM.BuildForIA32) ? EntrypointHelper.getField("Lorg/jikesrvm/scheduler/RVMThread;", "arrayIndexTrapParam", "I") : null;
+
+
+  NormalMethod registerStaticMethodHook =
+    EntrypointHelper.getMethod("Lorg/jikesrvm/OptTableMagic;", "registerStaticMethodHook", "(Ljava/lang/Class;I)I");
+  NormalMethod flushStaticMethodHooks =
+    EntrypointHelper.getMethod("Lorg/jikesrvm/OptTableMagic;", "flushStaticMethodHooks", "()V");
+  NormalMethod lookupStaticMethodHook =
+    EntrypointHelper.getMethod("Lorg/jikesrvm/OptTableMagic;", "lookupStaticMethodHook", "(I)Lorg/vmmagic/unboxed/Address;");
+  NormalMethod debugOffset =
+    EntrypointHelper.getMethod("Lorg/jikesrvm/OptTableMagic;", "debugOffset", "(Ljava/lang/Object;[Ljava/lang/Object;Lorg/vmmagic/unboxed/Address;)V");
 }
diff -ruN jikesrvm-3.1.0/rvm/src/org/jikesrvm/runtime/MagicNames.java jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/runtime/MagicNames.java
--- jikesrvm-3.1.0/rvm/src/org/jikesrvm/runtime/MagicNames.java	2009-04-24 16:17:42.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/runtime/MagicNames.java	2010-01-25 23:08:16.000000000 +0000
@@ -190,4 +190,11 @@
   public static final Atom addressArrayLength = Atom.findOrCreateAsciiAtom("length");
   public static final Atom addressArrayGet = Atom.findOrCreateAsciiAtom("get");
   public static final Atom addressArraySet = Atom.findOrCreateAsciiAtom("set");
+
+  // atoms related to method MMTk-into-RVM invocation hooks
+  public static final Atom registerStaticMethodHook = Atom.findOrCreateAsciiAtom("registerStaticMethodHook");
+  public static final Atom lookupStaticMethodHook = Atom.findOrCreateAsciiAtom("lookupStaticMethodHook");
+  public static final Atom flushStaticMethodHooks = Atom.findOrCreateAsciiAtom("flushStaticMethodHooks");
+  public static final Atom invokeStaticMethod = Atom.findOrCreateAsciiAtom("invokeStaticMethod");
 }
+
diff -ruN jikesrvm-3.1.0/rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java
--- jikesrvm-3.1.0/rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java	2009-04-24 16:17:42.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/rvm/src/org/jikesrvm/runtime/RuntimeEntrypoints.java	2010-02-08 15:25:09.000000000 +0000
@@ -843,6 +843,7 @@
     throw new java.lang.AbstractMethodError();
   }
 
+
   /**
    * Create and throw a java.lang.IllegalAccessError.
    * Used to handle error cases in invokeinterface dispatching.
Binary files jikesrvm-3.1.0/scratch/jar/janino-2.5.12.jar and jikesrvm-3.1.0-gcassertions/scratch/jar/janino-2.5.12.jar differ
Binary files jikesrvm-3.1.0/scratch/jar/sunflow-0.07.2.jar and jikesrvm-3.1.0-gcassertions/scratch/jar/sunflow-0.07.2.jar differ
diff -ruN jikesrvm-3.1.0/tools/bootImageRunner/RunBootImage.C jikesrvm-3.1.0-gcassertions/tools/bootImageRunner/RunBootImage.C
--- jikesrvm-3.1.0/tools/bootImageRunner/RunBootImage.C	2009-04-24 15:05:13.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/tools/bootImageRunner/RunBootImage.C	2010-01-20 23:21:21.000000000 +0000
@@ -403,7 +403,8 @@
 int
 main(int argc, const char **argv)
 {
-    Me            = strrchr(*argv, '/') + 1;
+    const char *c = strrchr(*argv, '/') + 1;
+    Me            = (char *)c;
     ++argv, --argc;
     initialHeapSize = heap_default_initial_size;
     maximumHeapSize = heap_default_maximum_size;
diff -ruN jikesrvm-3.1.0/tools/bootImageWriter/vmmagic/src/org/vmmagic/StaticOptTable.java jikesrvm-3.1.0-gcassertions/tools/bootImageWriter/vmmagic/src/org/vmmagic/StaticOptTable.java
--- jikesrvm-3.1.0/tools/bootImageWriter/vmmagic/src/org/vmmagic/StaticOptTable.java	1970-01-01 00:00:00.000000000 +0000
+++ jikesrvm-3.1.0-gcassertions/tools/bootImageWriter/vmmagic/src/org/vmmagic/StaticOptTable.java	2010-01-26 18:33:02.000000000 +0000
@@ -0,0 +1,27 @@
+package org.vmmagic;
+
+import org.vmmagic.unboxed.Address;
+
+public class StaticOptTable
+{
+
+  /* [CR]
+   * Magic method table operations
+   */
+
+  /** Opt-compile method and return a handle to it for later use. */
+  public static int registerStaticMethodHook(Class<?> c, int static_method_index) {
+    return -1;
+  }
+
+  public static Address lookupStaticMethodHook(int hook) {
+    return null;
+  }
+
+  public static void flushStaticMethodHooks() {
+  }
+
+  public static boolean invokeStaticMethod(Object param1, Object[] param2, Address address) {
+    return false;
+  }
+}
\ No newline at end of file
